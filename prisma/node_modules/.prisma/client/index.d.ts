
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model MBSCD
 * 
 */
export type MBSCD = $Result.DefaultSelection<Prisma.$MBSCDPayload>
/**
 * Model BSCD
 * 
 */
export type BSCD = $Result.DefaultSelection<Prisma.$BSCDPayload>
/**
 * Model MACNO
 * 
 */
export type MACNO = $Result.DefaultSelection<Prisma.$MACNOPayload>
/**
 * Model ACNO
 * 
 */
export type ACNO = $Result.DefaultSelection<Prisma.$ACNOPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CostCenter
 * 
 */
export type CostCenter = $Result.DefaultSelection<Prisma.$CostCenterPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model ProductMasterCategory
 * 
 */
export type ProductMasterCategory = $Result.DefaultSelection<Prisma.$ProductMasterCategoryPayload>
/**
 * Model ProductGroup
 * 
 */
export type ProductGroup = $Result.DefaultSelection<Prisma.$ProductGroupPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model MainCategory
 * 
 */
export type MainCategory = $Result.DefaultSelection<Prisma.$MainCategoryPayload>
/**
 * Model ItemCategory
 * 
 */
export type ItemCategory = $Result.DefaultSelection<Prisma.$ItemCategoryPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model Designation
 * 
 */
export type Designation = $Result.DefaultSelection<Prisma.$DesignationPayload>
/**
 * Model Godown
 * 
 */
export type Godown = $Result.DefaultSelection<Prisma.$GodownPayload>
/**
 * Model FinancialYear
 * 
 */
export type FinancialYear = $Result.DefaultSelection<Prisma.$FinancialYearPayload>
/**
 * Model Season
 * 
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model PoPrdCat
 * 
 */
export type PoPrdCat = $Result.DefaultSelection<Prisma.$PoPrdCatPayload>
/**
 * Model DeliveryMode
 * 
 */
export type DeliveryMode = $Result.DefaultSelection<Prisma.$DeliveryModePayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model TransactionsMaster
 * 
 */
export type TransactionsMaster = $Result.DefaultSelection<Prisma.$TransactionsMasterPayload>
/**
 * Model Transactions
 * 
 */
export type Transactions = $Result.DefaultSelection<Prisma.$TransactionsPayload>
/**
 * Model DeliveryTerm
 * 
 */
export type DeliveryTerm = $Result.DefaultSelection<Prisma.$DeliveryTermPayload>
/**
 * Model CommissionTerm
 * 
 */
export type CommissionTerm = $Result.DefaultSelection<Prisma.$CommissionTermPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Employer
 * 
 */
export type Employer = $Result.DefaultSelection<Prisma.$EmployerPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type Status = (typeof Status)[keyof typeof Status]


export const PaymentMethod: {
  CASH: 'CASH',
  DIRECT_DEPOSIT: 'DIRECT_DEPOSIT',
  CHEQUE: 'CHEQUE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PayType: {
  HOUR: 'HOUR',
  SALARY: 'SALARY'
};

export type PayType = (typeof PayType)[keyof typeof PayType]


export const PayFrequency: {
  Monthly: 'Monthly',
  Fortnightly: 'Fortnightly',
  Weekly: 'Weekly'
};

export type PayFrequency = (typeof PayFrequency)[keyof typeof PayFrequency]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PayType = $Enums.PayType

export const PayType: typeof $Enums.PayType

export type PayFrequency = $Enums.PayFrequency

export const PayFrequency: typeof $Enums.PayFrequency

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more MBSCDS
 * const mBSCDS = await prisma.mBSCD.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more MBSCDS
   * const mBSCDS = await prisma.mBSCD.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.mBSCD`: Exposes CRUD operations for the **MBSCD** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MBSCDS
    * const mBSCDS = await prisma.mBSCD.findMany()
    * ```
    */
  get mBSCD(): Prisma.MBSCDDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bSCD`: Exposes CRUD operations for the **BSCD** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BSCDS
    * const bSCDS = await prisma.bSCD.findMany()
    * ```
    */
  get bSCD(): Prisma.BSCDDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mACNO`: Exposes CRUD operations for the **MACNO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MACNOS
    * const mACNOS = await prisma.mACNO.findMany()
    * ```
    */
  get mACNO(): Prisma.MACNODelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aCNO`: Exposes CRUD operations for the **ACNO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ACNOS
    * const aCNOS = await prisma.aCNO.findMany()
    * ```
    */
  get aCNO(): Prisma.ACNODelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costCenter`: Exposes CRUD operations for the **CostCenter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostCenters
    * const costCenters = await prisma.costCenter.findMany()
    * ```
    */
  get costCenter(): Prisma.CostCenterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productMasterCategory`: Exposes CRUD operations for the **ProductMasterCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductMasterCategories
    * const productMasterCategories = await prisma.productMasterCategory.findMany()
    * ```
    */
  get productMasterCategory(): Prisma.ProductMasterCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productGroup`: Exposes CRUD operations for the **ProductGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductGroups
    * const productGroups = await prisma.productGroup.findMany()
    * ```
    */
  get productGroup(): Prisma.ProductGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mainCategory`: Exposes CRUD operations for the **MainCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MainCategories
    * const mainCategories = await prisma.mainCategory.findMany()
    * ```
    */
  get mainCategory(): Prisma.MainCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCategory`: Exposes CRUD operations for the **ItemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategories
    * const itemCategories = await prisma.itemCategory.findMany()
    * ```
    */
  get itemCategory(): Prisma.ItemCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designation`: Exposes CRUD operations for the **Designation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Designations
    * const designations = await prisma.designation.findMany()
    * ```
    */
  get designation(): Prisma.DesignationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.godown`: Exposes CRUD operations for the **Godown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Godowns
    * const godowns = await prisma.godown.findMany()
    * ```
    */
  get godown(): Prisma.GodownDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialYear`: Exposes CRUD operations for the **FinancialYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialYears
    * const financialYears = await prisma.financialYear.findMany()
    * ```
    */
  get financialYear(): Prisma.FinancialYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poPrdCat`: Exposes CRUD operations for the **PoPrdCat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PoPrdCats
    * const poPrdCats = await prisma.poPrdCat.findMany()
    * ```
    */
  get poPrdCat(): Prisma.PoPrdCatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryMode`: Exposes CRUD operations for the **DeliveryMode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryModes
    * const deliveryModes = await prisma.deliveryMode.findMany()
    * ```
    */
  get deliveryMode(): Prisma.DeliveryModeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionsMaster`: Exposes CRUD operations for the **TransactionsMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionsMasters
    * const transactionsMasters = await prisma.transactionsMaster.findMany()
    * ```
    */
  get transactionsMaster(): Prisma.TransactionsMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **Transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.TransactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryTerm`: Exposes CRUD operations for the **DeliveryTerm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryTerms
    * const deliveryTerms = await prisma.deliveryTerm.findMany()
    * ```
    */
  get deliveryTerm(): Prisma.DeliveryTermDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commissionTerm`: Exposes CRUD operations for the **CommissionTerm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommissionTerms
    * const commissionTerms = await prisma.commissionTerm.findMany()
    * ```
    */
  get commissionTerm(): Prisma.CommissionTermDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employer`: Exposes CRUD operations for the **Employer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employers
    * const employers = await prisma.employer.findMany()
    * ```
    */
  get employer(): Prisma.EmployerDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    MBSCD: 'MBSCD',
    BSCD: 'BSCD',
    MACNO: 'MACNO',
    ACNO: 'ACNO',
    Company: 'Company',
    CostCenter: 'CostCenter',
    Department: 'Department',
    ProductMasterCategory: 'ProductMasterCategory',
    ProductGroup: 'ProductGroup',
    ProductCategory: 'ProductCategory',
    MainCategory: 'MainCategory',
    ItemCategory: 'ItemCategory',
    Item: 'Item',
    Designation: 'Designation',
    Godown: 'Godown',
    FinancialYear: 'FinancialYear',
    Season: 'Season',
    PoPrdCat: 'PoPrdCat',
    DeliveryMode: 'DeliveryMode',
    Users: 'Users',
    Currency: 'Currency',
    TransactionsMaster: 'TransactionsMaster',
    Transactions: 'Transactions',
    DeliveryTerm: 'DeliveryTerm',
    CommissionTerm: 'CommissionTerm',
    Employee: 'Employee',
    Leave: 'Leave',
    Document: 'Document',
    Manager: 'Manager',
    Employer: 'Employer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "mBSCD" | "bSCD" | "mACNO" | "aCNO" | "company" | "costCenter" | "department" | "productMasterCategory" | "productGroup" | "productCategory" | "mainCategory" | "itemCategory" | "item" | "designation" | "godown" | "financialYear" | "season" | "poPrdCat" | "deliveryMode" | "users" | "currency" | "transactionsMaster" | "transactions" | "deliveryTerm" | "commissionTerm" | "employee" | "leave" | "document" | "manager" | "employer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      MBSCD: {
        payload: Prisma.$MBSCDPayload<ExtArgs>
        fields: Prisma.MBSCDFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MBSCDFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MBSCDFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>
          }
          findFirst: {
            args: Prisma.MBSCDFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MBSCDFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>
          }
          findMany: {
            args: Prisma.MBSCDFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>[]
          }
          create: {
            args: Prisma.MBSCDCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>
          }
          createMany: {
            args: Prisma.MBSCDCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MBSCDCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>[]
          }
          delete: {
            args: Prisma.MBSCDDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>
          }
          update: {
            args: Prisma.MBSCDUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>
          }
          deleteMany: {
            args: Prisma.MBSCDDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MBSCDUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MBSCDUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>[]
          }
          upsert: {
            args: Prisma.MBSCDUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MBSCDPayload>
          }
          aggregate: {
            args: Prisma.MBSCDAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMBSCD>
          }
          groupBy: {
            args: Prisma.MBSCDGroupByArgs<ExtArgs>
            result: $Utils.Optional<MBSCDGroupByOutputType>[]
          }
          count: {
            args: Prisma.MBSCDCountArgs<ExtArgs>
            result: $Utils.Optional<MBSCDCountAggregateOutputType> | number
          }
        }
      }
      BSCD: {
        payload: Prisma.$BSCDPayload<ExtArgs>
        fields: Prisma.BSCDFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BSCDFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BSCDFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>
          }
          findFirst: {
            args: Prisma.BSCDFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BSCDFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>
          }
          findMany: {
            args: Prisma.BSCDFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>[]
          }
          create: {
            args: Prisma.BSCDCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>
          }
          createMany: {
            args: Prisma.BSCDCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BSCDCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>[]
          }
          delete: {
            args: Prisma.BSCDDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>
          }
          update: {
            args: Prisma.BSCDUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>
          }
          deleteMany: {
            args: Prisma.BSCDDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BSCDUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BSCDUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>[]
          }
          upsert: {
            args: Prisma.BSCDUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BSCDPayload>
          }
          aggregate: {
            args: Prisma.BSCDAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBSCD>
          }
          groupBy: {
            args: Prisma.BSCDGroupByArgs<ExtArgs>
            result: $Utils.Optional<BSCDGroupByOutputType>[]
          }
          count: {
            args: Prisma.BSCDCountArgs<ExtArgs>
            result: $Utils.Optional<BSCDCountAggregateOutputType> | number
          }
        }
      }
      MACNO: {
        payload: Prisma.$MACNOPayload<ExtArgs>
        fields: Prisma.MACNOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MACNOFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MACNOFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>
          }
          findFirst: {
            args: Prisma.MACNOFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MACNOFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>
          }
          findMany: {
            args: Prisma.MACNOFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>[]
          }
          create: {
            args: Prisma.MACNOCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>
          }
          createMany: {
            args: Prisma.MACNOCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MACNOCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>[]
          }
          delete: {
            args: Prisma.MACNODeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>
          }
          update: {
            args: Prisma.MACNOUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>
          }
          deleteMany: {
            args: Prisma.MACNODeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MACNOUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MACNOUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>[]
          }
          upsert: {
            args: Prisma.MACNOUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MACNOPayload>
          }
          aggregate: {
            args: Prisma.MACNOAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMACNO>
          }
          groupBy: {
            args: Prisma.MACNOGroupByArgs<ExtArgs>
            result: $Utils.Optional<MACNOGroupByOutputType>[]
          }
          count: {
            args: Prisma.MACNOCountArgs<ExtArgs>
            result: $Utils.Optional<MACNOCountAggregateOutputType> | number
          }
        }
      }
      ACNO: {
        payload: Prisma.$ACNOPayload<ExtArgs>
        fields: Prisma.ACNOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ACNOFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ACNOFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>
          }
          findFirst: {
            args: Prisma.ACNOFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ACNOFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>
          }
          findMany: {
            args: Prisma.ACNOFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>[]
          }
          create: {
            args: Prisma.ACNOCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>
          }
          createMany: {
            args: Prisma.ACNOCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ACNOCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>[]
          }
          delete: {
            args: Prisma.ACNODeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>
          }
          update: {
            args: Prisma.ACNOUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>
          }
          deleteMany: {
            args: Prisma.ACNODeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ACNOUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ACNOUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>[]
          }
          upsert: {
            args: Prisma.ACNOUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACNOPayload>
          }
          aggregate: {
            args: Prisma.ACNOAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateACNO>
          }
          groupBy: {
            args: Prisma.ACNOGroupByArgs<ExtArgs>
            result: $Utils.Optional<ACNOGroupByOutputType>[]
          }
          count: {
            args: Prisma.ACNOCountArgs<ExtArgs>
            result: $Utils.Optional<ACNOCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CostCenter: {
        payload: Prisma.$CostCenterPayload<ExtArgs>
        fields: Prisma.CostCenterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostCenterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostCenterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          findFirst: {
            args: Prisma.CostCenterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostCenterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          findMany: {
            args: Prisma.CostCenterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          create: {
            args: Prisma.CostCenterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          createMany: {
            args: Prisma.CostCenterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostCenterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          delete: {
            args: Prisma.CostCenterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          update: {
            args: Prisma.CostCenterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          deleteMany: {
            args: Prisma.CostCenterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostCenterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostCenterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          upsert: {
            args: Prisma.CostCenterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          aggregate: {
            args: Prisma.CostCenterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostCenter>
          }
          groupBy: {
            args: Prisma.CostCenterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostCenterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostCenterCountArgs<ExtArgs>
            result: $Utils.Optional<CostCenterCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      ProductMasterCategory: {
        payload: Prisma.$ProductMasterCategoryPayload<ExtArgs>
        fields: Prisma.ProductMasterCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductMasterCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductMasterCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductMasterCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductMasterCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductMasterCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductMasterCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductMasterCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductMasterCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductMasterCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>
          }
          update: {
            args: Prisma.ProductMasterCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductMasterCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductMasterCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductMasterCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductMasterCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMasterCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductMasterCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductMasterCategory>
          }
          groupBy: {
            args: Prisma.ProductMasterCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductMasterCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductMasterCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductMasterCategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductGroup: {
        payload: Prisma.$ProductGroupPayload<ExtArgs>
        fields: Prisma.ProductGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>
          }
          findFirst: {
            args: Prisma.ProductGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>
          }
          findMany: {
            args: Prisma.ProductGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>[]
          }
          create: {
            args: Prisma.ProductGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>
          }
          createMany: {
            args: Prisma.ProductGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>[]
          }
          delete: {
            args: Prisma.ProductGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>
          }
          update: {
            args: Prisma.ProductGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>
          }
          deleteMany: {
            args: Prisma.ProductGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>[]
          }
          upsert: {
            args: Prisma.ProductGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGroupPayload>
          }
          aggregate: {
            args: Prisma.ProductGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductGroup>
          }
          groupBy: {
            args: Prisma.ProductGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      MainCategory: {
        payload: Prisma.$MainCategoryPayload<ExtArgs>
        fields: Prisma.MainCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MainCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MainCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>
          }
          findFirst: {
            args: Prisma.MainCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MainCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>
          }
          findMany: {
            args: Prisma.MainCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>[]
          }
          create: {
            args: Prisma.MainCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>
          }
          createMany: {
            args: Prisma.MainCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MainCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>[]
          }
          delete: {
            args: Prisma.MainCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>
          }
          update: {
            args: Prisma.MainCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>
          }
          deleteMany: {
            args: Prisma.MainCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MainCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MainCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>[]
          }
          upsert: {
            args: Prisma.MainCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainCategoryPayload>
          }
          aggregate: {
            args: Prisma.MainCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMainCategory>
          }
          groupBy: {
            args: Prisma.MainCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MainCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MainCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<MainCategoryCountAggregateOutputType> | number
          }
        }
      }
      ItemCategory: {
        payload: Prisma.$ItemCategoryPayload<ExtArgs>
        fields: Prisma.ItemCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findFirst: {
            args: Prisma.ItemCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findMany: {
            args: Prisma.ItemCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          create: {
            args: Prisma.ItemCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          createMany: {
            args: Prisma.ItemCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          delete: {
            args: Prisma.ItemCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          update: {
            args: Prisma.ItemCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ItemCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          aggregate: {
            args: Prisma.ItemCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategory>
          }
          groupBy: {
            args: Prisma.ItemCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      Designation: {
        payload: Prisma.$DesignationPayload<ExtArgs>
        fields: Prisma.DesignationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          findFirst: {
            args: Prisma.DesignationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          findMany: {
            args: Prisma.DesignationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>[]
          }
          create: {
            args: Prisma.DesignationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          createMany: {
            args: Prisma.DesignationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>[]
          }
          delete: {
            args: Prisma.DesignationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          update: {
            args: Prisma.DesignationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          deleteMany: {
            args: Prisma.DesignationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>[]
          }
          upsert: {
            args: Prisma.DesignationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          aggregate: {
            args: Prisma.DesignationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignation>
          }
          groupBy: {
            args: Prisma.DesignationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignationCountArgs<ExtArgs>
            result: $Utils.Optional<DesignationCountAggregateOutputType> | number
          }
        }
      }
      Godown: {
        payload: Prisma.$GodownPayload<ExtArgs>
        fields: Prisma.GodownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GodownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GodownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>
          }
          findFirst: {
            args: Prisma.GodownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GodownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>
          }
          findMany: {
            args: Prisma.GodownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>[]
          }
          create: {
            args: Prisma.GodownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>
          }
          createMany: {
            args: Prisma.GodownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GodownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>[]
          }
          delete: {
            args: Prisma.GodownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>
          }
          update: {
            args: Prisma.GodownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>
          }
          deleteMany: {
            args: Prisma.GodownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GodownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GodownUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>[]
          }
          upsert: {
            args: Prisma.GodownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GodownPayload>
          }
          aggregate: {
            args: Prisma.GodownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGodown>
          }
          groupBy: {
            args: Prisma.GodownGroupByArgs<ExtArgs>
            result: $Utils.Optional<GodownGroupByOutputType>[]
          }
          count: {
            args: Prisma.GodownCountArgs<ExtArgs>
            result: $Utils.Optional<GodownCountAggregateOutputType> | number
          }
        }
      }
      FinancialYear: {
        payload: Prisma.$FinancialYearPayload<ExtArgs>
        fields: Prisma.FinancialYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>
          }
          findFirst: {
            args: Prisma.FinancialYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>
          }
          findMany: {
            args: Prisma.FinancialYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>[]
          }
          create: {
            args: Prisma.FinancialYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>
          }
          createMany: {
            args: Prisma.FinancialYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>[]
          }
          delete: {
            args: Prisma.FinancialYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>
          }
          update: {
            args: Prisma.FinancialYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>
          }
          deleteMany: {
            args: Prisma.FinancialYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>[]
          }
          upsert: {
            args: Prisma.FinancialYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialYearPayload>
          }
          aggregate: {
            args: Prisma.FinancialYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialYear>
          }
          groupBy: {
            args: Prisma.FinancialYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialYearCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialYearCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeasonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      PoPrdCat: {
        payload: Prisma.$PoPrdCatPayload<ExtArgs>
        fields: Prisma.PoPrdCatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PoPrdCatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PoPrdCatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>
          }
          findFirst: {
            args: Prisma.PoPrdCatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PoPrdCatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>
          }
          findMany: {
            args: Prisma.PoPrdCatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>[]
          }
          create: {
            args: Prisma.PoPrdCatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>
          }
          createMany: {
            args: Prisma.PoPrdCatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PoPrdCatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>[]
          }
          delete: {
            args: Prisma.PoPrdCatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>
          }
          update: {
            args: Prisma.PoPrdCatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>
          }
          deleteMany: {
            args: Prisma.PoPrdCatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PoPrdCatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PoPrdCatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>[]
          }
          upsert: {
            args: Prisma.PoPrdCatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoPrdCatPayload>
          }
          aggregate: {
            args: Prisma.PoPrdCatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoPrdCat>
          }
          groupBy: {
            args: Prisma.PoPrdCatGroupByArgs<ExtArgs>
            result: $Utils.Optional<PoPrdCatGroupByOutputType>[]
          }
          count: {
            args: Prisma.PoPrdCatCountArgs<ExtArgs>
            result: $Utils.Optional<PoPrdCatCountAggregateOutputType> | number
          }
        }
      }
      DeliveryMode: {
        payload: Prisma.$DeliveryModePayload<ExtArgs>
        fields: Prisma.DeliveryModeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryModeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryModeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>
          }
          findFirst: {
            args: Prisma.DeliveryModeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryModeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>
          }
          findMany: {
            args: Prisma.DeliveryModeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>[]
          }
          create: {
            args: Prisma.DeliveryModeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>
          }
          createMany: {
            args: Prisma.DeliveryModeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryModeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>[]
          }
          delete: {
            args: Prisma.DeliveryModeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>
          }
          update: {
            args: Prisma.DeliveryModeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryModeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryModeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryModeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>[]
          }
          upsert: {
            args: Prisma.DeliveryModeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryModePayload>
          }
          aggregate: {
            args: Prisma.DeliveryModeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryMode>
          }
          groupBy: {
            args: Prisma.DeliveryModeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryModeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryModeCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryModeCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      TransactionsMaster: {
        payload: Prisma.$TransactionsMasterPayload<ExtArgs>
        fields: Prisma.TransactionsMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionsMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionsMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>
          }
          findFirst: {
            args: Prisma.TransactionsMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionsMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>
          }
          findMany: {
            args: Prisma.TransactionsMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>[]
          }
          create: {
            args: Prisma.TransactionsMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>
          }
          createMany: {
            args: Prisma.TransactionsMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionsMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>[]
          }
          delete: {
            args: Prisma.TransactionsMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>
          }
          update: {
            args: Prisma.TransactionsMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>
          }
          deleteMany: {
            args: Prisma.TransactionsMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionsMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionsMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>[]
          }
          upsert: {
            args: Prisma.TransactionsMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsMasterPayload>
          }
          aggregate: {
            args: Prisma.TransactionsMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionsMaster>
          }
          groupBy: {
            args: Prisma.TransactionsMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionsMasterCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsMasterCountAggregateOutputType> | number
          }
        }
      }
      Transactions: {
        payload: Prisma.$TransactionsPayload<ExtArgs>
        fields: Prisma.TransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findFirst: {
            args: Prisma.TransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findMany: {
            args: Prisma.TransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          create: {
            args: Prisma.TransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          createMany: {
            args: Prisma.TransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          delete: {
            args: Prisma.TransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          update: {
            args: Prisma.TransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          deleteMany: {
            args: Prisma.TransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          upsert: {
            args: Prisma.TransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.TransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      DeliveryTerm: {
        payload: Prisma.$DeliveryTermPayload<ExtArgs>
        fields: Prisma.DeliveryTermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryTermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryTermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>
          }
          findFirst: {
            args: Prisma.DeliveryTermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryTermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>
          }
          findMany: {
            args: Prisma.DeliveryTermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>[]
          }
          create: {
            args: Prisma.DeliveryTermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>
          }
          createMany: {
            args: Prisma.DeliveryTermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryTermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>[]
          }
          delete: {
            args: Prisma.DeliveryTermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>
          }
          update: {
            args: Prisma.DeliveryTermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryTermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryTermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryTermUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryTermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTermPayload>
          }
          aggregate: {
            args: Prisma.DeliveryTermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryTerm>
          }
          groupBy: {
            args: Prisma.DeliveryTermGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTermGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryTermCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTermCountAggregateOutputType> | number
          }
        }
      }
      CommissionTerm: {
        payload: Prisma.$CommissionTermPayload<ExtArgs>
        fields: Prisma.CommissionTermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionTermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionTermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>
          }
          findFirst: {
            args: Prisma.CommissionTermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionTermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>
          }
          findMany: {
            args: Prisma.CommissionTermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>[]
          }
          create: {
            args: Prisma.CommissionTermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>
          }
          createMany: {
            args: Prisma.CommissionTermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionTermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>[]
          }
          delete: {
            args: Prisma.CommissionTermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>
          }
          update: {
            args: Prisma.CommissionTermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>
          }
          deleteMany: {
            args: Prisma.CommissionTermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionTermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommissionTermUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>[]
          }
          upsert: {
            args: Prisma.CommissionTermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionTermPayload>
          }
          aggregate: {
            args: Prisma.CommissionTermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommissionTerm>
          }
          groupBy: {
            args: Prisma.CommissionTermGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionTermGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionTermCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionTermCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Employer: {
        payload: Prisma.$EmployerPayload<ExtArgs>
        fields: Prisma.EmployerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>
          }
          findFirst: {
            args: Prisma.EmployerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>
          }
          findMany: {
            args: Prisma.EmployerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>[]
          }
          create: {
            args: Prisma.EmployerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>
          }
          createMany: {
            args: Prisma.EmployerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>[]
          }
          delete: {
            args: Prisma.EmployerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>
          }
          update: {
            args: Prisma.EmployerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>
          }
          deleteMany: {
            args: Prisma.EmployerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>[]
          }
          upsert: {
            args: Prisma.EmployerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerPayload>
          }
          aggregate: {
            args: Prisma.EmployerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployer>
          }
          groupBy: {
            args: Prisma.EmployerGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployerGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployerCountArgs<ExtArgs>
            result: $Utils.Optional<EmployerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    mBSCD?: MBSCDOmit
    bSCD?: BSCDOmit
    mACNO?: MACNOOmit
    aCNO?: ACNOOmit
    company?: CompanyOmit
    costCenter?: CostCenterOmit
    department?: DepartmentOmit
    productMasterCategory?: ProductMasterCategoryOmit
    productGroup?: ProductGroupOmit
    productCategory?: ProductCategoryOmit
    mainCategory?: MainCategoryOmit
    itemCategory?: ItemCategoryOmit
    item?: ItemOmit
    designation?: DesignationOmit
    godown?: GodownOmit
    financialYear?: FinancialYearOmit
    season?: SeasonOmit
    poPrdCat?: PoPrdCatOmit
    deliveryMode?: DeliveryModeOmit
    users?: UsersOmit
    currency?: CurrencyOmit
    transactionsMaster?: TransactionsMasterOmit
    transactions?: TransactionsOmit
    deliveryTerm?: DeliveryTermOmit
    commissionTerm?: CommissionTermOmit
    employee?: EmployeeOmit
    leave?: LeaveOmit
    document?: DocumentOmit
    manager?: ManagerOmit
    employer?: EmployerOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MBSCDCountOutputType
   */

  export type MBSCDCountOutputType = {
    bscdItems: number
  }

  export type MBSCDCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bscdItems?: boolean | MBSCDCountOutputTypeCountBscdItemsArgs
  }

  // Custom InputTypes
  /**
   * MBSCDCountOutputType without action
   */
  export type MBSCDCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCDCountOutputType
     */
    select?: MBSCDCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MBSCDCountOutputType without action
   */
  export type MBSCDCountOutputTypeCountBscdItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BSCDWhereInput
  }


  /**
   * Count Type BSCDCountOutputType
   */

  export type BSCDCountOutputType = {
    macnoItems: number
  }

  export type BSCDCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    macnoItems?: boolean | BSCDCountOutputTypeCountMacnoItemsArgs
  }

  // Custom InputTypes
  /**
   * BSCDCountOutputType without action
   */
  export type BSCDCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCDCountOutputType
     */
    select?: BSCDCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BSCDCountOutputType without action
   */
  export type BSCDCountOutputTypeCountMacnoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MACNOWhereInput
  }


  /**
   * Count Type MACNOCountOutputType
   */

  export type MACNOCountOutputType = {
    accounts: number
  }

  export type MACNOCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | MACNOCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes
  /**
   * MACNOCountOutputType without action
   */
  export type MACNOCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNOCountOutputType
     */
    select?: MACNOCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MACNOCountOutputType without action
   */
  export type MACNOCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ACNOWhereInput
  }


  /**
   * Count Type ACNOCountOutputType
   */

  export type ACNOCountOutputType = {
    transactionsMaster: number
    transactions: number
  }

  export type ACNOCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionsMaster?: boolean | ACNOCountOutputTypeCountTransactionsMasterArgs
    transactions?: boolean | ACNOCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ACNOCountOutputType without action
   */
  export type ACNOCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNOCountOutputType
     */
    select?: ACNOCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ACNOCountOutputType without action
   */
  export type ACNOCountOutputTypeCountTransactionsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsMasterWhereInput
  }

  /**
   * ACNOCountOutputType without action
   */
  export type ACNOCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    costCenters: number
    departments: number
    designations: number
    godowns: number
    TransactionsMaster: number
    users: number
    financialYears: number
    seasons: number
    poPrdCats: number
    deliveryModes: number
    deliveryTerms: number
    commissionTerms: number
    employees: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costCenters?: boolean | CompanyCountOutputTypeCountCostCentersArgs
    departments?: boolean | CompanyCountOutputTypeCountDepartmentsArgs
    designations?: boolean | CompanyCountOutputTypeCountDesignationsArgs
    godowns?: boolean | CompanyCountOutputTypeCountGodownsArgs
    TransactionsMaster?: boolean | CompanyCountOutputTypeCountTransactionsMasterArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    financialYears?: boolean | CompanyCountOutputTypeCountFinancialYearsArgs
    seasons?: boolean | CompanyCountOutputTypeCountSeasonsArgs
    poPrdCats?: boolean | CompanyCountOutputTypeCountPoPrdCatsArgs
    deliveryModes?: boolean | CompanyCountOutputTypeCountDeliveryModesArgs
    deliveryTerms?: boolean | CompanyCountOutputTypeCountDeliveryTermsArgs
    commissionTerms?: boolean | CompanyCountOutputTypeCountCommissionTermsArgs
    employees?: boolean | CompanyCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCostCentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostCenterWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDesignationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignationWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountGodownsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GodownWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTransactionsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsMasterWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFinancialYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialYearWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPoPrdCatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoPrdCatWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDeliveryModesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryModeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDeliveryTermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTermWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCommissionTermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionTermWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type CostCenterCountOutputType
   */

  export type CostCenterCountOutputType = {
    Transaction: number
  }

  export type CostCenterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | CostCenterCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * CostCenterCountOutputType without action
   */
  export type CostCenterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenterCountOutputType
     */
    select?: CostCenterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostCenterCountOutputType without action
   */
  export type CostCenterCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type ProductMasterCategoryCountOutputType
   */

  export type ProductMasterCategoryCountOutputType = {
    productGroups: number
  }

  export type ProductMasterCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productGroups?: boolean | ProductMasterCategoryCountOutputTypeCountProductGroupsArgs
  }

  // Custom InputTypes
  /**
   * ProductMasterCategoryCountOutputType without action
   */
  export type ProductMasterCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategoryCountOutputType
     */
    select?: ProductMasterCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductMasterCategoryCountOutputType without action
   */
  export type ProductMasterCategoryCountOutputTypeCountProductGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductGroupWhereInput
  }


  /**
   * Count Type ProductGroupCountOutputType
   */

  export type ProductGroupCountOutputType = {
    productCategories: number
  }

  export type ProductGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productCategories?: boolean | ProductGroupCountOutputTypeCountProductCategoriesArgs
  }

  // Custom InputTypes
  /**
   * ProductGroupCountOutputType without action
   */
  export type ProductGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroupCountOutputType
     */
    select?: ProductGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductGroupCountOutputType without action
   */
  export type ProductGroupCountOutputTypeCountProductCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    mainCategories: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainCategories?: boolean | ProductCategoryCountOutputTypeCountMainCategoriesArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountMainCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainCategoryWhereInput
  }


  /**
   * Count Type MainCategoryCountOutputType
   */

  export type MainCategoryCountOutputType = {
    itemCategories: number
  }

  export type MainCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemCategories?: boolean | MainCategoryCountOutputTypeCountItemCategoriesArgs
  }

  // Custom InputTypes
  /**
   * MainCategoryCountOutputType without action
   */
  export type MainCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategoryCountOutputType
     */
    select?: MainCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MainCategoryCountOutputType without action
   */
  export type MainCategoryCountOutputTypeCountItemCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
  }


  /**
   * Count Type ItemCategoryCountOutputType
   */

  export type ItemCategoryCountOutputType = {
    items: number
  }

  export type ItemCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemCategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCountOutputType
     */
    select?: ItemCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    Transactions: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transactions?: boolean | ItemCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type GodownCountOutputType
   */

  export type GodownCountOutputType = {
    TransactionsMaster: number
    Transaction: number
  }

  export type GodownCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TransactionsMaster?: boolean | GodownCountOutputTypeCountTransactionsMasterArgs
    Transaction?: boolean | GodownCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * GodownCountOutputType without action
   */
  export type GodownCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GodownCountOutputType
     */
    select?: GodownCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GodownCountOutputType without action
   */
  export type GodownCountOutputTypeCountTransactionsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsMasterWhereInput
  }

  /**
   * GodownCountOutputType without action
   */
  export type GodownCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    transactionsMaster: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionsMaster?: boolean | UsersCountOutputTypeCountTransactionsMasterArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTransactionsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsMasterWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    transactions: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CurrencyCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type TransactionsMasterCountOutputType
   */

  export type TransactionsMasterCountOutputType = {
    transactions: number
  }

  export type TransactionsMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | TransactionsMasterCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * TransactionsMasterCountOutputType without action
   */
  export type TransactionsMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMasterCountOutputType
     */
    select?: TransactionsMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionsMasterCountOutputType without action
   */
  export type TransactionsMasterCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    leaves: number
    documents: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaves?: boolean | EmployeeCountOutputTypeCountLeavesArgs
    documents?: boolean | EmployeeCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type ManagerCountOutputType
   */

  export type ManagerCountOutputType = {
    employees: number
  }

  export type ManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | ManagerCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCountOutputType
     */
    select?: ManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type EmployerCountOutputType
   */

  export type EmployerCountOutputType = {
    employees: number
  }

  export type EmployerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployerCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * EmployerCountOutputType without action
   */
  export type EmployerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerCountOutputType
     */
    select?: EmployerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployerCountOutputType without action
   */
  export type EmployerCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model MBSCD
   */

  export type AggregateMBSCD = {
    _count: MBSCDCountAggregateOutputType | null
    _min: MBSCDMinAggregateOutputType | null
    _max: MBSCDMaxAggregateOutputType | null
  }

  export type MBSCDMinAggregateOutputType = {
    bscd: string | null
    bscdDetail: string | null
  }

  export type MBSCDMaxAggregateOutputType = {
    bscd: string | null
    bscdDetail: string | null
  }

  export type MBSCDCountAggregateOutputType = {
    bscd: number
    bscdDetail: number
    _all: number
  }


  export type MBSCDMinAggregateInputType = {
    bscd?: true
    bscdDetail?: true
  }

  export type MBSCDMaxAggregateInputType = {
    bscd?: true
    bscdDetail?: true
  }

  export type MBSCDCountAggregateInputType = {
    bscd?: true
    bscdDetail?: true
    _all?: true
  }

  export type MBSCDAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MBSCD to aggregate.
     */
    where?: MBSCDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MBSCDS to fetch.
     */
    orderBy?: MBSCDOrderByWithRelationInput | MBSCDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MBSCDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MBSCDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MBSCDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MBSCDS
    **/
    _count?: true | MBSCDCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MBSCDMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MBSCDMaxAggregateInputType
  }

  export type GetMBSCDAggregateType<T extends MBSCDAggregateArgs> = {
        [P in keyof T & keyof AggregateMBSCD]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMBSCD[P]>
      : GetScalarType<T[P], AggregateMBSCD[P]>
  }




  export type MBSCDGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MBSCDWhereInput
    orderBy?: MBSCDOrderByWithAggregationInput | MBSCDOrderByWithAggregationInput[]
    by: MBSCDScalarFieldEnum[] | MBSCDScalarFieldEnum
    having?: MBSCDScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MBSCDCountAggregateInputType | true
    _min?: MBSCDMinAggregateInputType
    _max?: MBSCDMaxAggregateInputType
  }

  export type MBSCDGroupByOutputType = {
    bscd: string
    bscdDetail: string
    _count: MBSCDCountAggregateOutputType | null
    _min: MBSCDMinAggregateOutputType | null
    _max: MBSCDMaxAggregateOutputType | null
  }

  type GetMBSCDGroupByPayload<T extends MBSCDGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MBSCDGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MBSCDGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MBSCDGroupByOutputType[P]>
            : GetScalarType<T[P], MBSCDGroupByOutputType[P]>
        }
      >
    >


  export type MBSCDSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bscd?: boolean
    bscdDetail?: boolean
    bscdItems?: boolean | MBSCD$bscdItemsArgs<ExtArgs>
    _count?: boolean | MBSCDCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mBSCD"]>

  export type MBSCDSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bscd?: boolean
    bscdDetail?: boolean
  }, ExtArgs["result"]["mBSCD"]>

  export type MBSCDSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bscd?: boolean
    bscdDetail?: boolean
  }, ExtArgs["result"]["mBSCD"]>

  export type MBSCDSelectScalar = {
    bscd?: boolean
    bscdDetail?: boolean
  }

  export type MBSCDOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"bscd" | "bscdDetail", ExtArgs["result"]["mBSCD"]>
  export type MBSCDInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bscdItems?: boolean | MBSCD$bscdItemsArgs<ExtArgs>
    _count?: boolean | MBSCDCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MBSCDIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MBSCDIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MBSCDPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MBSCD"
    objects: {
      bscdItems: Prisma.$BSCDPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      bscd: string
      bscdDetail: string
    }, ExtArgs["result"]["mBSCD"]>
    composites: {}
  }

  type MBSCDGetPayload<S extends boolean | null | undefined | MBSCDDefaultArgs> = $Result.GetResult<Prisma.$MBSCDPayload, S>

  type MBSCDCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MBSCDFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MBSCDCountAggregateInputType | true
    }

  export interface MBSCDDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MBSCD'], meta: { name: 'MBSCD' } }
    /**
     * Find zero or one MBSCD that matches the filter.
     * @param {MBSCDFindUniqueArgs} args - Arguments to find a MBSCD
     * @example
     * // Get one MBSCD
     * const mBSCD = await prisma.mBSCD.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MBSCDFindUniqueArgs>(args: SelectSubset<T, MBSCDFindUniqueArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MBSCD that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MBSCDFindUniqueOrThrowArgs} args - Arguments to find a MBSCD
     * @example
     * // Get one MBSCD
     * const mBSCD = await prisma.mBSCD.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MBSCDFindUniqueOrThrowArgs>(args: SelectSubset<T, MBSCDFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MBSCD that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MBSCDFindFirstArgs} args - Arguments to find a MBSCD
     * @example
     * // Get one MBSCD
     * const mBSCD = await prisma.mBSCD.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MBSCDFindFirstArgs>(args?: SelectSubset<T, MBSCDFindFirstArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MBSCD that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MBSCDFindFirstOrThrowArgs} args - Arguments to find a MBSCD
     * @example
     * // Get one MBSCD
     * const mBSCD = await prisma.mBSCD.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MBSCDFindFirstOrThrowArgs>(args?: SelectSubset<T, MBSCDFindFirstOrThrowArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MBSCDS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MBSCDFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MBSCDS
     * const mBSCDS = await prisma.mBSCD.findMany()
     * 
     * // Get first 10 MBSCDS
     * const mBSCDS = await prisma.mBSCD.findMany({ take: 10 })
     * 
     * // Only select the `bscd`
     * const mBSCDWithBscdOnly = await prisma.mBSCD.findMany({ select: { bscd: true } })
     * 
     */
    findMany<T extends MBSCDFindManyArgs>(args?: SelectSubset<T, MBSCDFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MBSCD.
     * @param {MBSCDCreateArgs} args - Arguments to create a MBSCD.
     * @example
     * // Create one MBSCD
     * const MBSCD = await prisma.mBSCD.create({
     *   data: {
     *     // ... data to create a MBSCD
     *   }
     * })
     * 
     */
    create<T extends MBSCDCreateArgs>(args: SelectSubset<T, MBSCDCreateArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MBSCDS.
     * @param {MBSCDCreateManyArgs} args - Arguments to create many MBSCDS.
     * @example
     * // Create many MBSCDS
     * const mBSCD = await prisma.mBSCD.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MBSCDCreateManyArgs>(args?: SelectSubset<T, MBSCDCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MBSCDS and returns the data saved in the database.
     * @param {MBSCDCreateManyAndReturnArgs} args - Arguments to create many MBSCDS.
     * @example
     * // Create many MBSCDS
     * const mBSCD = await prisma.mBSCD.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MBSCDS and only return the `bscd`
     * const mBSCDWithBscdOnly = await prisma.mBSCD.createManyAndReturn({
     *   select: { bscd: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MBSCDCreateManyAndReturnArgs>(args?: SelectSubset<T, MBSCDCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MBSCD.
     * @param {MBSCDDeleteArgs} args - Arguments to delete one MBSCD.
     * @example
     * // Delete one MBSCD
     * const MBSCD = await prisma.mBSCD.delete({
     *   where: {
     *     // ... filter to delete one MBSCD
     *   }
     * })
     * 
     */
    delete<T extends MBSCDDeleteArgs>(args: SelectSubset<T, MBSCDDeleteArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MBSCD.
     * @param {MBSCDUpdateArgs} args - Arguments to update one MBSCD.
     * @example
     * // Update one MBSCD
     * const mBSCD = await prisma.mBSCD.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MBSCDUpdateArgs>(args: SelectSubset<T, MBSCDUpdateArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MBSCDS.
     * @param {MBSCDDeleteManyArgs} args - Arguments to filter MBSCDS to delete.
     * @example
     * // Delete a few MBSCDS
     * const { count } = await prisma.mBSCD.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MBSCDDeleteManyArgs>(args?: SelectSubset<T, MBSCDDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MBSCDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MBSCDUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MBSCDS
     * const mBSCD = await prisma.mBSCD.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MBSCDUpdateManyArgs>(args: SelectSubset<T, MBSCDUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MBSCDS and returns the data updated in the database.
     * @param {MBSCDUpdateManyAndReturnArgs} args - Arguments to update many MBSCDS.
     * @example
     * // Update many MBSCDS
     * const mBSCD = await prisma.mBSCD.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MBSCDS and only return the `bscd`
     * const mBSCDWithBscdOnly = await prisma.mBSCD.updateManyAndReturn({
     *   select: { bscd: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MBSCDUpdateManyAndReturnArgs>(args: SelectSubset<T, MBSCDUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MBSCD.
     * @param {MBSCDUpsertArgs} args - Arguments to update or create a MBSCD.
     * @example
     * // Update or create a MBSCD
     * const mBSCD = await prisma.mBSCD.upsert({
     *   create: {
     *     // ... data to create a MBSCD
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MBSCD we want to update
     *   }
     * })
     */
    upsert<T extends MBSCDUpsertArgs>(args: SelectSubset<T, MBSCDUpsertArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MBSCDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MBSCDCountArgs} args - Arguments to filter MBSCDS to count.
     * @example
     * // Count the number of MBSCDS
     * const count = await prisma.mBSCD.count({
     *   where: {
     *     // ... the filter for the MBSCDS we want to count
     *   }
     * })
    **/
    count<T extends MBSCDCountArgs>(
      args?: Subset<T, MBSCDCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MBSCDCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MBSCD.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MBSCDAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MBSCDAggregateArgs>(args: Subset<T, MBSCDAggregateArgs>): Prisma.PrismaPromise<GetMBSCDAggregateType<T>>

    /**
     * Group by MBSCD.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MBSCDGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MBSCDGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MBSCDGroupByArgs['orderBy'] }
        : { orderBy?: MBSCDGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MBSCDGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMBSCDGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MBSCD model
   */
  readonly fields: MBSCDFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MBSCD.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MBSCDClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bscdItems<T extends MBSCD$bscdItemsArgs<ExtArgs> = {}>(args?: Subset<T, MBSCD$bscdItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MBSCD model
   */
  interface MBSCDFieldRefs {
    readonly bscd: FieldRef<"MBSCD", 'String'>
    readonly bscdDetail: FieldRef<"MBSCD", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MBSCD findUnique
   */
  export type MBSCDFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * Filter, which MBSCD to fetch.
     */
    where: MBSCDWhereUniqueInput
  }

  /**
   * MBSCD findUniqueOrThrow
   */
  export type MBSCDFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * Filter, which MBSCD to fetch.
     */
    where: MBSCDWhereUniqueInput
  }

  /**
   * MBSCD findFirst
   */
  export type MBSCDFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * Filter, which MBSCD to fetch.
     */
    where?: MBSCDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MBSCDS to fetch.
     */
    orderBy?: MBSCDOrderByWithRelationInput | MBSCDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MBSCDS.
     */
    cursor?: MBSCDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MBSCDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MBSCDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MBSCDS.
     */
    distinct?: MBSCDScalarFieldEnum | MBSCDScalarFieldEnum[]
  }

  /**
   * MBSCD findFirstOrThrow
   */
  export type MBSCDFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * Filter, which MBSCD to fetch.
     */
    where?: MBSCDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MBSCDS to fetch.
     */
    orderBy?: MBSCDOrderByWithRelationInput | MBSCDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MBSCDS.
     */
    cursor?: MBSCDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MBSCDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MBSCDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MBSCDS.
     */
    distinct?: MBSCDScalarFieldEnum | MBSCDScalarFieldEnum[]
  }

  /**
   * MBSCD findMany
   */
  export type MBSCDFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * Filter, which MBSCDS to fetch.
     */
    where?: MBSCDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MBSCDS to fetch.
     */
    orderBy?: MBSCDOrderByWithRelationInput | MBSCDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MBSCDS.
     */
    cursor?: MBSCDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MBSCDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MBSCDS.
     */
    skip?: number
    distinct?: MBSCDScalarFieldEnum | MBSCDScalarFieldEnum[]
  }

  /**
   * MBSCD create
   */
  export type MBSCDCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * The data needed to create a MBSCD.
     */
    data: XOR<MBSCDCreateInput, MBSCDUncheckedCreateInput>
  }

  /**
   * MBSCD createMany
   */
  export type MBSCDCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MBSCDS.
     */
    data: MBSCDCreateManyInput | MBSCDCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MBSCD createManyAndReturn
   */
  export type MBSCDCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * The data used to create many MBSCDS.
     */
    data: MBSCDCreateManyInput | MBSCDCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MBSCD update
   */
  export type MBSCDUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * The data needed to update a MBSCD.
     */
    data: XOR<MBSCDUpdateInput, MBSCDUncheckedUpdateInput>
    /**
     * Choose, which MBSCD to update.
     */
    where: MBSCDWhereUniqueInput
  }

  /**
   * MBSCD updateMany
   */
  export type MBSCDUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MBSCDS.
     */
    data: XOR<MBSCDUpdateManyMutationInput, MBSCDUncheckedUpdateManyInput>
    /**
     * Filter which MBSCDS to update
     */
    where?: MBSCDWhereInput
    /**
     * Limit how many MBSCDS to update.
     */
    limit?: number
  }

  /**
   * MBSCD updateManyAndReturn
   */
  export type MBSCDUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * The data used to update MBSCDS.
     */
    data: XOR<MBSCDUpdateManyMutationInput, MBSCDUncheckedUpdateManyInput>
    /**
     * Filter which MBSCDS to update
     */
    where?: MBSCDWhereInput
    /**
     * Limit how many MBSCDS to update.
     */
    limit?: number
  }

  /**
   * MBSCD upsert
   */
  export type MBSCDUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * The filter to search for the MBSCD to update in case it exists.
     */
    where: MBSCDWhereUniqueInput
    /**
     * In case the MBSCD found by the `where` argument doesn't exist, create a new MBSCD with this data.
     */
    create: XOR<MBSCDCreateInput, MBSCDUncheckedCreateInput>
    /**
     * In case the MBSCD was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MBSCDUpdateInput, MBSCDUncheckedUpdateInput>
  }

  /**
   * MBSCD delete
   */
  export type MBSCDDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
    /**
     * Filter which MBSCD to delete.
     */
    where: MBSCDWhereUniqueInput
  }

  /**
   * MBSCD deleteMany
   */
  export type MBSCDDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MBSCDS to delete
     */
    where?: MBSCDWhereInput
    /**
     * Limit how many MBSCDS to delete.
     */
    limit?: number
  }

  /**
   * MBSCD.bscdItems
   */
  export type MBSCD$bscdItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    where?: BSCDWhereInput
    orderBy?: BSCDOrderByWithRelationInput | BSCDOrderByWithRelationInput[]
    cursor?: BSCDWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BSCDScalarFieldEnum | BSCDScalarFieldEnum[]
  }

  /**
   * MBSCD without action
   */
  export type MBSCDDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MBSCD
     */
    select?: MBSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MBSCD
     */
    omit?: MBSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MBSCDInclude<ExtArgs> | null
  }


  /**
   * Model BSCD
   */

  export type AggregateBSCD = {
    _count: BSCDCountAggregateOutputType | null
    _min: BSCDMinAggregateOutputType | null
    _max: BSCDMaxAggregateOutputType | null
  }

  export type BSCDMinAggregateOutputType = {
    bscd: string | null
    mbscd: string | null
    bscdDetail: string | null
  }

  export type BSCDMaxAggregateOutputType = {
    bscd: string | null
    mbscd: string | null
    bscdDetail: string | null
  }

  export type BSCDCountAggregateOutputType = {
    bscd: number
    mbscd: number
    bscdDetail: number
    _all: number
  }


  export type BSCDMinAggregateInputType = {
    bscd?: true
    mbscd?: true
    bscdDetail?: true
  }

  export type BSCDMaxAggregateInputType = {
    bscd?: true
    mbscd?: true
    bscdDetail?: true
  }

  export type BSCDCountAggregateInputType = {
    bscd?: true
    mbscd?: true
    bscdDetail?: true
    _all?: true
  }

  export type BSCDAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BSCD to aggregate.
     */
    where?: BSCDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BSCDS to fetch.
     */
    orderBy?: BSCDOrderByWithRelationInput | BSCDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BSCDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BSCDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BSCDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BSCDS
    **/
    _count?: true | BSCDCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BSCDMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BSCDMaxAggregateInputType
  }

  export type GetBSCDAggregateType<T extends BSCDAggregateArgs> = {
        [P in keyof T & keyof AggregateBSCD]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBSCD[P]>
      : GetScalarType<T[P], AggregateBSCD[P]>
  }




  export type BSCDGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BSCDWhereInput
    orderBy?: BSCDOrderByWithAggregationInput | BSCDOrderByWithAggregationInput[]
    by: BSCDScalarFieldEnum[] | BSCDScalarFieldEnum
    having?: BSCDScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BSCDCountAggregateInputType | true
    _min?: BSCDMinAggregateInputType
    _max?: BSCDMaxAggregateInputType
  }

  export type BSCDGroupByOutputType = {
    bscd: string
    mbscd: string
    bscdDetail: string
    _count: BSCDCountAggregateOutputType | null
    _min: BSCDMinAggregateOutputType | null
    _max: BSCDMaxAggregateOutputType | null
  }

  type GetBSCDGroupByPayload<T extends BSCDGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BSCDGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BSCDGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BSCDGroupByOutputType[P]>
            : GetScalarType<T[P], BSCDGroupByOutputType[P]>
        }
      >
    >


  export type BSCDSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bscd?: boolean
    mbscd?: boolean
    bscdDetail?: boolean
    mainBscd?: boolean | MBSCDDefaultArgs<ExtArgs>
    macnoItems?: boolean | BSCD$macnoItemsArgs<ExtArgs>
    _count?: boolean | BSCDCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bSCD"]>

  export type BSCDSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bscd?: boolean
    mbscd?: boolean
    bscdDetail?: boolean
    mainBscd?: boolean | MBSCDDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bSCD"]>

  export type BSCDSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bscd?: boolean
    mbscd?: boolean
    bscdDetail?: boolean
    mainBscd?: boolean | MBSCDDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bSCD"]>

  export type BSCDSelectScalar = {
    bscd?: boolean
    mbscd?: boolean
    bscdDetail?: boolean
  }

  export type BSCDOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"bscd" | "mbscd" | "bscdDetail", ExtArgs["result"]["bSCD"]>
  export type BSCDInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainBscd?: boolean | MBSCDDefaultArgs<ExtArgs>
    macnoItems?: boolean | BSCD$macnoItemsArgs<ExtArgs>
    _count?: boolean | BSCDCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BSCDIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainBscd?: boolean | MBSCDDefaultArgs<ExtArgs>
  }
  export type BSCDIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainBscd?: boolean | MBSCDDefaultArgs<ExtArgs>
  }

  export type $BSCDPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BSCD"
    objects: {
      mainBscd: Prisma.$MBSCDPayload<ExtArgs>
      macnoItems: Prisma.$MACNOPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      bscd: string
      mbscd: string
      bscdDetail: string
    }, ExtArgs["result"]["bSCD"]>
    composites: {}
  }

  type BSCDGetPayload<S extends boolean | null | undefined | BSCDDefaultArgs> = $Result.GetResult<Prisma.$BSCDPayload, S>

  type BSCDCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BSCDFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BSCDCountAggregateInputType | true
    }

  export interface BSCDDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BSCD'], meta: { name: 'BSCD' } }
    /**
     * Find zero or one BSCD that matches the filter.
     * @param {BSCDFindUniqueArgs} args - Arguments to find a BSCD
     * @example
     * // Get one BSCD
     * const bSCD = await prisma.bSCD.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BSCDFindUniqueArgs>(args: SelectSubset<T, BSCDFindUniqueArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BSCD that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BSCDFindUniqueOrThrowArgs} args - Arguments to find a BSCD
     * @example
     * // Get one BSCD
     * const bSCD = await prisma.bSCD.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BSCDFindUniqueOrThrowArgs>(args: SelectSubset<T, BSCDFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BSCD that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BSCDFindFirstArgs} args - Arguments to find a BSCD
     * @example
     * // Get one BSCD
     * const bSCD = await prisma.bSCD.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BSCDFindFirstArgs>(args?: SelectSubset<T, BSCDFindFirstArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BSCD that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BSCDFindFirstOrThrowArgs} args - Arguments to find a BSCD
     * @example
     * // Get one BSCD
     * const bSCD = await prisma.bSCD.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BSCDFindFirstOrThrowArgs>(args?: SelectSubset<T, BSCDFindFirstOrThrowArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BSCDS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BSCDFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BSCDS
     * const bSCDS = await prisma.bSCD.findMany()
     * 
     * // Get first 10 BSCDS
     * const bSCDS = await prisma.bSCD.findMany({ take: 10 })
     * 
     * // Only select the `bscd`
     * const bSCDWithBscdOnly = await prisma.bSCD.findMany({ select: { bscd: true } })
     * 
     */
    findMany<T extends BSCDFindManyArgs>(args?: SelectSubset<T, BSCDFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BSCD.
     * @param {BSCDCreateArgs} args - Arguments to create a BSCD.
     * @example
     * // Create one BSCD
     * const BSCD = await prisma.bSCD.create({
     *   data: {
     *     // ... data to create a BSCD
     *   }
     * })
     * 
     */
    create<T extends BSCDCreateArgs>(args: SelectSubset<T, BSCDCreateArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BSCDS.
     * @param {BSCDCreateManyArgs} args - Arguments to create many BSCDS.
     * @example
     * // Create many BSCDS
     * const bSCD = await prisma.bSCD.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BSCDCreateManyArgs>(args?: SelectSubset<T, BSCDCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BSCDS and returns the data saved in the database.
     * @param {BSCDCreateManyAndReturnArgs} args - Arguments to create many BSCDS.
     * @example
     * // Create many BSCDS
     * const bSCD = await prisma.bSCD.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BSCDS and only return the `bscd`
     * const bSCDWithBscdOnly = await prisma.bSCD.createManyAndReturn({
     *   select: { bscd: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BSCDCreateManyAndReturnArgs>(args?: SelectSubset<T, BSCDCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BSCD.
     * @param {BSCDDeleteArgs} args - Arguments to delete one BSCD.
     * @example
     * // Delete one BSCD
     * const BSCD = await prisma.bSCD.delete({
     *   where: {
     *     // ... filter to delete one BSCD
     *   }
     * })
     * 
     */
    delete<T extends BSCDDeleteArgs>(args: SelectSubset<T, BSCDDeleteArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BSCD.
     * @param {BSCDUpdateArgs} args - Arguments to update one BSCD.
     * @example
     * // Update one BSCD
     * const bSCD = await prisma.bSCD.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BSCDUpdateArgs>(args: SelectSubset<T, BSCDUpdateArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BSCDS.
     * @param {BSCDDeleteManyArgs} args - Arguments to filter BSCDS to delete.
     * @example
     * // Delete a few BSCDS
     * const { count } = await prisma.bSCD.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BSCDDeleteManyArgs>(args?: SelectSubset<T, BSCDDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BSCDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BSCDUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BSCDS
     * const bSCD = await prisma.bSCD.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BSCDUpdateManyArgs>(args: SelectSubset<T, BSCDUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BSCDS and returns the data updated in the database.
     * @param {BSCDUpdateManyAndReturnArgs} args - Arguments to update many BSCDS.
     * @example
     * // Update many BSCDS
     * const bSCD = await prisma.bSCD.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BSCDS and only return the `bscd`
     * const bSCDWithBscdOnly = await prisma.bSCD.updateManyAndReturn({
     *   select: { bscd: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BSCDUpdateManyAndReturnArgs>(args: SelectSubset<T, BSCDUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BSCD.
     * @param {BSCDUpsertArgs} args - Arguments to update or create a BSCD.
     * @example
     * // Update or create a BSCD
     * const bSCD = await prisma.bSCD.upsert({
     *   create: {
     *     // ... data to create a BSCD
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BSCD we want to update
     *   }
     * })
     */
    upsert<T extends BSCDUpsertArgs>(args: SelectSubset<T, BSCDUpsertArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BSCDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BSCDCountArgs} args - Arguments to filter BSCDS to count.
     * @example
     * // Count the number of BSCDS
     * const count = await prisma.bSCD.count({
     *   where: {
     *     // ... the filter for the BSCDS we want to count
     *   }
     * })
    **/
    count<T extends BSCDCountArgs>(
      args?: Subset<T, BSCDCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BSCDCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BSCD.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BSCDAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BSCDAggregateArgs>(args: Subset<T, BSCDAggregateArgs>): Prisma.PrismaPromise<GetBSCDAggregateType<T>>

    /**
     * Group by BSCD.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BSCDGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BSCDGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BSCDGroupByArgs['orderBy'] }
        : { orderBy?: BSCDGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BSCDGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBSCDGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BSCD model
   */
  readonly fields: BSCDFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BSCD.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BSCDClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainBscd<T extends MBSCDDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MBSCDDefaultArgs<ExtArgs>>): Prisma__MBSCDClient<$Result.GetResult<Prisma.$MBSCDPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    macnoItems<T extends BSCD$macnoItemsArgs<ExtArgs> = {}>(args?: Subset<T, BSCD$macnoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BSCD model
   */
  interface BSCDFieldRefs {
    readonly bscd: FieldRef<"BSCD", 'String'>
    readonly mbscd: FieldRef<"BSCD", 'String'>
    readonly bscdDetail: FieldRef<"BSCD", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BSCD findUnique
   */
  export type BSCDFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * Filter, which BSCD to fetch.
     */
    where: BSCDWhereUniqueInput
  }

  /**
   * BSCD findUniqueOrThrow
   */
  export type BSCDFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * Filter, which BSCD to fetch.
     */
    where: BSCDWhereUniqueInput
  }

  /**
   * BSCD findFirst
   */
  export type BSCDFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * Filter, which BSCD to fetch.
     */
    where?: BSCDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BSCDS to fetch.
     */
    orderBy?: BSCDOrderByWithRelationInput | BSCDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BSCDS.
     */
    cursor?: BSCDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BSCDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BSCDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BSCDS.
     */
    distinct?: BSCDScalarFieldEnum | BSCDScalarFieldEnum[]
  }

  /**
   * BSCD findFirstOrThrow
   */
  export type BSCDFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * Filter, which BSCD to fetch.
     */
    where?: BSCDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BSCDS to fetch.
     */
    orderBy?: BSCDOrderByWithRelationInput | BSCDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BSCDS.
     */
    cursor?: BSCDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BSCDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BSCDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BSCDS.
     */
    distinct?: BSCDScalarFieldEnum | BSCDScalarFieldEnum[]
  }

  /**
   * BSCD findMany
   */
  export type BSCDFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * Filter, which BSCDS to fetch.
     */
    where?: BSCDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BSCDS to fetch.
     */
    orderBy?: BSCDOrderByWithRelationInput | BSCDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BSCDS.
     */
    cursor?: BSCDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BSCDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BSCDS.
     */
    skip?: number
    distinct?: BSCDScalarFieldEnum | BSCDScalarFieldEnum[]
  }

  /**
   * BSCD create
   */
  export type BSCDCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * The data needed to create a BSCD.
     */
    data: XOR<BSCDCreateInput, BSCDUncheckedCreateInput>
  }

  /**
   * BSCD createMany
   */
  export type BSCDCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BSCDS.
     */
    data: BSCDCreateManyInput | BSCDCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BSCD createManyAndReturn
   */
  export type BSCDCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * The data used to create many BSCDS.
     */
    data: BSCDCreateManyInput | BSCDCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BSCD update
   */
  export type BSCDUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * The data needed to update a BSCD.
     */
    data: XOR<BSCDUpdateInput, BSCDUncheckedUpdateInput>
    /**
     * Choose, which BSCD to update.
     */
    where: BSCDWhereUniqueInput
  }

  /**
   * BSCD updateMany
   */
  export type BSCDUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BSCDS.
     */
    data: XOR<BSCDUpdateManyMutationInput, BSCDUncheckedUpdateManyInput>
    /**
     * Filter which BSCDS to update
     */
    where?: BSCDWhereInput
    /**
     * Limit how many BSCDS to update.
     */
    limit?: number
  }

  /**
   * BSCD updateManyAndReturn
   */
  export type BSCDUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * The data used to update BSCDS.
     */
    data: XOR<BSCDUpdateManyMutationInput, BSCDUncheckedUpdateManyInput>
    /**
     * Filter which BSCDS to update
     */
    where?: BSCDWhereInput
    /**
     * Limit how many BSCDS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BSCD upsert
   */
  export type BSCDUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * The filter to search for the BSCD to update in case it exists.
     */
    where: BSCDWhereUniqueInput
    /**
     * In case the BSCD found by the `where` argument doesn't exist, create a new BSCD with this data.
     */
    create: XOR<BSCDCreateInput, BSCDUncheckedCreateInput>
    /**
     * In case the BSCD was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BSCDUpdateInput, BSCDUncheckedUpdateInput>
  }

  /**
   * BSCD delete
   */
  export type BSCDDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
    /**
     * Filter which BSCD to delete.
     */
    where: BSCDWhereUniqueInput
  }

  /**
   * BSCD deleteMany
   */
  export type BSCDDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BSCDS to delete
     */
    where?: BSCDWhereInput
    /**
     * Limit how many BSCDS to delete.
     */
    limit?: number
  }

  /**
   * BSCD.macnoItems
   */
  export type BSCD$macnoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    where?: MACNOWhereInput
    orderBy?: MACNOOrderByWithRelationInput | MACNOOrderByWithRelationInput[]
    cursor?: MACNOWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MACNOScalarFieldEnum | MACNOScalarFieldEnum[]
  }

  /**
   * BSCD without action
   */
  export type BSCDDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BSCD
     */
    select?: BSCDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BSCD
     */
    omit?: BSCDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BSCDInclude<ExtArgs> | null
  }


  /**
   * Model MACNO
   */

  export type AggregateMACNO = {
    _count: MACNOCountAggregateOutputType | null
    _min: MACNOMinAggregateOutputType | null
    _max: MACNOMaxAggregateOutputType | null
  }

  export type MACNOMinAggregateOutputType = {
    macno: string | null
    bscd: string | null
    macname: string | null
  }

  export type MACNOMaxAggregateOutputType = {
    macno: string | null
    bscd: string | null
    macname: string | null
  }

  export type MACNOCountAggregateOutputType = {
    macno: number
    bscd: number
    macname: number
    _all: number
  }


  export type MACNOMinAggregateInputType = {
    macno?: true
    bscd?: true
    macname?: true
  }

  export type MACNOMaxAggregateInputType = {
    macno?: true
    bscd?: true
    macname?: true
  }

  export type MACNOCountAggregateInputType = {
    macno?: true
    bscd?: true
    macname?: true
    _all?: true
  }

  export type MACNOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MACNO to aggregate.
     */
    where?: MACNOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MACNOS to fetch.
     */
    orderBy?: MACNOOrderByWithRelationInput | MACNOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MACNOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MACNOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MACNOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MACNOS
    **/
    _count?: true | MACNOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MACNOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MACNOMaxAggregateInputType
  }

  export type GetMACNOAggregateType<T extends MACNOAggregateArgs> = {
        [P in keyof T & keyof AggregateMACNO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMACNO[P]>
      : GetScalarType<T[P], AggregateMACNO[P]>
  }




  export type MACNOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MACNOWhereInput
    orderBy?: MACNOOrderByWithAggregationInput | MACNOOrderByWithAggregationInput[]
    by: MACNOScalarFieldEnum[] | MACNOScalarFieldEnum
    having?: MACNOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MACNOCountAggregateInputType | true
    _min?: MACNOMinAggregateInputType
    _max?: MACNOMaxAggregateInputType
  }

  export type MACNOGroupByOutputType = {
    macno: string
    bscd: string
    macname: string
    _count: MACNOCountAggregateOutputType | null
    _min: MACNOMinAggregateOutputType | null
    _max: MACNOMaxAggregateOutputType | null
  }

  type GetMACNOGroupByPayload<T extends MACNOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MACNOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MACNOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MACNOGroupByOutputType[P]>
            : GetScalarType<T[P], MACNOGroupByOutputType[P]>
        }
      >
    >


  export type MACNOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    macno?: boolean
    bscd?: boolean
    macname?: boolean
    bscdRef?: boolean | BSCDDefaultArgs<ExtArgs>
    accounts?: boolean | MACNO$accountsArgs<ExtArgs>
    _count?: boolean | MACNOCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mACNO"]>

  export type MACNOSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    macno?: boolean
    bscd?: boolean
    macname?: boolean
    bscdRef?: boolean | BSCDDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mACNO"]>

  export type MACNOSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    macno?: boolean
    bscd?: boolean
    macname?: boolean
    bscdRef?: boolean | BSCDDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mACNO"]>

  export type MACNOSelectScalar = {
    macno?: boolean
    bscd?: boolean
    macname?: boolean
  }

  export type MACNOOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"macno" | "bscd" | "macname", ExtArgs["result"]["mACNO"]>
  export type MACNOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bscdRef?: boolean | BSCDDefaultArgs<ExtArgs>
    accounts?: boolean | MACNO$accountsArgs<ExtArgs>
    _count?: boolean | MACNOCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MACNOIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bscdRef?: boolean | BSCDDefaultArgs<ExtArgs>
  }
  export type MACNOIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bscdRef?: boolean | BSCDDefaultArgs<ExtArgs>
  }

  export type $MACNOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MACNO"
    objects: {
      bscdRef: Prisma.$BSCDPayload<ExtArgs>
      accounts: Prisma.$ACNOPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      macno: string
      bscd: string
      macname: string
    }, ExtArgs["result"]["mACNO"]>
    composites: {}
  }

  type MACNOGetPayload<S extends boolean | null | undefined | MACNODefaultArgs> = $Result.GetResult<Prisma.$MACNOPayload, S>

  type MACNOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MACNOFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MACNOCountAggregateInputType | true
    }

  export interface MACNODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MACNO'], meta: { name: 'MACNO' } }
    /**
     * Find zero or one MACNO that matches the filter.
     * @param {MACNOFindUniqueArgs} args - Arguments to find a MACNO
     * @example
     * // Get one MACNO
     * const mACNO = await prisma.mACNO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MACNOFindUniqueArgs>(args: SelectSubset<T, MACNOFindUniqueArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MACNO that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MACNOFindUniqueOrThrowArgs} args - Arguments to find a MACNO
     * @example
     * // Get one MACNO
     * const mACNO = await prisma.mACNO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MACNOFindUniqueOrThrowArgs>(args: SelectSubset<T, MACNOFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MACNO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MACNOFindFirstArgs} args - Arguments to find a MACNO
     * @example
     * // Get one MACNO
     * const mACNO = await prisma.mACNO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MACNOFindFirstArgs>(args?: SelectSubset<T, MACNOFindFirstArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MACNO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MACNOFindFirstOrThrowArgs} args - Arguments to find a MACNO
     * @example
     * // Get one MACNO
     * const mACNO = await prisma.mACNO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MACNOFindFirstOrThrowArgs>(args?: SelectSubset<T, MACNOFindFirstOrThrowArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MACNOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MACNOFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MACNOS
     * const mACNOS = await prisma.mACNO.findMany()
     * 
     * // Get first 10 MACNOS
     * const mACNOS = await prisma.mACNO.findMany({ take: 10 })
     * 
     * // Only select the `macno`
     * const mACNOWithMacnoOnly = await prisma.mACNO.findMany({ select: { macno: true } })
     * 
     */
    findMany<T extends MACNOFindManyArgs>(args?: SelectSubset<T, MACNOFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MACNO.
     * @param {MACNOCreateArgs} args - Arguments to create a MACNO.
     * @example
     * // Create one MACNO
     * const MACNO = await prisma.mACNO.create({
     *   data: {
     *     // ... data to create a MACNO
     *   }
     * })
     * 
     */
    create<T extends MACNOCreateArgs>(args: SelectSubset<T, MACNOCreateArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MACNOS.
     * @param {MACNOCreateManyArgs} args - Arguments to create many MACNOS.
     * @example
     * // Create many MACNOS
     * const mACNO = await prisma.mACNO.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MACNOCreateManyArgs>(args?: SelectSubset<T, MACNOCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MACNOS and returns the data saved in the database.
     * @param {MACNOCreateManyAndReturnArgs} args - Arguments to create many MACNOS.
     * @example
     * // Create many MACNOS
     * const mACNO = await prisma.mACNO.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MACNOS and only return the `macno`
     * const mACNOWithMacnoOnly = await prisma.mACNO.createManyAndReturn({
     *   select: { macno: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MACNOCreateManyAndReturnArgs>(args?: SelectSubset<T, MACNOCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MACNO.
     * @param {MACNODeleteArgs} args - Arguments to delete one MACNO.
     * @example
     * // Delete one MACNO
     * const MACNO = await prisma.mACNO.delete({
     *   where: {
     *     // ... filter to delete one MACNO
     *   }
     * })
     * 
     */
    delete<T extends MACNODeleteArgs>(args: SelectSubset<T, MACNODeleteArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MACNO.
     * @param {MACNOUpdateArgs} args - Arguments to update one MACNO.
     * @example
     * // Update one MACNO
     * const mACNO = await prisma.mACNO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MACNOUpdateArgs>(args: SelectSubset<T, MACNOUpdateArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MACNOS.
     * @param {MACNODeleteManyArgs} args - Arguments to filter MACNOS to delete.
     * @example
     * // Delete a few MACNOS
     * const { count } = await prisma.mACNO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MACNODeleteManyArgs>(args?: SelectSubset<T, MACNODeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MACNOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MACNOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MACNOS
     * const mACNO = await prisma.mACNO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MACNOUpdateManyArgs>(args: SelectSubset<T, MACNOUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MACNOS and returns the data updated in the database.
     * @param {MACNOUpdateManyAndReturnArgs} args - Arguments to update many MACNOS.
     * @example
     * // Update many MACNOS
     * const mACNO = await prisma.mACNO.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MACNOS and only return the `macno`
     * const mACNOWithMacnoOnly = await prisma.mACNO.updateManyAndReturn({
     *   select: { macno: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MACNOUpdateManyAndReturnArgs>(args: SelectSubset<T, MACNOUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MACNO.
     * @param {MACNOUpsertArgs} args - Arguments to update or create a MACNO.
     * @example
     * // Update or create a MACNO
     * const mACNO = await prisma.mACNO.upsert({
     *   create: {
     *     // ... data to create a MACNO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MACNO we want to update
     *   }
     * })
     */
    upsert<T extends MACNOUpsertArgs>(args: SelectSubset<T, MACNOUpsertArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MACNOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MACNOCountArgs} args - Arguments to filter MACNOS to count.
     * @example
     * // Count the number of MACNOS
     * const count = await prisma.mACNO.count({
     *   where: {
     *     // ... the filter for the MACNOS we want to count
     *   }
     * })
    **/
    count<T extends MACNOCountArgs>(
      args?: Subset<T, MACNOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MACNOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MACNO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MACNOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MACNOAggregateArgs>(args: Subset<T, MACNOAggregateArgs>): Prisma.PrismaPromise<GetMACNOAggregateType<T>>

    /**
     * Group by MACNO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MACNOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MACNOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MACNOGroupByArgs['orderBy'] }
        : { orderBy?: MACNOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MACNOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMACNOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MACNO model
   */
  readonly fields: MACNOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MACNO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MACNOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bscdRef<T extends BSCDDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BSCDDefaultArgs<ExtArgs>>): Prisma__BSCDClient<$Result.GetResult<Prisma.$BSCDPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accounts<T extends MACNO$accountsArgs<ExtArgs> = {}>(args?: Subset<T, MACNO$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MACNO model
   */
  interface MACNOFieldRefs {
    readonly macno: FieldRef<"MACNO", 'String'>
    readonly bscd: FieldRef<"MACNO", 'String'>
    readonly macname: FieldRef<"MACNO", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MACNO findUnique
   */
  export type MACNOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * Filter, which MACNO to fetch.
     */
    where: MACNOWhereUniqueInput
  }

  /**
   * MACNO findUniqueOrThrow
   */
  export type MACNOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * Filter, which MACNO to fetch.
     */
    where: MACNOWhereUniqueInput
  }

  /**
   * MACNO findFirst
   */
  export type MACNOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * Filter, which MACNO to fetch.
     */
    where?: MACNOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MACNOS to fetch.
     */
    orderBy?: MACNOOrderByWithRelationInput | MACNOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MACNOS.
     */
    cursor?: MACNOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MACNOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MACNOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MACNOS.
     */
    distinct?: MACNOScalarFieldEnum | MACNOScalarFieldEnum[]
  }

  /**
   * MACNO findFirstOrThrow
   */
  export type MACNOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * Filter, which MACNO to fetch.
     */
    where?: MACNOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MACNOS to fetch.
     */
    orderBy?: MACNOOrderByWithRelationInput | MACNOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MACNOS.
     */
    cursor?: MACNOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MACNOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MACNOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MACNOS.
     */
    distinct?: MACNOScalarFieldEnum | MACNOScalarFieldEnum[]
  }

  /**
   * MACNO findMany
   */
  export type MACNOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * Filter, which MACNOS to fetch.
     */
    where?: MACNOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MACNOS to fetch.
     */
    orderBy?: MACNOOrderByWithRelationInput | MACNOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MACNOS.
     */
    cursor?: MACNOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MACNOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MACNOS.
     */
    skip?: number
    distinct?: MACNOScalarFieldEnum | MACNOScalarFieldEnum[]
  }

  /**
   * MACNO create
   */
  export type MACNOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * The data needed to create a MACNO.
     */
    data: XOR<MACNOCreateInput, MACNOUncheckedCreateInput>
  }

  /**
   * MACNO createMany
   */
  export type MACNOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MACNOS.
     */
    data: MACNOCreateManyInput | MACNOCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MACNO createManyAndReturn
   */
  export type MACNOCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * The data used to create many MACNOS.
     */
    data: MACNOCreateManyInput | MACNOCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MACNO update
   */
  export type MACNOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * The data needed to update a MACNO.
     */
    data: XOR<MACNOUpdateInput, MACNOUncheckedUpdateInput>
    /**
     * Choose, which MACNO to update.
     */
    where: MACNOWhereUniqueInput
  }

  /**
   * MACNO updateMany
   */
  export type MACNOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MACNOS.
     */
    data: XOR<MACNOUpdateManyMutationInput, MACNOUncheckedUpdateManyInput>
    /**
     * Filter which MACNOS to update
     */
    where?: MACNOWhereInput
    /**
     * Limit how many MACNOS to update.
     */
    limit?: number
  }

  /**
   * MACNO updateManyAndReturn
   */
  export type MACNOUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * The data used to update MACNOS.
     */
    data: XOR<MACNOUpdateManyMutationInput, MACNOUncheckedUpdateManyInput>
    /**
     * Filter which MACNOS to update
     */
    where?: MACNOWhereInput
    /**
     * Limit how many MACNOS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MACNO upsert
   */
  export type MACNOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * The filter to search for the MACNO to update in case it exists.
     */
    where: MACNOWhereUniqueInput
    /**
     * In case the MACNO found by the `where` argument doesn't exist, create a new MACNO with this data.
     */
    create: XOR<MACNOCreateInput, MACNOUncheckedCreateInput>
    /**
     * In case the MACNO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MACNOUpdateInput, MACNOUncheckedUpdateInput>
  }

  /**
   * MACNO delete
   */
  export type MACNODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
    /**
     * Filter which MACNO to delete.
     */
    where: MACNOWhereUniqueInput
  }

  /**
   * MACNO deleteMany
   */
  export type MACNODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MACNOS to delete
     */
    where?: MACNOWhereInput
    /**
     * Limit how many MACNOS to delete.
     */
    limit?: number
  }

  /**
   * MACNO.accounts
   */
  export type MACNO$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    where?: ACNOWhereInput
    orderBy?: ACNOOrderByWithRelationInput | ACNOOrderByWithRelationInput[]
    cursor?: ACNOWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ACNOScalarFieldEnum | ACNOScalarFieldEnum[]
  }

  /**
   * MACNO without action
   */
  export type MACNODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MACNO
     */
    select?: MACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MACNO
     */
    omit?: MACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MACNOInclude<ExtArgs> | null
  }


  /**
   * Model ACNO
   */

  export type AggregateACNO = {
    _count: ACNOCountAggregateOutputType | null
    _avg: ACNOAvgAggregateOutputType | null
    _sum: ACNOSumAggregateOutputType | null
    _min: ACNOMinAggregateOutputType | null
    _max: ACNOMaxAggregateOutputType | null
  }

  export type ACNOAvgAggregateOutputType = {
    crDays: number | null
    stRate: Decimal | null
    crLimit: number | null
  }

  export type ACNOSumAggregateOutputType = {
    crDays: number | null
    stRate: Decimal | null
    crLimit: number | null
  }

  export type ACNOMinAggregateOutputType = {
    acno: string | null
    macno: string | null
    acname: string | null
    bankAccountNo: string | null
    address: string | null
    city: string | null
    phoneFax: string | null
    email: string | null
    website: string | null
    crDays: number | null
    stRate: Decimal | null
    area: string | null
    category: string | null
    subCategory: string | null
    country: string | null
    customerBank: string | null
    customerBankAddr: string | null
    stRegNo: string | null
    ntnNo: string | null
    contactPerson: string | null
    crLimit: number | null
    salesArea: string | null
  }

  export type ACNOMaxAggregateOutputType = {
    acno: string | null
    macno: string | null
    acname: string | null
    bankAccountNo: string | null
    address: string | null
    city: string | null
    phoneFax: string | null
    email: string | null
    website: string | null
    crDays: number | null
    stRate: Decimal | null
    area: string | null
    category: string | null
    subCategory: string | null
    country: string | null
    customerBank: string | null
    customerBankAddr: string | null
    stRegNo: string | null
    ntnNo: string | null
    contactPerson: string | null
    crLimit: number | null
    salesArea: string | null
  }

  export type ACNOCountAggregateOutputType = {
    acno: number
    macno: number
    acname: number
    bankAccountNo: number
    address: number
    city: number
    phoneFax: number
    email: number
    website: number
    crDays: number
    stRate: number
    area: number
    category: number
    subCategory: number
    country: number
    customerBank: number
    customerBankAddr: number
    stRegNo: number
    ntnNo: number
    contactPerson: number
    crLimit: number
    salesArea: number
    _all: number
  }


  export type ACNOAvgAggregateInputType = {
    crDays?: true
    stRate?: true
    crLimit?: true
  }

  export type ACNOSumAggregateInputType = {
    crDays?: true
    stRate?: true
    crLimit?: true
  }

  export type ACNOMinAggregateInputType = {
    acno?: true
    macno?: true
    acname?: true
    bankAccountNo?: true
    address?: true
    city?: true
    phoneFax?: true
    email?: true
    website?: true
    crDays?: true
    stRate?: true
    area?: true
    category?: true
    subCategory?: true
    country?: true
    customerBank?: true
    customerBankAddr?: true
    stRegNo?: true
    ntnNo?: true
    contactPerson?: true
    crLimit?: true
    salesArea?: true
  }

  export type ACNOMaxAggregateInputType = {
    acno?: true
    macno?: true
    acname?: true
    bankAccountNo?: true
    address?: true
    city?: true
    phoneFax?: true
    email?: true
    website?: true
    crDays?: true
    stRate?: true
    area?: true
    category?: true
    subCategory?: true
    country?: true
    customerBank?: true
    customerBankAddr?: true
    stRegNo?: true
    ntnNo?: true
    contactPerson?: true
    crLimit?: true
    salesArea?: true
  }

  export type ACNOCountAggregateInputType = {
    acno?: true
    macno?: true
    acname?: true
    bankAccountNo?: true
    address?: true
    city?: true
    phoneFax?: true
    email?: true
    website?: true
    crDays?: true
    stRate?: true
    area?: true
    category?: true
    subCategory?: true
    country?: true
    customerBank?: true
    customerBankAddr?: true
    stRegNo?: true
    ntnNo?: true
    contactPerson?: true
    crLimit?: true
    salesArea?: true
    _all?: true
  }

  export type ACNOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ACNO to aggregate.
     */
    where?: ACNOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ACNOS to fetch.
     */
    orderBy?: ACNOOrderByWithRelationInput | ACNOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ACNOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ACNOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ACNOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ACNOS
    **/
    _count?: true | ACNOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ACNOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ACNOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ACNOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ACNOMaxAggregateInputType
  }

  export type GetACNOAggregateType<T extends ACNOAggregateArgs> = {
        [P in keyof T & keyof AggregateACNO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateACNO[P]>
      : GetScalarType<T[P], AggregateACNO[P]>
  }




  export type ACNOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ACNOWhereInput
    orderBy?: ACNOOrderByWithAggregationInput | ACNOOrderByWithAggregationInput[]
    by: ACNOScalarFieldEnum[] | ACNOScalarFieldEnum
    having?: ACNOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ACNOCountAggregateInputType | true
    _avg?: ACNOAvgAggregateInputType
    _sum?: ACNOSumAggregateInputType
    _min?: ACNOMinAggregateInputType
    _max?: ACNOMaxAggregateInputType
  }

  export type ACNOGroupByOutputType = {
    acno: string
    macno: string
    acname: string
    bankAccountNo: string | null
    address: string | null
    city: string | null
    phoneFax: string | null
    email: string | null
    website: string | null
    crDays: number | null
    stRate: Decimal | null
    area: string | null
    category: string | null
    subCategory: string | null
    country: string | null
    customerBank: string | null
    customerBankAddr: string | null
    stRegNo: string | null
    ntnNo: string | null
    contactPerson: string | null
    crLimit: number | null
    salesArea: string | null
    _count: ACNOCountAggregateOutputType | null
    _avg: ACNOAvgAggregateOutputType | null
    _sum: ACNOSumAggregateOutputType | null
    _min: ACNOMinAggregateOutputType | null
    _max: ACNOMaxAggregateOutputType | null
  }

  type GetACNOGroupByPayload<T extends ACNOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ACNOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ACNOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ACNOGroupByOutputType[P]>
            : GetScalarType<T[P], ACNOGroupByOutputType[P]>
        }
      >
    >


  export type ACNOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    acno?: boolean
    macno?: boolean
    acname?: boolean
    bankAccountNo?: boolean
    address?: boolean
    city?: boolean
    phoneFax?: boolean
    email?: boolean
    website?: boolean
    crDays?: boolean
    stRate?: boolean
    area?: boolean
    category?: boolean
    subCategory?: boolean
    country?: boolean
    customerBank?: boolean
    customerBankAddr?: boolean
    stRegNo?: boolean
    ntnNo?: boolean
    contactPerson?: boolean
    crLimit?: boolean
    salesArea?: boolean
    transactionsMaster?: boolean | ACNO$transactionsMasterArgs<ExtArgs>
    transactions?: boolean | ACNO$transactionsArgs<ExtArgs>
    mainAccount?: boolean | MACNODefaultArgs<ExtArgs>
    _count?: boolean | ACNOCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aCNO"]>

  export type ACNOSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    acno?: boolean
    macno?: boolean
    acname?: boolean
    bankAccountNo?: boolean
    address?: boolean
    city?: boolean
    phoneFax?: boolean
    email?: boolean
    website?: boolean
    crDays?: boolean
    stRate?: boolean
    area?: boolean
    category?: boolean
    subCategory?: boolean
    country?: boolean
    customerBank?: boolean
    customerBankAddr?: boolean
    stRegNo?: boolean
    ntnNo?: boolean
    contactPerson?: boolean
    crLimit?: boolean
    salesArea?: boolean
    mainAccount?: boolean | MACNODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aCNO"]>

  export type ACNOSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    acno?: boolean
    macno?: boolean
    acname?: boolean
    bankAccountNo?: boolean
    address?: boolean
    city?: boolean
    phoneFax?: boolean
    email?: boolean
    website?: boolean
    crDays?: boolean
    stRate?: boolean
    area?: boolean
    category?: boolean
    subCategory?: boolean
    country?: boolean
    customerBank?: boolean
    customerBankAddr?: boolean
    stRegNo?: boolean
    ntnNo?: boolean
    contactPerson?: boolean
    crLimit?: boolean
    salesArea?: boolean
    mainAccount?: boolean | MACNODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aCNO"]>

  export type ACNOSelectScalar = {
    acno?: boolean
    macno?: boolean
    acname?: boolean
    bankAccountNo?: boolean
    address?: boolean
    city?: boolean
    phoneFax?: boolean
    email?: boolean
    website?: boolean
    crDays?: boolean
    stRate?: boolean
    area?: boolean
    category?: boolean
    subCategory?: boolean
    country?: boolean
    customerBank?: boolean
    customerBankAddr?: boolean
    stRegNo?: boolean
    ntnNo?: boolean
    contactPerson?: boolean
    crLimit?: boolean
    salesArea?: boolean
  }

  export type ACNOOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"acno" | "macno" | "acname" | "bankAccountNo" | "address" | "city" | "phoneFax" | "email" | "website" | "crDays" | "stRate" | "area" | "category" | "subCategory" | "country" | "customerBank" | "customerBankAddr" | "stRegNo" | "ntnNo" | "contactPerson" | "crLimit" | "salesArea", ExtArgs["result"]["aCNO"]>
  export type ACNOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionsMaster?: boolean | ACNO$transactionsMasterArgs<ExtArgs>
    transactions?: boolean | ACNO$transactionsArgs<ExtArgs>
    mainAccount?: boolean | MACNODefaultArgs<ExtArgs>
    _count?: boolean | ACNOCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ACNOIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainAccount?: boolean | MACNODefaultArgs<ExtArgs>
  }
  export type ACNOIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainAccount?: boolean | MACNODefaultArgs<ExtArgs>
  }

  export type $ACNOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ACNO"
    objects: {
      transactionsMaster: Prisma.$TransactionsMasterPayload<ExtArgs>[]
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
      mainAccount: Prisma.$MACNOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      acno: string
      macno: string
      acname: string
      bankAccountNo: string | null
      address: string | null
      city: string | null
      phoneFax: string | null
      email: string | null
      website: string | null
      crDays: number | null
      stRate: Prisma.Decimal | null
      area: string | null
      category: string | null
      subCategory: string | null
      country: string | null
      customerBank: string | null
      customerBankAddr: string | null
      stRegNo: string | null
      ntnNo: string | null
      contactPerson: string | null
      crLimit: number | null
      salesArea: string | null
    }, ExtArgs["result"]["aCNO"]>
    composites: {}
  }

  type ACNOGetPayload<S extends boolean | null | undefined | ACNODefaultArgs> = $Result.GetResult<Prisma.$ACNOPayload, S>

  type ACNOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ACNOFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ACNOCountAggregateInputType | true
    }

  export interface ACNODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ACNO'], meta: { name: 'ACNO' } }
    /**
     * Find zero or one ACNO that matches the filter.
     * @param {ACNOFindUniqueArgs} args - Arguments to find a ACNO
     * @example
     * // Get one ACNO
     * const aCNO = await prisma.aCNO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ACNOFindUniqueArgs>(args: SelectSubset<T, ACNOFindUniqueArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ACNO that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ACNOFindUniqueOrThrowArgs} args - Arguments to find a ACNO
     * @example
     * // Get one ACNO
     * const aCNO = await prisma.aCNO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ACNOFindUniqueOrThrowArgs>(args: SelectSubset<T, ACNOFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ACNO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACNOFindFirstArgs} args - Arguments to find a ACNO
     * @example
     * // Get one ACNO
     * const aCNO = await prisma.aCNO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ACNOFindFirstArgs>(args?: SelectSubset<T, ACNOFindFirstArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ACNO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACNOFindFirstOrThrowArgs} args - Arguments to find a ACNO
     * @example
     * // Get one ACNO
     * const aCNO = await prisma.aCNO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ACNOFindFirstOrThrowArgs>(args?: SelectSubset<T, ACNOFindFirstOrThrowArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ACNOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACNOFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ACNOS
     * const aCNOS = await prisma.aCNO.findMany()
     * 
     * // Get first 10 ACNOS
     * const aCNOS = await prisma.aCNO.findMany({ take: 10 })
     * 
     * // Only select the `acno`
     * const aCNOWithAcnoOnly = await prisma.aCNO.findMany({ select: { acno: true } })
     * 
     */
    findMany<T extends ACNOFindManyArgs>(args?: SelectSubset<T, ACNOFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ACNO.
     * @param {ACNOCreateArgs} args - Arguments to create a ACNO.
     * @example
     * // Create one ACNO
     * const ACNO = await prisma.aCNO.create({
     *   data: {
     *     // ... data to create a ACNO
     *   }
     * })
     * 
     */
    create<T extends ACNOCreateArgs>(args: SelectSubset<T, ACNOCreateArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ACNOS.
     * @param {ACNOCreateManyArgs} args - Arguments to create many ACNOS.
     * @example
     * // Create many ACNOS
     * const aCNO = await prisma.aCNO.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ACNOCreateManyArgs>(args?: SelectSubset<T, ACNOCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ACNOS and returns the data saved in the database.
     * @param {ACNOCreateManyAndReturnArgs} args - Arguments to create many ACNOS.
     * @example
     * // Create many ACNOS
     * const aCNO = await prisma.aCNO.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ACNOS and only return the `acno`
     * const aCNOWithAcnoOnly = await prisma.aCNO.createManyAndReturn({
     *   select: { acno: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ACNOCreateManyAndReturnArgs>(args?: SelectSubset<T, ACNOCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ACNO.
     * @param {ACNODeleteArgs} args - Arguments to delete one ACNO.
     * @example
     * // Delete one ACNO
     * const ACNO = await prisma.aCNO.delete({
     *   where: {
     *     // ... filter to delete one ACNO
     *   }
     * })
     * 
     */
    delete<T extends ACNODeleteArgs>(args: SelectSubset<T, ACNODeleteArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ACNO.
     * @param {ACNOUpdateArgs} args - Arguments to update one ACNO.
     * @example
     * // Update one ACNO
     * const aCNO = await prisma.aCNO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ACNOUpdateArgs>(args: SelectSubset<T, ACNOUpdateArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ACNOS.
     * @param {ACNODeleteManyArgs} args - Arguments to filter ACNOS to delete.
     * @example
     * // Delete a few ACNOS
     * const { count } = await prisma.aCNO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ACNODeleteManyArgs>(args?: SelectSubset<T, ACNODeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ACNOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACNOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ACNOS
     * const aCNO = await prisma.aCNO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ACNOUpdateManyArgs>(args: SelectSubset<T, ACNOUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ACNOS and returns the data updated in the database.
     * @param {ACNOUpdateManyAndReturnArgs} args - Arguments to update many ACNOS.
     * @example
     * // Update many ACNOS
     * const aCNO = await prisma.aCNO.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ACNOS and only return the `acno`
     * const aCNOWithAcnoOnly = await prisma.aCNO.updateManyAndReturn({
     *   select: { acno: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ACNOUpdateManyAndReturnArgs>(args: SelectSubset<T, ACNOUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ACNO.
     * @param {ACNOUpsertArgs} args - Arguments to update or create a ACNO.
     * @example
     * // Update or create a ACNO
     * const aCNO = await prisma.aCNO.upsert({
     *   create: {
     *     // ... data to create a ACNO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ACNO we want to update
     *   }
     * })
     */
    upsert<T extends ACNOUpsertArgs>(args: SelectSubset<T, ACNOUpsertArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ACNOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACNOCountArgs} args - Arguments to filter ACNOS to count.
     * @example
     * // Count the number of ACNOS
     * const count = await prisma.aCNO.count({
     *   where: {
     *     // ... the filter for the ACNOS we want to count
     *   }
     * })
    **/
    count<T extends ACNOCountArgs>(
      args?: Subset<T, ACNOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ACNOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ACNO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACNOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ACNOAggregateArgs>(args: Subset<T, ACNOAggregateArgs>): Prisma.PrismaPromise<GetACNOAggregateType<T>>

    /**
     * Group by ACNO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACNOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ACNOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ACNOGroupByArgs['orderBy'] }
        : { orderBy?: ACNOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ACNOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetACNOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ACNO model
   */
  readonly fields: ACNOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ACNO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ACNOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactionsMaster<T extends ACNO$transactionsMasterArgs<ExtArgs> = {}>(args?: Subset<T, ACNO$transactionsMasterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends ACNO$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, ACNO$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mainAccount<T extends MACNODefaultArgs<ExtArgs> = {}>(args?: Subset<T, MACNODefaultArgs<ExtArgs>>): Prisma__MACNOClient<$Result.GetResult<Prisma.$MACNOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ACNO model
   */
  interface ACNOFieldRefs {
    readonly acno: FieldRef<"ACNO", 'String'>
    readonly macno: FieldRef<"ACNO", 'String'>
    readonly acname: FieldRef<"ACNO", 'String'>
    readonly bankAccountNo: FieldRef<"ACNO", 'String'>
    readonly address: FieldRef<"ACNO", 'String'>
    readonly city: FieldRef<"ACNO", 'String'>
    readonly phoneFax: FieldRef<"ACNO", 'String'>
    readonly email: FieldRef<"ACNO", 'String'>
    readonly website: FieldRef<"ACNO", 'String'>
    readonly crDays: FieldRef<"ACNO", 'Int'>
    readonly stRate: FieldRef<"ACNO", 'Decimal'>
    readonly area: FieldRef<"ACNO", 'String'>
    readonly category: FieldRef<"ACNO", 'String'>
    readonly subCategory: FieldRef<"ACNO", 'String'>
    readonly country: FieldRef<"ACNO", 'String'>
    readonly customerBank: FieldRef<"ACNO", 'String'>
    readonly customerBankAddr: FieldRef<"ACNO", 'String'>
    readonly stRegNo: FieldRef<"ACNO", 'String'>
    readonly ntnNo: FieldRef<"ACNO", 'String'>
    readonly contactPerson: FieldRef<"ACNO", 'String'>
    readonly crLimit: FieldRef<"ACNO", 'Int'>
    readonly salesArea: FieldRef<"ACNO", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ACNO findUnique
   */
  export type ACNOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * Filter, which ACNO to fetch.
     */
    where: ACNOWhereUniqueInput
  }

  /**
   * ACNO findUniqueOrThrow
   */
  export type ACNOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * Filter, which ACNO to fetch.
     */
    where: ACNOWhereUniqueInput
  }

  /**
   * ACNO findFirst
   */
  export type ACNOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * Filter, which ACNO to fetch.
     */
    where?: ACNOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ACNOS to fetch.
     */
    orderBy?: ACNOOrderByWithRelationInput | ACNOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ACNOS.
     */
    cursor?: ACNOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ACNOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ACNOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ACNOS.
     */
    distinct?: ACNOScalarFieldEnum | ACNOScalarFieldEnum[]
  }

  /**
   * ACNO findFirstOrThrow
   */
  export type ACNOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * Filter, which ACNO to fetch.
     */
    where?: ACNOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ACNOS to fetch.
     */
    orderBy?: ACNOOrderByWithRelationInput | ACNOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ACNOS.
     */
    cursor?: ACNOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ACNOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ACNOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ACNOS.
     */
    distinct?: ACNOScalarFieldEnum | ACNOScalarFieldEnum[]
  }

  /**
   * ACNO findMany
   */
  export type ACNOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * Filter, which ACNOS to fetch.
     */
    where?: ACNOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ACNOS to fetch.
     */
    orderBy?: ACNOOrderByWithRelationInput | ACNOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ACNOS.
     */
    cursor?: ACNOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ACNOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ACNOS.
     */
    skip?: number
    distinct?: ACNOScalarFieldEnum | ACNOScalarFieldEnum[]
  }

  /**
   * ACNO create
   */
  export type ACNOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * The data needed to create a ACNO.
     */
    data: XOR<ACNOCreateInput, ACNOUncheckedCreateInput>
  }

  /**
   * ACNO createMany
   */
  export type ACNOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ACNOS.
     */
    data: ACNOCreateManyInput | ACNOCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ACNO createManyAndReturn
   */
  export type ACNOCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * The data used to create many ACNOS.
     */
    data: ACNOCreateManyInput | ACNOCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ACNO update
   */
  export type ACNOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * The data needed to update a ACNO.
     */
    data: XOR<ACNOUpdateInput, ACNOUncheckedUpdateInput>
    /**
     * Choose, which ACNO to update.
     */
    where: ACNOWhereUniqueInput
  }

  /**
   * ACNO updateMany
   */
  export type ACNOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ACNOS.
     */
    data: XOR<ACNOUpdateManyMutationInput, ACNOUncheckedUpdateManyInput>
    /**
     * Filter which ACNOS to update
     */
    where?: ACNOWhereInput
    /**
     * Limit how many ACNOS to update.
     */
    limit?: number
  }

  /**
   * ACNO updateManyAndReturn
   */
  export type ACNOUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * The data used to update ACNOS.
     */
    data: XOR<ACNOUpdateManyMutationInput, ACNOUncheckedUpdateManyInput>
    /**
     * Filter which ACNOS to update
     */
    where?: ACNOWhereInput
    /**
     * Limit how many ACNOS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ACNO upsert
   */
  export type ACNOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * The filter to search for the ACNO to update in case it exists.
     */
    where: ACNOWhereUniqueInput
    /**
     * In case the ACNO found by the `where` argument doesn't exist, create a new ACNO with this data.
     */
    create: XOR<ACNOCreateInput, ACNOUncheckedCreateInput>
    /**
     * In case the ACNO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ACNOUpdateInput, ACNOUncheckedUpdateInput>
  }

  /**
   * ACNO delete
   */
  export type ACNODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    /**
     * Filter which ACNO to delete.
     */
    where: ACNOWhereUniqueInput
  }

  /**
   * ACNO deleteMany
   */
  export type ACNODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ACNOS to delete
     */
    where?: ACNOWhereInput
    /**
     * Limit how many ACNOS to delete.
     */
    limit?: number
  }

  /**
   * ACNO.transactionsMaster
   */
  export type ACNO$transactionsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    where?: TransactionsMasterWhereInput
    orderBy?: TransactionsMasterOrderByWithRelationInput | TransactionsMasterOrderByWithRelationInput[]
    cursor?: TransactionsMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsMasterScalarFieldEnum | TransactionsMasterScalarFieldEnum[]
  }

  /**
   * ACNO.transactions
   */
  export type ACNO$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * ACNO without action
   */
  export type ACNODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    company: string | null
    addr1: string | null
    addr2: string | null
    city: string | null
    phone: string | null
    fax: string | null
    email: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    company: string | null
    addr1: string | null
    addr2: string | null
    city: string | null
    phone: string | null
    fax: string | null
    email: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    company: number
    addr1: number
    addr2: number
    city: number
    phone: number
    fax: number
    email: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    company?: true
    addr1?: true
    addr2?: true
    city?: true
    phone?: true
    fax?: true
    email?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    company?: true
    addr1?: true
    addr2?: true
    city?: true
    phone?: true
    fax?: true
    email?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    company?: true
    addr1?: true
    addr2?: true
    city?: true
    phone?: true
    fax?: true
    email?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    company: string | null
    addr1: string | null
    addr2: string | null
    city: string | null
    phone: string | null
    fax: string | null
    email: string | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    addr1?: boolean
    addr2?: boolean
    city?: boolean
    phone?: boolean
    fax?: boolean
    email?: boolean
    costCenters?: boolean | Company$costCentersArgs<ExtArgs>
    departments?: boolean | Company$departmentsArgs<ExtArgs>
    designations?: boolean | Company$designationsArgs<ExtArgs>
    godowns?: boolean | Company$godownsArgs<ExtArgs>
    TransactionsMaster?: boolean | Company$TransactionsMasterArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    financialYears?: boolean | Company$financialYearsArgs<ExtArgs>
    seasons?: boolean | Company$seasonsArgs<ExtArgs>
    poPrdCats?: boolean | Company$poPrdCatsArgs<ExtArgs>
    deliveryModes?: boolean | Company$deliveryModesArgs<ExtArgs>
    deliveryTerms?: boolean | Company$deliveryTermsArgs<ExtArgs>
    commissionTerms?: boolean | Company$commissionTermsArgs<ExtArgs>
    employees?: boolean | Company$employeesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    addr1?: boolean
    addr2?: boolean
    city?: boolean
    phone?: boolean
    fax?: boolean
    email?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    addr1?: boolean
    addr2?: boolean
    city?: boolean
    phone?: boolean
    fax?: boolean
    email?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    company?: boolean
    addr1?: boolean
    addr2?: boolean
    city?: boolean
    phone?: boolean
    fax?: boolean
    email?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company" | "addr1" | "addr2" | "city" | "phone" | "fax" | "email", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costCenters?: boolean | Company$costCentersArgs<ExtArgs>
    departments?: boolean | Company$departmentsArgs<ExtArgs>
    designations?: boolean | Company$designationsArgs<ExtArgs>
    godowns?: boolean | Company$godownsArgs<ExtArgs>
    TransactionsMaster?: boolean | Company$TransactionsMasterArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    financialYears?: boolean | Company$financialYearsArgs<ExtArgs>
    seasons?: boolean | Company$seasonsArgs<ExtArgs>
    poPrdCats?: boolean | Company$poPrdCatsArgs<ExtArgs>
    deliveryModes?: boolean | Company$deliveryModesArgs<ExtArgs>
    deliveryTerms?: boolean | Company$deliveryTermsArgs<ExtArgs>
    commissionTerms?: boolean | Company$commissionTermsArgs<ExtArgs>
    employees?: boolean | Company$employeesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      costCenters: Prisma.$CostCenterPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      designations: Prisma.$DesignationPayload<ExtArgs>[]
      godowns: Prisma.$GodownPayload<ExtArgs>[]
      TransactionsMaster: Prisma.$TransactionsMasterPayload<ExtArgs>[]
      users: Prisma.$UsersPayload<ExtArgs>[]
      financialYears: Prisma.$FinancialYearPayload<ExtArgs>[]
      seasons: Prisma.$SeasonPayload<ExtArgs>[]
      poPrdCats: Prisma.$PoPrdCatPayload<ExtArgs>[]
      deliveryModes: Prisma.$DeliveryModePayload<ExtArgs>[]
      deliveryTerms: Prisma.$DeliveryTermPayload<ExtArgs>[]
      commissionTerms: Prisma.$CommissionTermPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company: string | null
      addr1: string | null
      addr2: string | null
      city: string | null
      phone: string | null
      fax: string | null
      email: string | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costCenters<T extends Company$costCentersArgs<ExtArgs> = {}>(args?: Subset<T, Company$costCentersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends Company$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    designations<T extends Company$designationsArgs<ExtArgs> = {}>(args?: Subset<T, Company$designationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    godowns<T extends Company$godownsArgs<ExtArgs> = {}>(args?: Subset<T, Company$godownsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TransactionsMaster<T extends Company$TransactionsMasterArgs<ExtArgs> = {}>(args?: Subset<T, Company$TransactionsMasterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialYears<T extends Company$financialYearsArgs<ExtArgs> = {}>(args?: Subset<T, Company$financialYearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seasons<T extends Company$seasonsArgs<ExtArgs> = {}>(args?: Subset<T, Company$seasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    poPrdCats<T extends Company$poPrdCatsArgs<ExtArgs> = {}>(args?: Subset<T, Company$poPrdCatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryModes<T extends Company$deliveryModesArgs<ExtArgs> = {}>(args?: Subset<T, Company$deliveryModesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryTerms<T extends Company$deliveryTermsArgs<ExtArgs> = {}>(args?: Subset<T, Company$deliveryTermsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commissionTerms<T extends Company$commissionTermsArgs<ExtArgs> = {}>(args?: Subset<T, Company$commissionTermsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Company$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Company$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly company: FieldRef<"Company", 'String'>
    readonly addr1: FieldRef<"Company", 'String'>
    readonly addr2: FieldRef<"Company", 'String'>
    readonly city: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly fax: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data?: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.costCenters
   */
  export type Company$costCentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    where?: CostCenterWhereInput
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    cursor?: CostCenterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * Company.departments
   */
  export type Company$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Company.designations
   */
  export type Company$designationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    where?: DesignationWhereInput
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    cursor?: DesignationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Company.godowns
   */
  export type Company$godownsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    where?: GodownWhereInput
    orderBy?: GodownOrderByWithRelationInput | GodownOrderByWithRelationInput[]
    cursor?: GodownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GodownScalarFieldEnum | GodownScalarFieldEnum[]
  }

  /**
   * Company.TransactionsMaster
   */
  export type Company$TransactionsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    where?: TransactionsMasterWhereInput
    orderBy?: TransactionsMasterOrderByWithRelationInput | TransactionsMasterOrderByWithRelationInput[]
    cursor?: TransactionsMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsMasterScalarFieldEnum | TransactionsMasterScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Company.financialYears
   */
  export type Company$financialYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    where?: FinancialYearWhereInput
    orderBy?: FinancialYearOrderByWithRelationInput | FinancialYearOrderByWithRelationInput[]
    cursor?: FinancialYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialYearScalarFieldEnum | FinancialYearScalarFieldEnum[]
  }

  /**
   * Company.seasons
   */
  export type Company$seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    cursor?: SeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Company.poPrdCats
   */
  export type Company$poPrdCatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    where?: PoPrdCatWhereInput
    orderBy?: PoPrdCatOrderByWithRelationInput | PoPrdCatOrderByWithRelationInput[]
    cursor?: PoPrdCatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoPrdCatScalarFieldEnum | PoPrdCatScalarFieldEnum[]
  }

  /**
   * Company.deliveryModes
   */
  export type Company$deliveryModesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    where?: DeliveryModeWhereInput
    orderBy?: DeliveryModeOrderByWithRelationInput | DeliveryModeOrderByWithRelationInput[]
    cursor?: DeliveryModeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryModeScalarFieldEnum | DeliveryModeScalarFieldEnum[]
  }

  /**
   * Company.deliveryTerms
   */
  export type Company$deliveryTermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    where?: DeliveryTermWhereInput
    orderBy?: DeliveryTermOrderByWithRelationInput | DeliveryTermOrderByWithRelationInput[]
    cursor?: DeliveryTermWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryTermScalarFieldEnum | DeliveryTermScalarFieldEnum[]
  }

  /**
   * Company.commissionTerms
   */
  export type Company$commissionTermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    where?: CommissionTermWhereInput
    orderBy?: CommissionTermOrderByWithRelationInput | CommissionTermOrderByWithRelationInput[]
    cursor?: CommissionTermWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionTermScalarFieldEnum | CommissionTermScalarFieldEnum[]
  }

  /**
   * Company.employees
   */
  export type Company$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CostCenter
   */

  export type AggregateCostCenter = {
    _count: CostCenterCountAggregateOutputType | null
    _avg: CostCenterAvgAggregateOutputType | null
    _sum: CostCenterSumAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  export type CostCenterAvgAggregateOutputType = {
    ccno: number | null
    company_id: number | null
  }

  export type CostCenterSumAggregateOutputType = {
    ccno: number | null
    company_id: number | null
  }

  export type CostCenterMinAggregateOutputType = {
    ccno: number | null
    company_id: number | null
    ccname: string | null
  }

  export type CostCenterMaxAggregateOutputType = {
    ccno: number | null
    company_id: number | null
    ccname: string | null
  }

  export type CostCenterCountAggregateOutputType = {
    ccno: number
    company_id: number
    ccname: number
    _all: number
  }


  export type CostCenterAvgAggregateInputType = {
    ccno?: true
    company_id?: true
  }

  export type CostCenterSumAggregateInputType = {
    ccno?: true
    company_id?: true
  }

  export type CostCenterMinAggregateInputType = {
    ccno?: true
    company_id?: true
    ccname?: true
  }

  export type CostCenterMaxAggregateInputType = {
    ccno?: true
    company_id?: true
    ccname?: true
  }

  export type CostCenterCountAggregateInputType = {
    ccno?: true
    company_id?: true
    ccname?: true
    _all?: true
  }

  export type CostCenterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCenter to aggregate.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostCenters
    **/
    _count?: true | CostCenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostCenterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostCenterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostCenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostCenterMaxAggregateInputType
  }

  export type GetCostCenterAggregateType<T extends CostCenterAggregateArgs> = {
        [P in keyof T & keyof AggregateCostCenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostCenter[P]>
      : GetScalarType<T[P], AggregateCostCenter[P]>
  }




  export type CostCenterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostCenterWhereInput
    orderBy?: CostCenterOrderByWithAggregationInput | CostCenterOrderByWithAggregationInput[]
    by: CostCenterScalarFieldEnum[] | CostCenterScalarFieldEnum
    having?: CostCenterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCenterCountAggregateInputType | true
    _avg?: CostCenterAvgAggregateInputType
    _sum?: CostCenterSumAggregateInputType
    _min?: CostCenterMinAggregateInputType
    _max?: CostCenterMaxAggregateInputType
  }

  export type CostCenterGroupByOutputType = {
    ccno: number
    company_id: number
    ccname: string | null
    _count: CostCenterCountAggregateOutputType | null
    _avg: CostCenterAvgAggregateOutputType | null
    _sum: CostCenterSumAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  type GetCostCenterGroupByPayload<T extends CostCenterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostCenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostCenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
            : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
        }
      >
    >


  export type CostCenterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ccno?: boolean
    company_id?: boolean
    ccname?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    Transaction?: boolean | CostCenter$TransactionArgs<ExtArgs>
    _count?: boolean | CostCenterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ccno?: boolean
    company_id?: boolean
    ccname?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ccno?: boolean
    company_id?: boolean
    ccname?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectScalar = {
    ccno?: boolean
    company_id?: boolean
    ccname?: boolean
  }

  export type CostCenterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ccno" | "company_id" | "ccname", ExtArgs["result"]["costCenter"]>
  export type CostCenterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    Transaction?: boolean | CostCenter$TransactionArgs<ExtArgs>
    _count?: boolean | CostCenterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostCenterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CostCenterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CostCenterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostCenter"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      Transaction: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ccno: number
      company_id: number
      ccname: string | null
    }, ExtArgs["result"]["costCenter"]>
    composites: {}
  }

  type CostCenterGetPayload<S extends boolean | null | undefined | CostCenterDefaultArgs> = $Result.GetResult<Prisma.$CostCenterPayload, S>

  type CostCenterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostCenterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostCenterCountAggregateInputType | true
    }

  export interface CostCenterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostCenter'], meta: { name: 'CostCenter' } }
    /**
     * Find zero or one CostCenter that matches the filter.
     * @param {CostCenterFindUniqueArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostCenterFindUniqueArgs>(args: SelectSubset<T, CostCenterFindUniqueArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostCenter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostCenterFindUniqueOrThrowArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostCenterFindUniqueOrThrowArgs>(args: SelectSubset<T, CostCenterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostCenter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostCenterFindFirstArgs>(args?: SelectSubset<T, CostCenterFindFirstArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostCenter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstOrThrowArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostCenterFindFirstOrThrowArgs>(args?: SelectSubset<T, CostCenterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostCenters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostCenters
     * const costCenters = await prisma.costCenter.findMany()
     * 
     * // Get first 10 CostCenters
     * const costCenters = await prisma.costCenter.findMany({ take: 10 })
     * 
     * // Only select the `ccno`
     * const costCenterWithCcnoOnly = await prisma.costCenter.findMany({ select: { ccno: true } })
     * 
     */
    findMany<T extends CostCenterFindManyArgs>(args?: SelectSubset<T, CostCenterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostCenter.
     * @param {CostCenterCreateArgs} args - Arguments to create a CostCenter.
     * @example
     * // Create one CostCenter
     * const CostCenter = await prisma.costCenter.create({
     *   data: {
     *     // ... data to create a CostCenter
     *   }
     * })
     * 
     */
    create<T extends CostCenterCreateArgs>(args: SelectSubset<T, CostCenterCreateArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostCenters.
     * @param {CostCenterCreateManyArgs} args - Arguments to create many CostCenters.
     * @example
     * // Create many CostCenters
     * const costCenter = await prisma.costCenter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostCenterCreateManyArgs>(args?: SelectSubset<T, CostCenterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostCenters and returns the data saved in the database.
     * @param {CostCenterCreateManyAndReturnArgs} args - Arguments to create many CostCenters.
     * @example
     * // Create many CostCenters
     * const costCenter = await prisma.costCenter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostCenters and only return the `ccno`
     * const costCenterWithCcnoOnly = await prisma.costCenter.createManyAndReturn({
     *   select: { ccno: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostCenterCreateManyAndReturnArgs>(args?: SelectSubset<T, CostCenterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostCenter.
     * @param {CostCenterDeleteArgs} args - Arguments to delete one CostCenter.
     * @example
     * // Delete one CostCenter
     * const CostCenter = await prisma.costCenter.delete({
     *   where: {
     *     // ... filter to delete one CostCenter
     *   }
     * })
     * 
     */
    delete<T extends CostCenterDeleteArgs>(args: SelectSubset<T, CostCenterDeleteArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostCenter.
     * @param {CostCenterUpdateArgs} args - Arguments to update one CostCenter.
     * @example
     * // Update one CostCenter
     * const costCenter = await prisma.costCenter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostCenterUpdateArgs>(args: SelectSubset<T, CostCenterUpdateArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostCenters.
     * @param {CostCenterDeleteManyArgs} args - Arguments to filter CostCenters to delete.
     * @example
     * // Delete a few CostCenters
     * const { count } = await prisma.costCenter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostCenterDeleteManyArgs>(args?: SelectSubset<T, CostCenterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostCenters
     * const costCenter = await prisma.costCenter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostCenterUpdateManyArgs>(args: SelectSubset<T, CostCenterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostCenters and returns the data updated in the database.
     * @param {CostCenterUpdateManyAndReturnArgs} args - Arguments to update many CostCenters.
     * @example
     * // Update many CostCenters
     * const costCenter = await prisma.costCenter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostCenters and only return the `ccno`
     * const costCenterWithCcnoOnly = await prisma.costCenter.updateManyAndReturn({
     *   select: { ccno: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostCenterUpdateManyAndReturnArgs>(args: SelectSubset<T, CostCenterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostCenter.
     * @param {CostCenterUpsertArgs} args - Arguments to update or create a CostCenter.
     * @example
     * // Update or create a CostCenter
     * const costCenter = await prisma.costCenter.upsert({
     *   create: {
     *     // ... data to create a CostCenter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostCenter we want to update
     *   }
     * })
     */
    upsert<T extends CostCenterUpsertArgs>(args: SelectSubset<T, CostCenterUpsertArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterCountArgs} args - Arguments to filter CostCenters to count.
     * @example
     * // Count the number of CostCenters
     * const count = await prisma.costCenter.count({
     *   where: {
     *     // ... the filter for the CostCenters we want to count
     *   }
     * })
    **/
    count<T extends CostCenterCountArgs>(
      args?: Subset<T, CostCenterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostCenterAggregateArgs>(args: Subset<T, CostCenterAggregateArgs>): Prisma.PrismaPromise<GetCostCenterAggregateType<T>>

    /**
     * Group by CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostCenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostCenterGroupByArgs['orderBy'] }
        : { orderBy?: CostCenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostCenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostCenterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostCenter model
   */
  readonly fields: CostCenterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostCenter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostCenterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Transaction<T extends CostCenter$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, CostCenter$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostCenter model
   */
  interface CostCenterFieldRefs {
    readonly ccno: FieldRef<"CostCenter", 'Int'>
    readonly company_id: FieldRef<"CostCenter", 'Int'>
    readonly ccname: FieldRef<"CostCenter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CostCenter findUnique
   */
  export type CostCenterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter findUniqueOrThrow
   */
  export type CostCenterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter findFirst
   */
  export type CostCenterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     */
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter findFirstOrThrow
   */
  export type CostCenterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     */
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter findMany
   */
  export type CostCenterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenters to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter create
   */
  export type CostCenterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * The data needed to create a CostCenter.
     */
    data: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
  }

  /**
   * CostCenter createMany
   */
  export type CostCenterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostCenters.
     */
    data: CostCenterCreateManyInput | CostCenterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostCenter createManyAndReturn
   */
  export type CostCenterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * The data used to create many CostCenters.
     */
    data: CostCenterCreateManyInput | CostCenterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostCenter update
   */
  export type CostCenterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * The data needed to update a CostCenter.
     */
    data: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
    /**
     * Choose, which CostCenter to update.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter updateMany
   */
  export type CostCenterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostCenters.
     */
    data: XOR<CostCenterUpdateManyMutationInput, CostCenterUncheckedUpdateManyInput>
    /**
     * Filter which CostCenters to update
     */
    where?: CostCenterWhereInput
    /**
     * Limit how many CostCenters to update.
     */
    limit?: number
  }

  /**
   * CostCenter updateManyAndReturn
   */
  export type CostCenterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * The data used to update CostCenters.
     */
    data: XOR<CostCenterUpdateManyMutationInput, CostCenterUncheckedUpdateManyInput>
    /**
     * Filter which CostCenters to update
     */
    where?: CostCenterWhereInput
    /**
     * Limit how many CostCenters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostCenter upsert
   */
  export type CostCenterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * The filter to search for the CostCenter to update in case it exists.
     */
    where: CostCenterWhereUniqueInput
    /**
     * In case the CostCenter found by the `where` argument doesn't exist, create a new CostCenter with this data.
     */
    create: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
    /**
     * In case the CostCenter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
  }

  /**
   * CostCenter delete
   */
  export type CostCenterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter which CostCenter to delete.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter deleteMany
   */
  export type CostCenterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCenters to delete
     */
    where?: CostCenterWhereInput
    /**
     * Limit how many CostCenters to delete.
     */
    limit?: number
  }

  /**
   * CostCenter.Transaction
   */
  export type CostCenter$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * CostCenter without action
   */
  export type CostCenterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    dept_name: string | null
    company_id: number | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    dept_name: string | null
    company_id: number | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    dept_name: number
    company_id: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    dept_name?: true
    company_id?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    dept_name?: true
    company_id?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    dept_name?: true
    company_id?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    dept_name: string | null
    company_id: number
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dept_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dept_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dept_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    dept_name?: boolean
    company_id?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dept_name" | "company_id", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dept_name: string | null
      company_id: number
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly dept_name: FieldRef<"Department", 'String'>
    readonly company_id: FieldRef<"Department", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model ProductMasterCategory
   */

  export type AggregateProductMasterCategory = {
    _count: ProductMasterCategoryCountAggregateOutputType | null
    _avg: ProductMasterCategoryAvgAggregateOutputType | null
    _sum: ProductMasterCategorySumAggregateOutputType | null
    _min: ProductMasterCategoryMinAggregateOutputType | null
    _max: ProductMasterCategoryMaxAggregateOutputType | null
  }

  export type ProductMasterCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductMasterCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ProductMasterCategoryMinAggregateOutputType = {
    id: number | null
    pmc_name: string | null
  }

  export type ProductMasterCategoryMaxAggregateOutputType = {
    id: number | null
    pmc_name: string | null
  }

  export type ProductMasterCategoryCountAggregateOutputType = {
    id: number
    pmc_name: number
    _all: number
  }


  export type ProductMasterCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ProductMasterCategorySumAggregateInputType = {
    id?: true
  }

  export type ProductMasterCategoryMinAggregateInputType = {
    id?: true
    pmc_name?: true
  }

  export type ProductMasterCategoryMaxAggregateInputType = {
    id?: true
    pmc_name?: true
  }

  export type ProductMasterCategoryCountAggregateInputType = {
    id?: true
    pmc_name?: true
    _all?: true
  }

  export type ProductMasterCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductMasterCategory to aggregate.
     */
    where?: ProductMasterCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMasterCategories to fetch.
     */
    orderBy?: ProductMasterCategoryOrderByWithRelationInput | ProductMasterCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductMasterCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMasterCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMasterCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductMasterCategories
    **/
    _count?: true | ProductMasterCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductMasterCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductMasterCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMasterCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMasterCategoryMaxAggregateInputType
  }

  export type GetProductMasterCategoryAggregateType<T extends ProductMasterCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductMasterCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductMasterCategory[P]>
      : GetScalarType<T[P], AggregateProductMasterCategory[P]>
  }




  export type ProductMasterCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductMasterCategoryWhereInput
    orderBy?: ProductMasterCategoryOrderByWithAggregationInput | ProductMasterCategoryOrderByWithAggregationInput[]
    by: ProductMasterCategoryScalarFieldEnum[] | ProductMasterCategoryScalarFieldEnum
    having?: ProductMasterCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductMasterCategoryCountAggregateInputType | true
    _avg?: ProductMasterCategoryAvgAggregateInputType
    _sum?: ProductMasterCategorySumAggregateInputType
    _min?: ProductMasterCategoryMinAggregateInputType
    _max?: ProductMasterCategoryMaxAggregateInputType
  }

  export type ProductMasterCategoryGroupByOutputType = {
    id: number
    pmc_name: string | null
    _count: ProductMasterCategoryCountAggregateOutputType | null
    _avg: ProductMasterCategoryAvgAggregateOutputType | null
    _sum: ProductMasterCategorySumAggregateOutputType | null
    _min: ProductMasterCategoryMinAggregateOutputType | null
    _max: ProductMasterCategoryMaxAggregateOutputType | null
  }

  type GetProductMasterCategoryGroupByPayload<T extends ProductMasterCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductMasterCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductMasterCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductMasterCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductMasterCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductMasterCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pmc_name?: boolean
    productGroups?: boolean | ProductMasterCategory$productGroupsArgs<ExtArgs>
    _count?: boolean | ProductMasterCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productMasterCategory"]>

  export type ProductMasterCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pmc_name?: boolean
  }, ExtArgs["result"]["productMasterCategory"]>

  export type ProductMasterCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pmc_name?: boolean
  }, ExtArgs["result"]["productMasterCategory"]>

  export type ProductMasterCategorySelectScalar = {
    id?: boolean
    pmc_name?: boolean
  }

  export type ProductMasterCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pmc_name", ExtArgs["result"]["productMasterCategory"]>
  export type ProductMasterCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productGroups?: boolean | ProductMasterCategory$productGroupsArgs<ExtArgs>
    _count?: boolean | ProductMasterCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductMasterCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductMasterCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductMasterCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductMasterCategory"
    objects: {
      productGroups: Prisma.$ProductGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pmc_name: string | null
    }, ExtArgs["result"]["productMasterCategory"]>
    composites: {}
  }

  type ProductMasterCategoryGetPayload<S extends boolean | null | undefined | ProductMasterCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductMasterCategoryPayload, S>

  type ProductMasterCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductMasterCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductMasterCategoryCountAggregateInputType | true
    }

  export interface ProductMasterCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductMasterCategory'], meta: { name: 'ProductMasterCategory' } }
    /**
     * Find zero or one ProductMasterCategory that matches the filter.
     * @param {ProductMasterCategoryFindUniqueArgs} args - Arguments to find a ProductMasterCategory
     * @example
     * // Get one ProductMasterCategory
     * const productMasterCategory = await prisma.productMasterCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductMasterCategoryFindUniqueArgs>(args: SelectSubset<T, ProductMasterCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductMasterCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductMasterCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductMasterCategory
     * @example
     * // Get one ProductMasterCategory
     * const productMasterCategory = await prisma.productMasterCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductMasterCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductMasterCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductMasterCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMasterCategoryFindFirstArgs} args - Arguments to find a ProductMasterCategory
     * @example
     * // Get one ProductMasterCategory
     * const productMasterCategory = await prisma.productMasterCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductMasterCategoryFindFirstArgs>(args?: SelectSubset<T, ProductMasterCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductMasterCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMasterCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductMasterCategory
     * @example
     * // Get one ProductMasterCategory
     * const productMasterCategory = await prisma.productMasterCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductMasterCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductMasterCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductMasterCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMasterCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductMasterCategories
     * const productMasterCategories = await prisma.productMasterCategory.findMany()
     * 
     * // Get first 10 ProductMasterCategories
     * const productMasterCategories = await prisma.productMasterCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productMasterCategoryWithIdOnly = await prisma.productMasterCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductMasterCategoryFindManyArgs>(args?: SelectSubset<T, ProductMasterCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductMasterCategory.
     * @param {ProductMasterCategoryCreateArgs} args - Arguments to create a ProductMasterCategory.
     * @example
     * // Create one ProductMasterCategory
     * const ProductMasterCategory = await prisma.productMasterCategory.create({
     *   data: {
     *     // ... data to create a ProductMasterCategory
     *   }
     * })
     * 
     */
    create<T extends ProductMasterCategoryCreateArgs>(args: SelectSubset<T, ProductMasterCategoryCreateArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductMasterCategories.
     * @param {ProductMasterCategoryCreateManyArgs} args - Arguments to create many ProductMasterCategories.
     * @example
     * // Create many ProductMasterCategories
     * const productMasterCategory = await prisma.productMasterCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductMasterCategoryCreateManyArgs>(args?: SelectSubset<T, ProductMasterCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductMasterCategories and returns the data saved in the database.
     * @param {ProductMasterCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductMasterCategories.
     * @example
     * // Create many ProductMasterCategories
     * const productMasterCategory = await prisma.productMasterCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductMasterCategories and only return the `id`
     * const productMasterCategoryWithIdOnly = await prisma.productMasterCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductMasterCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductMasterCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductMasterCategory.
     * @param {ProductMasterCategoryDeleteArgs} args - Arguments to delete one ProductMasterCategory.
     * @example
     * // Delete one ProductMasterCategory
     * const ProductMasterCategory = await prisma.productMasterCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductMasterCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductMasterCategoryDeleteArgs>(args: SelectSubset<T, ProductMasterCategoryDeleteArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductMasterCategory.
     * @param {ProductMasterCategoryUpdateArgs} args - Arguments to update one ProductMasterCategory.
     * @example
     * // Update one ProductMasterCategory
     * const productMasterCategory = await prisma.productMasterCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductMasterCategoryUpdateArgs>(args: SelectSubset<T, ProductMasterCategoryUpdateArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductMasterCategories.
     * @param {ProductMasterCategoryDeleteManyArgs} args - Arguments to filter ProductMasterCategories to delete.
     * @example
     * // Delete a few ProductMasterCategories
     * const { count } = await prisma.productMasterCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductMasterCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductMasterCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductMasterCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMasterCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductMasterCategories
     * const productMasterCategory = await prisma.productMasterCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductMasterCategoryUpdateManyArgs>(args: SelectSubset<T, ProductMasterCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductMasterCategories and returns the data updated in the database.
     * @param {ProductMasterCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductMasterCategories.
     * @example
     * // Update many ProductMasterCategories
     * const productMasterCategory = await prisma.productMasterCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductMasterCategories and only return the `id`
     * const productMasterCategoryWithIdOnly = await prisma.productMasterCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductMasterCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductMasterCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductMasterCategory.
     * @param {ProductMasterCategoryUpsertArgs} args - Arguments to update or create a ProductMasterCategory.
     * @example
     * // Update or create a ProductMasterCategory
     * const productMasterCategory = await prisma.productMasterCategory.upsert({
     *   create: {
     *     // ... data to create a ProductMasterCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductMasterCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductMasterCategoryUpsertArgs>(args: SelectSubset<T, ProductMasterCategoryUpsertArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductMasterCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMasterCategoryCountArgs} args - Arguments to filter ProductMasterCategories to count.
     * @example
     * // Count the number of ProductMasterCategories
     * const count = await prisma.productMasterCategory.count({
     *   where: {
     *     // ... the filter for the ProductMasterCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductMasterCategoryCountArgs>(
      args?: Subset<T, ProductMasterCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductMasterCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductMasterCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMasterCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductMasterCategoryAggregateArgs>(args: Subset<T, ProductMasterCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductMasterCategoryAggregateType<T>>

    /**
     * Group by ProductMasterCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMasterCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductMasterCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductMasterCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductMasterCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductMasterCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductMasterCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductMasterCategory model
   */
  readonly fields: ProductMasterCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductMasterCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductMasterCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productGroups<T extends ProductMasterCategory$productGroupsArgs<ExtArgs> = {}>(args?: Subset<T, ProductMasterCategory$productGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductMasterCategory model
   */
  interface ProductMasterCategoryFieldRefs {
    readonly id: FieldRef<"ProductMasterCategory", 'Int'>
    readonly pmc_name: FieldRef<"ProductMasterCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductMasterCategory findUnique
   */
  export type ProductMasterCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductMasterCategory to fetch.
     */
    where: ProductMasterCategoryWhereUniqueInput
  }

  /**
   * ProductMasterCategory findUniqueOrThrow
   */
  export type ProductMasterCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductMasterCategory to fetch.
     */
    where: ProductMasterCategoryWhereUniqueInput
  }

  /**
   * ProductMasterCategory findFirst
   */
  export type ProductMasterCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductMasterCategory to fetch.
     */
    where?: ProductMasterCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMasterCategories to fetch.
     */
    orderBy?: ProductMasterCategoryOrderByWithRelationInput | ProductMasterCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductMasterCategories.
     */
    cursor?: ProductMasterCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMasterCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMasterCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductMasterCategories.
     */
    distinct?: ProductMasterCategoryScalarFieldEnum | ProductMasterCategoryScalarFieldEnum[]
  }

  /**
   * ProductMasterCategory findFirstOrThrow
   */
  export type ProductMasterCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductMasterCategory to fetch.
     */
    where?: ProductMasterCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMasterCategories to fetch.
     */
    orderBy?: ProductMasterCategoryOrderByWithRelationInput | ProductMasterCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductMasterCategories.
     */
    cursor?: ProductMasterCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMasterCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMasterCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductMasterCategories.
     */
    distinct?: ProductMasterCategoryScalarFieldEnum | ProductMasterCategoryScalarFieldEnum[]
  }

  /**
   * ProductMasterCategory findMany
   */
  export type ProductMasterCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductMasterCategories to fetch.
     */
    where?: ProductMasterCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMasterCategories to fetch.
     */
    orderBy?: ProductMasterCategoryOrderByWithRelationInput | ProductMasterCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductMasterCategories.
     */
    cursor?: ProductMasterCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMasterCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMasterCategories.
     */
    skip?: number
    distinct?: ProductMasterCategoryScalarFieldEnum | ProductMasterCategoryScalarFieldEnum[]
  }

  /**
   * ProductMasterCategory create
   */
  export type ProductMasterCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductMasterCategory.
     */
    data?: XOR<ProductMasterCategoryCreateInput, ProductMasterCategoryUncheckedCreateInput>
  }

  /**
   * ProductMasterCategory createMany
   */
  export type ProductMasterCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductMasterCategories.
     */
    data: ProductMasterCategoryCreateManyInput | ProductMasterCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductMasterCategory createManyAndReturn
   */
  export type ProductMasterCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductMasterCategories.
     */
    data: ProductMasterCategoryCreateManyInput | ProductMasterCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductMasterCategory update
   */
  export type ProductMasterCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductMasterCategory.
     */
    data: XOR<ProductMasterCategoryUpdateInput, ProductMasterCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductMasterCategory to update.
     */
    where: ProductMasterCategoryWhereUniqueInput
  }

  /**
   * ProductMasterCategory updateMany
   */
  export type ProductMasterCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductMasterCategories.
     */
    data: XOR<ProductMasterCategoryUpdateManyMutationInput, ProductMasterCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductMasterCategories to update
     */
    where?: ProductMasterCategoryWhereInput
    /**
     * Limit how many ProductMasterCategories to update.
     */
    limit?: number
  }

  /**
   * ProductMasterCategory updateManyAndReturn
   */
  export type ProductMasterCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductMasterCategories.
     */
    data: XOR<ProductMasterCategoryUpdateManyMutationInput, ProductMasterCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductMasterCategories to update
     */
    where?: ProductMasterCategoryWhereInput
    /**
     * Limit how many ProductMasterCategories to update.
     */
    limit?: number
  }

  /**
   * ProductMasterCategory upsert
   */
  export type ProductMasterCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductMasterCategory to update in case it exists.
     */
    where: ProductMasterCategoryWhereUniqueInput
    /**
     * In case the ProductMasterCategory found by the `where` argument doesn't exist, create a new ProductMasterCategory with this data.
     */
    create: XOR<ProductMasterCategoryCreateInput, ProductMasterCategoryUncheckedCreateInput>
    /**
     * In case the ProductMasterCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductMasterCategoryUpdateInput, ProductMasterCategoryUncheckedUpdateInput>
  }

  /**
   * ProductMasterCategory delete
   */
  export type ProductMasterCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductMasterCategory to delete.
     */
    where: ProductMasterCategoryWhereUniqueInput
  }

  /**
   * ProductMasterCategory deleteMany
   */
  export type ProductMasterCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductMasterCategories to delete
     */
    where?: ProductMasterCategoryWhereInput
    /**
     * Limit how many ProductMasterCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductMasterCategory.productGroups
   */
  export type ProductMasterCategory$productGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    where?: ProductGroupWhereInput
    orderBy?: ProductGroupOrderByWithRelationInput | ProductGroupOrderByWithRelationInput[]
    cursor?: ProductGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductGroupScalarFieldEnum | ProductGroupScalarFieldEnum[]
  }

  /**
   * ProductMasterCategory without action
   */
  export type ProductMasterCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMasterCategory
     */
    select?: ProductMasterCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMasterCategory
     */
    omit?: ProductMasterCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMasterCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductGroup
   */

  export type AggregateProductGroup = {
    _count: ProductGroupCountAggregateOutputType | null
    _avg: ProductGroupAvgAggregateOutputType | null
    _sum: ProductGroupSumAggregateOutputType | null
    _min: ProductGroupMinAggregateOutputType | null
    _max: ProductGroupMaxAggregateOutputType | null
  }

  export type ProductGroupAvgAggregateOutputType = {
    id: number | null
    pmc_id: number | null
  }

  export type ProductGroupSumAggregateOutputType = {
    id: number | null
    pmc_id: number | null
  }

  export type ProductGroupMinAggregateOutputType = {
    id: number | null
    pg_name: string | null
    pmc_id: number | null
  }

  export type ProductGroupMaxAggregateOutputType = {
    id: number | null
    pg_name: string | null
    pmc_id: number | null
  }

  export type ProductGroupCountAggregateOutputType = {
    id: number
    pg_name: number
    pmc_id: number
    _all: number
  }


  export type ProductGroupAvgAggregateInputType = {
    id?: true
    pmc_id?: true
  }

  export type ProductGroupSumAggregateInputType = {
    id?: true
    pmc_id?: true
  }

  export type ProductGroupMinAggregateInputType = {
    id?: true
    pg_name?: true
    pmc_id?: true
  }

  export type ProductGroupMaxAggregateInputType = {
    id?: true
    pg_name?: true
    pmc_id?: true
  }

  export type ProductGroupCountAggregateInputType = {
    id?: true
    pg_name?: true
    pmc_id?: true
    _all?: true
  }

  export type ProductGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductGroup to aggregate.
     */
    where?: ProductGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGroups to fetch.
     */
    orderBy?: ProductGroupOrderByWithRelationInput | ProductGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductGroups
    **/
    _count?: true | ProductGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductGroupMaxAggregateInputType
  }

  export type GetProductGroupAggregateType<T extends ProductGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateProductGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductGroup[P]>
      : GetScalarType<T[P], AggregateProductGroup[P]>
  }




  export type ProductGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductGroupWhereInput
    orderBy?: ProductGroupOrderByWithAggregationInput | ProductGroupOrderByWithAggregationInput[]
    by: ProductGroupScalarFieldEnum[] | ProductGroupScalarFieldEnum
    having?: ProductGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductGroupCountAggregateInputType | true
    _avg?: ProductGroupAvgAggregateInputType
    _sum?: ProductGroupSumAggregateInputType
    _min?: ProductGroupMinAggregateInputType
    _max?: ProductGroupMaxAggregateInputType
  }

  export type ProductGroupGroupByOutputType = {
    id: number
    pg_name: string | null
    pmc_id: number
    _count: ProductGroupCountAggregateOutputType | null
    _avg: ProductGroupAvgAggregateOutputType | null
    _sum: ProductGroupSumAggregateOutputType | null
    _min: ProductGroupMinAggregateOutputType | null
    _max: ProductGroupMaxAggregateOutputType | null
  }

  type GetProductGroupGroupByPayload<T extends ProductGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupGroupByOutputType[P]>
        }
      >
    >


  export type ProductGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pg_name?: boolean
    pmc_id?: boolean
    productCategories?: boolean | ProductGroup$productCategoriesArgs<ExtArgs>
    ProductMasterCategories?: boolean | ProductMasterCategoryDefaultArgs<ExtArgs>
    _count?: boolean | ProductGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGroup"]>

  export type ProductGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pg_name?: boolean
    pmc_id?: boolean
    ProductMasterCategories?: boolean | ProductMasterCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGroup"]>

  export type ProductGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pg_name?: boolean
    pmc_id?: boolean
    ProductMasterCategories?: boolean | ProductMasterCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGroup"]>

  export type ProductGroupSelectScalar = {
    id?: boolean
    pg_name?: boolean
    pmc_id?: boolean
  }

  export type ProductGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pg_name" | "pmc_id", ExtArgs["result"]["productGroup"]>
  export type ProductGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productCategories?: boolean | ProductGroup$productCategoriesArgs<ExtArgs>
    ProductMasterCategories?: boolean | ProductMasterCategoryDefaultArgs<ExtArgs>
    _count?: boolean | ProductGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductMasterCategories?: boolean | ProductMasterCategoryDefaultArgs<ExtArgs>
  }
  export type ProductGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductMasterCategories?: boolean | ProductMasterCategoryDefaultArgs<ExtArgs>
  }

  export type $ProductGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductGroup"
    objects: {
      productCategories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      ProductMasterCategories: Prisma.$ProductMasterCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pg_name: string | null
      pmc_id: number
    }, ExtArgs["result"]["productGroup"]>
    composites: {}
  }

  type ProductGroupGetPayload<S extends boolean | null | undefined | ProductGroupDefaultArgs> = $Result.GetResult<Prisma.$ProductGroupPayload, S>

  type ProductGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductGroupCountAggregateInputType | true
    }

  export interface ProductGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductGroup'], meta: { name: 'ProductGroup' } }
    /**
     * Find zero or one ProductGroup that matches the filter.
     * @param {ProductGroupFindUniqueArgs} args - Arguments to find a ProductGroup
     * @example
     * // Get one ProductGroup
     * const productGroup = await prisma.productGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductGroupFindUniqueArgs>(args: SelectSubset<T, ProductGroupFindUniqueArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductGroupFindUniqueOrThrowArgs} args - Arguments to find a ProductGroup
     * @example
     * // Get one ProductGroup
     * const productGroup = await prisma.productGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupFindFirstArgs} args - Arguments to find a ProductGroup
     * @example
     * // Get one ProductGroup
     * const productGroup = await prisma.productGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductGroupFindFirstArgs>(args?: SelectSubset<T, ProductGroupFindFirstArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupFindFirstOrThrowArgs} args - Arguments to find a ProductGroup
     * @example
     * // Get one ProductGroup
     * const productGroup = await prisma.productGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductGroups
     * const productGroups = await prisma.productGroup.findMany()
     * 
     * // Get first 10 ProductGroups
     * const productGroups = await prisma.productGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productGroupWithIdOnly = await prisma.productGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductGroupFindManyArgs>(args?: SelectSubset<T, ProductGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductGroup.
     * @param {ProductGroupCreateArgs} args - Arguments to create a ProductGroup.
     * @example
     * // Create one ProductGroup
     * const ProductGroup = await prisma.productGroup.create({
     *   data: {
     *     // ... data to create a ProductGroup
     *   }
     * })
     * 
     */
    create<T extends ProductGroupCreateArgs>(args: SelectSubset<T, ProductGroupCreateArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductGroups.
     * @param {ProductGroupCreateManyArgs} args - Arguments to create many ProductGroups.
     * @example
     * // Create many ProductGroups
     * const productGroup = await prisma.productGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductGroupCreateManyArgs>(args?: SelectSubset<T, ProductGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductGroups and returns the data saved in the database.
     * @param {ProductGroupCreateManyAndReturnArgs} args - Arguments to create many ProductGroups.
     * @example
     * // Create many ProductGroups
     * const productGroup = await prisma.productGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductGroups and only return the `id`
     * const productGroupWithIdOnly = await prisma.productGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductGroup.
     * @param {ProductGroupDeleteArgs} args - Arguments to delete one ProductGroup.
     * @example
     * // Delete one ProductGroup
     * const ProductGroup = await prisma.productGroup.delete({
     *   where: {
     *     // ... filter to delete one ProductGroup
     *   }
     * })
     * 
     */
    delete<T extends ProductGroupDeleteArgs>(args: SelectSubset<T, ProductGroupDeleteArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductGroup.
     * @param {ProductGroupUpdateArgs} args - Arguments to update one ProductGroup.
     * @example
     * // Update one ProductGroup
     * const productGroup = await prisma.productGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductGroupUpdateArgs>(args: SelectSubset<T, ProductGroupUpdateArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductGroups.
     * @param {ProductGroupDeleteManyArgs} args - Arguments to filter ProductGroups to delete.
     * @example
     * // Delete a few ProductGroups
     * const { count } = await prisma.productGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductGroupDeleteManyArgs>(args?: SelectSubset<T, ProductGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductGroups
     * const productGroup = await prisma.productGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductGroupUpdateManyArgs>(args: SelectSubset<T, ProductGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductGroups and returns the data updated in the database.
     * @param {ProductGroupUpdateManyAndReturnArgs} args - Arguments to update many ProductGroups.
     * @example
     * // Update many ProductGroups
     * const productGroup = await prisma.productGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductGroups and only return the `id`
     * const productGroupWithIdOnly = await prisma.productGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductGroup.
     * @param {ProductGroupUpsertArgs} args - Arguments to update or create a ProductGroup.
     * @example
     * // Update or create a ProductGroup
     * const productGroup = await prisma.productGroup.upsert({
     *   create: {
     *     // ... data to create a ProductGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductGroup we want to update
     *   }
     * })
     */
    upsert<T extends ProductGroupUpsertArgs>(args: SelectSubset<T, ProductGroupUpsertArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupCountArgs} args - Arguments to filter ProductGroups to count.
     * @example
     * // Count the number of ProductGroups
     * const count = await prisma.productGroup.count({
     *   where: {
     *     // ... the filter for the ProductGroups we want to count
     *   }
     * })
    **/
    count<T extends ProductGroupCountArgs>(
      args?: Subset<T, ProductGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductGroupAggregateArgs>(args: Subset<T, ProductGroupAggregateArgs>): Prisma.PrismaPromise<GetProductGroupAggregateType<T>>

    /**
     * Group by ProductGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductGroup model
   */
  readonly fields: ProductGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productCategories<T extends ProductGroup$productCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, ProductGroup$productCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductMasterCategories<T extends ProductMasterCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductMasterCategoryDefaultArgs<ExtArgs>>): Prisma__ProductMasterCategoryClient<$Result.GetResult<Prisma.$ProductMasterCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductGroup model
   */
  interface ProductGroupFieldRefs {
    readonly id: FieldRef<"ProductGroup", 'Int'>
    readonly pg_name: FieldRef<"ProductGroup", 'String'>
    readonly pmc_id: FieldRef<"ProductGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductGroup findUnique
   */
  export type ProductGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProductGroup to fetch.
     */
    where: ProductGroupWhereUniqueInput
  }

  /**
   * ProductGroup findUniqueOrThrow
   */
  export type ProductGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProductGroup to fetch.
     */
    where: ProductGroupWhereUniqueInput
  }

  /**
   * ProductGroup findFirst
   */
  export type ProductGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProductGroup to fetch.
     */
    where?: ProductGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGroups to fetch.
     */
    orderBy?: ProductGroupOrderByWithRelationInput | ProductGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductGroups.
     */
    cursor?: ProductGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductGroups.
     */
    distinct?: ProductGroupScalarFieldEnum | ProductGroupScalarFieldEnum[]
  }

  /**
   * ProductGroup findFirstOrThrow
   */
  export type ProductGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProductGroup to fetch.
     */
    where?: ProductGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGroups to fetch.
     */
    orderBy?: ProductGroupOrderByWithRelationInput | ProductGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductGroups.
     */
    cursor?: ProductGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductGroups.
     */
    distinct?: ProductGroupScalarFieldEnum | ProductGroupScalarFieldEnum[]
  }

  /**
   * ProductGroup findMany
   */
  export type ProductGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProductGroups to fetch.
     */
    where?: ProductGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGroups to fetch.
     */
    orderBy?: ProductGroupOrderByWithRelationInput | ProductGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductGroups.
     */
    cursor?: ProductGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGroups.
     */
    skip?: number
    distinct?: ProductGroupScalarFieldEnum | ProductGroupScalarFieldEnum[]
  }

  /**
   * ProductGroup create
   */
  export type ProductGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductGroup.
     */
    data: XOR<ProductGroupCreateInput, ProductGroupUncheckedCreateInput>
  }

  /**
   * ProductGroup createMany
   */
  export type ProductGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductGroups.
     */
    data: ProductGroupCreateManyInput | ProductGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductGroup createManyAndReturn
   */
  export type ProductGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * The data used to create many ProductGroups.
     */
    data: ProductGroupCreateManyInput | ProductGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductGroup update
   */
  export type ProductGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductGroup.
     */
    data: XOR<ProductGroupUpdateInput, ProductGroupUncheckedUpdateInput>
    /**
     * Choose, which ProductGroup to update.
     */
    where: ProductGroupWhereUniqueInput
  }

  /**
   * ProductGroup updateMany
   */
  export type ProductGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductGroups.
     */
    data: XOR<ProductGroupUpdateManyMutationInput, ProductGroupUncheckedUpdateManyInput>
    /**
     * Filter which ProductGroups to update
     */
    where?: ProductGroupWhereInput
    /**
     * Limit how many ProductGroups to update.
     */
    limit?: number
  }

  /**
   * ProductGroup updateManyAndReturn
   */
  export type ProductGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * The data used to update ProductGroups.
     */
    data: XOR<ProductGroupUpdateManyMutationInput, ProductGroupUncheckedUpdateManyInput>
    /**
     * Filter which ProductGroups to update
     */
    where?: ProductGroupWhereInput
    /**
     * Limit how many ProductGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductGroup upsert
   */
  export type ProductGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductGroup to update in case it exists.
     */
    where: ProductGroupWhereUniqueInput
    /**
     * In case the ProductGroup found by the `where` argument doesn't exist, create a new ProductGroup with this data.
     */
    create: XOR<ProductGroupCreateInput, ProductGroupUncheckedCreateInput>
    /**
     * In case the ProductGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductGroupUpdateInput, ProductGroupUncheckedUpdateInput>
  }

  /**
   * ProductGroup delete
   */
  export type ProductGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
    /**
     * Filter which ProductGroup to delete.
     */
    where: ProductGroupWhereUniqueInput
  }

  /**
   * ProductGroup deleteMany
   */
  export type ProductGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductGroups to delete
     */
    where?: ProductGroupWhereInput
    /**
     * Limit how many ProductGroups to delete.
     */
    limit?: number
  }

  /**
   * ProductGroup.productCategories
   */
  export type ProductGroup$productCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductGroup without action
   */
  export type ProductGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGroup
     */
    select?: ProductGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGroup
     */
    omit?: ProductGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGroupInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
    pg_id: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
    pg_id: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    pc_name: string | null
    pg_id: number | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    pc_name: string | null
    pg_id: number | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    pc_name: number
    pg_id: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
    pg_id?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
    pg_id?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    pc_name?: true
    pg_id?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    pc_name?: true
    pg_id?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    pc_name?: true
    pg_id?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: number
    pc_name: string | null
    pg_id: number
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pc_name?: boolean
    pg_id?: boolean
    mainCategories?: boolean | ProductCategory$mainCategoriesArgs<ExtArgs>
    ProductGroups?: boolean | ProductGroupDefaultArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pc_name?: boolean
    pg_id?: boolean
    ProductGroups?: boolean | ProductGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pc_name?: boolean
    pg_id?: boolean
    ProductGroups?: boolean | ProductGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    pc_name?: boolean
    pg_id?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pc_name" | "pg_id", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainCategories?: boolean | ProductCategory$mainCategoriesArgs<ExtArgs>
    ProductGroups?: boolean | ProductGroupDefaultArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductGroups?: boolean | ProductGroupDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductGroups?: boolean | ProductGroupDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      mainCategories: Prisma.$MainCategoryPayload<ExtArgs>[]
      ProductGroups: Prisma.$ProductGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pc_name: string | null
      pg_id: number
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainCategories<T extends ProductCategory$mainCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$mainCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductGroups<T extends ProductGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductGroupDefaultArgs<ExtArgs>>): Prisma__ProductGroupClient<$Result.GetResult<Prisma.$ProductGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'Int'>
    readonly pc_name: FieldRef<"ProductCategory", 'String'>
    readonly pg_id: FieldRef<"ProductCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.mainCategories
   */
  export type ProductCategory$mainCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    where?: MainCategoryWhereInput
    orderBy?: MainCategoryOrderByWithRelationInput | MainCategoryOrderByWithRelationInput[]
    cursor?: MainCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MainCategoryScalarFieldEnum | MainCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model MainCategory
   */

  export type AggregateMainCategory = {
    _count: MainCategoryCountAggregateOutputType | null
    _avg: MainCategoryAvgAggregateOutputType | null
    _sum: MainCategorySumAggregateOutputType | null
    _min: MainCategoryMinAggregateOutputType | null
    _max: MainCategoryMaxAggregateOutputType | null
  }

  export type MainCategoryAvgAggregateOutputType = {
    id: number | null
    pc_id: number | null
  }

  export type MainCategorySumAggregateOutputType = {
    id: number | null
    pc_id: number | null
  }

  export type MainCategoryMinAggregateOutputType = {
    id: number | null
    mc_name: string | null
    pc_id: number | null
  }

  export type MainCategoryMaxAggregateOutputType = {
    id: number | null
    mc_name: string | null
    pc_id: number | null
  }

  export type MainCategoryCountAggregateOutputType = {
    id: number
    mc_name: number
    pc_id: number
    _all: number
  }


  export type MainCategoryAvgAggregateInputType = {
    id?: true
    pc_id?: true
  }

  export type MainCategorySumAggregateInputType = {
    id?: true
    pc_id?: true
  }

  export type MainCategoryMinAggregateInputType = {
    id?: true
    mc_name?: true
    pc_id?: true
  }

  export type MainCategoryMaxAggregateInputType = {
    id?: true
    mc_name?: true
    pc_id?: true
  }

  export type MainCategoryCountAggregateInputType = {
    id?: true
    mc_name?: true
    pc_id?: true
    _all?: true
  }

  export type MainCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MainCategory to aggregate.
     */
    where?: MainCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainCategories to fetch.
     */
    orderBy?: MainCategoryOrderByWithRelationInput | MainCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MainCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MainCategories
    **/
    _count?: true | MainCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MainCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MainCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MainCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MainCategoryMaxAggregateInputType
  }

  export type GetMainCategoryAggregateType<T extends MainCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMainCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMainCategory[P]>
      : GetScalarType<T[P], AggregateMainCategory[P]>
  }




  export type MainCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainCategoryWhereInput
    orderBy?: MainCategoryOrderByWithAggregationInput | MainCategoryOrderByWithAggregationInput[]
    by: MainCategoryScalarFieldEnum[] | MainCategoryScalarFieldEnum
    having?: MainCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MainCategoryCountAggregateInputType | true
    _avg?: MainCategoryAvgAggregateInputType
    _sum?: MainCategorySumAggregateInputType
    _min?: MainCategoryMinAggregateInputType
    _max?: MainCategoryMaxAggregateInputType
  }

  export type MainCategoryGroupByOutputType = {
    id: number
    mc_name: string | null
    pc_id: number
    _count: MainCategoryCountAggregateOutputType | null
    _avg: MainCategoryAvgAggregateOutputType | null
    _sum: MainCategorySumAggregateOutputType | null
    _min: MainCategoryMinAggregateOutputType | null
    _max: MainCategoryMaxAggregateOutputType | null
  }

  type GetMainCategoryGroupByPayload<T extends MainCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MainCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MainCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MainCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], MainCategoryGroupByOutputType[P]>
        }
      >
    >


  export type MainCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mc_name?: boolean
    pc_id?: boolean
    itemCategories?: boolean | MainCategory$itemCategoriesArgs<ExtArgs>
    ProductCategories?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    _count?: boolean | MainCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mainCategory"]>

  export type MainCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mc_name?: boolean
    pc_id?: boolean
    ProductCategories?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mainCategory"]>

  export type MainCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mc_name?: boolean
    pc_id?: boolean
    ProductCategories?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mainCategory"]>

  export type MainCategorySelectScalar = {
    id?: boolean
    mc_name?: boolean
    pc_id?: boolean
  }

  export type MainCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mc_name" | "pc_id", ExtArgs["result"]["mainCategory"]>
  export type MainCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemCategories?: boolean | MainCategory$itemCategoriesArgs<ExtArgs>
    ProductCategories?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    _count?: boolean | MainCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MainCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategories?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }
  export type MainCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategories?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }

  export type $MainCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MainCategory"
    objects: {
      itemCategories: Prisma.$ItemCategoryPayload<ExtArgs>[]
      ProductCategories: Prisma.$ProductCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mc_name: string | null
      pc_id: number
    }, ExtArgs["result"]["mainCategory"]>
    composites: {}
  }

  type MainCategoryGetPayload<S extends boolean | null | undefined | MainCategoryDefaultArgs> = $Result.GetResult<Prisma.$MainCategoryPayload, S>

  type MainCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MainCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MainCategoryCountAggregateInputType | true
    }

  export interface MainCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MainCategory'], meta: { name: 'MainCategory' } }
    /**
     * Find zero or one MainCategory that matches the filter.
     * @param {MainCategoryFindUniqueArgs} args - Arguments to find a MainCategory
     * @example
     * // Get one MainCategory
     * const mainCategory = await prisma.mainCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MainCategoryFindUniqueArgs>(args: SelectSubset<T, MainCategoryFindUniqueArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MainCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MainCategoryFindUniqueOrThrowArgs} args - Arguments to find a MainCategory
     * @example
     * // Get one MainCategory
     * const mainCategory = await prisma.mainCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MainCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MainCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MainCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCategoryFindFirstArgs} args - Arguments to find a MainCategory
     * @example
     * // Get one MainCategory
     * const mainCategory = await prisma.mainCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MainCategoryFindFirstArgs>(args?: SelectSubset<T, MainCategoryFindFirstArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MainCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCategoryFindFirstOrThrowArgs} args - Arguments to find a MainCategory
     * @example
     * // Get one MainCategory
     * const mainCategory = await prisma.mainCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MainCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MainCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MainCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MainCategories
     * const mainCategories = await prisma.mainCategory.findMany()
     * 
     * // Get first 10 MainCategories
     * const mainCategories = await prisma.mainCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mainCategoryWithIdOnly = await prisma.mainCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MainCategoryFindManyArgs>(args?: SelectSubset<T, MainCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MainCategory.
     * @param {MainCategoryCreateArgs} args - Arguments to create a MainCategory.
     * @example
     * // Create one MainCategory
     * const MainCategory = await prisma.mainCategory.create({
     *   data: {
     *     // ... data to create a MainCategory
     *   }
     * })
     * 
     */
    create<T extends MainCategoryCreateArgs>(args: SelectSubset<T, MainCategoryCreateArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MainCategories.
     * @param {MainCategoryCreateManyArgs} args - Arguments to create many MainCategories.
     * @example
     * // Create many MainCategories
     * const mainCategory = await prisma.mainCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MainCategoryCreateManyArgs>(args?: SelectSubset<T, MainCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MainCategories and returns the data saved in the database.
     * @param {MainCategoryCreateManyAndReturnArgs} args - Arguments to create many MainCategories.
     * @example
     * // Create many MainCategories
     * const mainCategory = await prisma.mainCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MainCategories and only return the `id`
     * const mainCategoryWithIdOnly = await prisma.mainCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MainCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, MainCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MainCategory.
     * @param {MainCategoryDeleteArgs} args - Arguments to delete one MainCategory.
     * @example
     * // Delete one MainCategory
     * const MainCategory = await prisma.mainCategory.delete({
     *   where: {
     *     // ... filter to delete one MainCategory
     *   }
     * })
     * 
     */
    delete<T extends MainCategoryDeleteArgs>(args: SelectSubset<T, MainCategoryDeleteArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MainCategory.
     * @param {MainCategoryUpdateArgs} args - Arguments to update one MainCategory.
     * @example
     * // Update one MainCategory
     * const mainCategory = await prisma.mainCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MainCategoryUpdateArgs>(args: SelectSubset<T, MainCategoryUpdateArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MainCategories.
     * @param {MainCategoryDeleteManyArgs} args - Arguments to filter MainCategories to delete.
     * @example
     * // Delete a few MainCategories
     * const { count } = await prisma.mainCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MainCategoryDeleteManyArgs>(args?: SelectSubset<T, MainCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MainCategories
     * const mainCategory = await prisma.mainCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MainCategoryUpdateManyArgs>(args: SelectSubset<T, MainCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainCategories and returns the data updated in the database.
     * @param {MainCategoryUpdateManyAndReturnArgs} args - Arguments to update many MainCategories.
     * @example
     * // Update many MainCategories
     * const mainCategory = await prisma.mainCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MainCategories and only return the `id`
     * const mainCategoryWithIdOnly = await prisma.mainCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MainCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, MainCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MainCategory.
     * @param {MainCategoryUpsertArgs} args - Arguments to update or create a MainCategory.
     * @example
     * // Update or create a MainCategory
     * const mainCategory = await prisma.mainCategory.upsert({
     *   create: {
     *     // ... data to create a MainCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MainCategory we want to update
     *   }
     * })
     */
    upsert<T extends MainCategoryUpsertArgs>(args: SelectSubset<T, MainCategoryUpsertArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MainCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCategoryCountArgs} args - Arguments to filter MainCategories to count.
     * @example
     * // Count the number of MainCategories
     * const count = await prisma.mainCategory.count({
     *   where: {
     *     // ... the filter for the MainCategories we want to count
     *   }
     * })
    **/
    count<T extends MainCategoryCountArgs>(
      args?: Subset<T, MainCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MainCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MainCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MainCategoryAggregateArgs>(args: Subset<T, MainCategoryAggregateArgs>): Prisma.PrismaPromise<GetMainCategoryAggregateType<T>>

    /**
     * Group by MainCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MainCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MainCategoryGroupByArgs['orderBy'] }
        : { orderBy?: MainCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MainCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMainCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MainCategory model
   */
  readonly fields: MainCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MainCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MainCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemCategories<T extends MainCategory$itemCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, MainCategory$itemCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductCategories<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MainCategory model
   */
  interface MainCategoryFieldRefs {
    readonly id: FieldRef<"MainCategory", 'Int'>
    readonly mc_name: FieldRef<"MainCategory", 'String'>
    readonly pc_id: FieldRef<"MainCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MainCategory findUnique
   */
  export type MainCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MainCategory to fetch.
     */
    where: MainCategoryWhereUniqueInput
  }

  /**
   * MainCategory findUniqueOrThrow
   */
  export type MainCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MainCategory to fetch.
     */
    where: MainCategoryWhereUniqueInput
  }

  /**
   * MainCategory findFirst
   */
  export type MainCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MainCategory to fetch.
     */
    where?: MainCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainCategories to fetch.
     */
    orderBy?: MainCategoryOrderByWithRelationInput | MainCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainCategories.
     */
    cursor?: MainCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainCategories.
     */
    distinct?: MainCategoryScalarFieldEnum | MainCategoryScalarFieldEnum[]
  }

  /**
   * MainCategory findFirstOrThrow
   */
  export type MainCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MainCategory to fetch.
     */
    where?: MainCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainCategories to fetch.
     */
    orderBy?: MainCategoryOrderByWithRelationInput | MainCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainCategories.
     */
    cursor?: MainCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainCategories.
     */
    distinct?: MainCategoryScalarFieldEnum | MainCategoryScalarFieldEnum[]
  }

  /**
   * MainCategory findMany
   */
  export type MainCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MainCategories to fetch.
     */
    where?: MainCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainCategories to fetch.
     */
    orderBy?: MainCategoryOrderByWithRelationInput | MainCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MainCategories.
     */
    cursor?: MainCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainCategories.
     */
    skip?: number
    distinct?: MainCategoryScalarFieldEnum | MainCategoryScalarFieldEnum[]
  }

  /**
   * MainCategory create
   */
  export type MainCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a MainCategory.
     */
    data: XOR<MainCategoryCreateInput, MainCategoryUncheckedCreateInput>
  }

  /**
   * MainCategory createMany
   */
  export type MainCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MainCategories.
     */
    data: MainCategoryCreateManyInput | MainCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MainCategory createManyAndReturn
   */
  export type MainCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many MainCategories.
     */
    data: MainCategoryCreateManyInput | MainCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MainCategory update
   */
  export type MainCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a MainCategory.
     */
    data: XOR<MainCategoryUpdateInput, MainCategoryUncheckedUpdateInput>
    /**
     * Choose, which MainCategory to update.
     */
    where: MainCategoryWhereUniqueInput
  }

  /**
   * MainCategory updateMany
   */
  export type MainCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MainCategories.
     */
    data: XOR<MainCategoryUpdateManyMutationInput, MainCategoryUncheckedUpdateManyInput>
    /**
     * Filter which MainCategories to update
     */
    where?: MainCategoryWhereInput
    /**
     * Limit how many MainCategories to update.
     */
    limit?: number
  }

  /**
   * MainCategory updateManyAndReturn
   */
  export type MainCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * The data used to update MainCategories.
     */
    data: XOR<MainCategoryUpdateManyMutationInput, MainCategoryUncheckedUpdateManyInput>
    /**
     * Filter which MainCategories to update
     */
    where?: MainCategoryWhereInput
    /**
     * Limit how many MainCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MainCategory upsert
   */
  export type MainCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the MainCategory to update in case it exists.
     */
    where: MainCategoryWhereUniqueInput
    /**
     * In case the MainCategory found by the `where` argument doesn't exist, create a new MainCategory with this data.
     */
    create: XOR<MainCategoryCreateInput, MainCategoryUncheckedCreateInput>
    /**
     * In case the MainCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MainCategoryUpdateInput, MainCategoryUncheckedUpdateInput>
  }

  /**
   * MainCategory delete
   */
  export type MainCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
    /**
     * Filter which MainCategory to delete.
     */
    where: MainCategoryWhereUniqueInput
  }

  /**
   * MainCategory deleteMany
   */
  export type MainCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MainCategories to delete
     */
    where?: MainCategoryWhereInput
    /**
     * Limit how many MainCategories to delete.
     */
    limit?: number
  }

  /**
   * MainCategory.itemCategories
   */
  export type MainCategory$itemCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    cursor?: ItemCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * MainCategory without action
   */
  export type MainCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainCategory
     */
    select?: MainCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainCategory
     */
    omit?: MainCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ItemCategory
   */

  export type AggregateItemCategory = {
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  export type ItemCategoryAvgAggregateOutputType = {
    id: number | null
    mc_id: number | null
    wc_category_id: number | null
  }

  export type ItemCategorySumAggregateOutputType = {
    id: number | null
    mc_id: number | null
    wc_category_id: number | null
  }

  export type ItemCategoryMinAggregateOutputType = {
    id: number | null
    ic_name: string | null
    mc_id: number | null
    wc_category_id: number | null
    sync_status: string | null
    last_sync: Date | null
  }

  export type ItemCategoryMaxAggregateOutputType = {
    id: number | null
    ic_name: string | null
    mc_id: number | null
    wc_category_id: number | null
    sync_status: string | null
    last_sync: Date | null
  }

  export type ItemCategoryCountAggregateOutputType = {
    id: number
    ic_name: number
    mc_id: number
    wc_category_id: number
    sync_status: number
    last_sync: number
    _all: number
  }


  export type ItemCategoryAvgAggregateInputType = {
    id?: true
    mc_id?: true
    wc_category_id?: true
  }

  export type ItemCategorySumAggregateInputType = {
    id?: true
    mc_id?: true
    wc_category_id?: true
  }

  export type ItemCategoryMinAggregateInputType = {
    id?: true
    ic_name?: true
    mc_id?: true
    wc_category_id?: true
    sync_status?: true
    last_sync?: true
  }

  export type ItemCategoryMaxAggregateInputType = {
    id?: true
    ic_name?: true
    mc_id?: true
    wc_category_id?: true
    sync_status?: true
    last_sync?: true
  }

  export type ItemCategoryCountAggregateInputType = {
    id?: true
    ic_name?: true
    mc_id?: true
    wc_category_id?: true
    sync_status?: true
    last_sync?: true
    _all?: true
  }

  export type ItemCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategory to aggregate.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategories
    **/
    _count?: true | ItemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type GetItemCategoryAggregateType<T extends ItemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategory[P]>
      : GetScalarType<T[P], AggregateItemCategory[P]>
  }




  export type ItemCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithAggregationInput | ItemCategoryOrderByWithAggregationInput[]
    by: ItemCategoryScalarFieldEnum[] | ItemCategoryScalarFieldEnum
    having?: ItemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryCountAggregateInputType | true
    _avg?: ItemCategoryAvgAggregateInputType
    _sum?: ItemCategorySumAggregateInputType
    _min?: ItemCategoryMinAggregateInputType
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type ItemCategoryGroupByOutputType = {
    id: number
    ic_name: string
    mc_id: number
    wc_category_id: number | null
    sync_status: string | null
    last_sync: Date | null
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  type GetItemCategoryGroupByPayload<T extends ItemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ic_name?: boolean
    mc_id?: boolean
    wc_category_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    mainCategory?: boolean | MainCategoryDefaultArgs<ExtArgs>
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ic_name?: boolean
    mc_id?: boolean
    wc_category_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    mainCategory?: boolean | MainCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ic_name?: boolean
    mc_id?: boolean
    wc_category_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    mainCategory?: boolean | MainCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectScalar = {
    id?: boolean
    ic_name?: boolean
    mc_id?: boolean
    wc_category_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
  }

  export type ItemCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ic_name" | "mc_id" | "wc_category_id" | "sync_status" | "last_sync", ExtArgs["result"]["itemCategory"]>
  export type ItemCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainCategory?: boolean | MainCategoryDefaultArgs<ExtArgs>
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainCategory?: boolean | MainCategoryDefaultArgs<ExtArgs>
  }
  export type ItemCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainCategory?: boolean | MainCategoryDefaultArgs<ExtArgs>
  }

  export type $ItemCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategory"
    objects: {
      mainCategory: Prisma.$MainCategoryPayload<ExtArgs>
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ic_name: string
      mc_id: number
      wc_category_id: number | null
      sync_status: string | null
      last_sync: Date | null
    }, ExtArgs["result"]["itemCategory"]>
    composites: {}
  }

  type ItemCategoryGetPayload<S extends boolean | null | undefined | ItemCategoryDefaultArgs> = $Result.GetResult<Prisma.$ItemCategoryPayload, S>

  type ItemCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCategoryCountAggregateInputType | true
    }

  export interface ItemCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategory'], meta: { name: 'ItemCategory' } }
    /**
     * Find zero or one ItemCategory that matches the filter.
     * @param {ItemCategoryFindUniqueArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategoryFindUniqueArgs>(args: SelectSubset<T, ItemCategoryFindUniqueArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategoryFindFirstArgs>(args?: SelectSubset<T, ItemCategoryFindFirstArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany()
     * 
     * // Get first 10 ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemCategoryFindManyArgs>(args?: SelectSubset<T, ItemCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemCategory.
     * @param {ItemCategoryCreateArgs} args - Arguments to create a ItemCategory.
     * @example
     * // Create one ItemCategory
     * const ItemCategory = await prisma.itemCategory.create({
     *   data: {
     *     // ... data to create a ItemCategory
     *   }
     * })
     * 
     */
    create<T extends ItemCategoryCreateArgs>(args: SelectSubset<T, ItemCategoryCreateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemCategories.
     * @param {ItemCategoryCreateManyArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategoryCreateManyArgs>(args?: SelectSubset<T, ItemCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCategories and returns the data saved in the database.
     * @param {ItemCategoryCreateManyAndReturnArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCategories and only return the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemCategory.
     * @param {ItemCategoryDeleteArgs} args - Arguments to delete one ItemCategory.
     * @example
     * // Delete one ItemCategory
     * const ItemCategory = await prisma.itemCategory.delete({
     *   where: {
     *     // ... filter to delete one ItemCategory
     *   }
     * })
     * 
     */
    delete<T extends ItemCategoryDeleteArgs>(args: SelectSubset<T, ItemCategoryDeleteArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemCategory.
     * @param {ItemCategoryUpdateArgs} args - Arguments to update one ItemCategory.
     * @example
     * // Update one ItemCategory
     * const itemCategory = await prisma.itemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategoryUpdateArgs>(args: SelectSubset<T, ItemCategoryUpdateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemCategories.
     * @param {ItemCategoryDeleteManyArgs} args - Arguments to filter ItemCategories to delete.
     * @example
     * // Delete a few ItemCategories
     * const { count } = await prisma.itemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategoryDeleteManyArgs>(args?: SelectSubset<T, ItemCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategoryUpdateManyArgs>(args: SelectSubset<T, ItemCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories and returns the data updated in the database.
     * @param {ItemCategoryUpdateManyAndReturnArgs} args - Arguments to update many ItemCategories.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemCategories and only return the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemCategory.
     * @param {ItemCategoryUpsertArgs} args - Arguments to update or create a ItemCategory.
     * @example
     * // Update or create a ItemCategory
     * const itemCategory = await prisma.itemCategory.upsert({
     *   create: {
     *     // ... data to create a ItemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategory we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategoryUpsertArgs>(args: SelectSubset<T, ItemCategoryUpsertArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCountArgs} args - Arguments to filter ItemCategories to count.
     * @example
     * // Count the number of ItemCategories
     * const count = await prisma.itemCategory.count({
     *   where: {
     *     // ... the filter for the ItemCategories we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryCountArgs>(
      args?: Subset<T, ItemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryAggregateArgs>(args: Subset<T, ItemCategoryAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryAggregateType<T>>

    /**
     * Group by ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategory model
   */
  readonly fields: ItemCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainCategory<T extends MainCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MainCategoryDefaultArgs<ExtArgs>>): Prisma__MainCategoryClient<$Result.GetResult<Prisma.$MainCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends ItemCategory$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategory model
   */
  interface ItemCategoryFieldRefs {
    readonly id: FieldRef<"ItemCategory", 'Int'>
    readonly ic_name: FieldRef<"ItemCategory", 'String'>
    readonly mc_id: FieldRef<"ItemCategory", 'Int'>
    readonly wc_category_id: FieldRef<"ItemCategory", 'Int'>
    readonly sync_status: FieldRef<"ItemCategory", 'String'>
    readonly last_sync: FieldRef<"ItemCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategory findUnique
   */
  export type ItemCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findUniqueOrThrow
   */
  export type ItemCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findFirst
   */
  export type ItemCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findFirstOrThrow
   */
  export type ItemCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findMany
   */
  export type ItemCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategories to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory create
   */
  export type ItemCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategory.
     */
    data: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
  }

  /**
   * ItemCategory createMany
   */
  export type ItemCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategory createManyAndReturn
   */
  export type ItemCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCategory update
   */
  export type ItemCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategory.
     */
    data: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemCategory to update.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory updateMany
   */
  export type ItemCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to update.
     */
    limit?: number
  }

  /**
   * ItemCategory updateManyAndReturn
   */
  export type ItemCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCategory upsert
   */
  export type ItemCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategory to update in case it exists.
     */
    where: ItemCategoryWhereUniqueInput
    /**
     * In case the ItemCategory found by the `where` argument doesn't exist, create a new ItemCategory with this data.
     */
    create: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
    /**
     * In case the ItemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
  }

  /**
   * ItemCategory delete
   */
  export type ItemCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter which ItemCategory to delete.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory deleteMany
   */
  export type ItemCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategories to delete
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to delete.
     */
    limit?: number
  }

  /**
   * ItemCategory.items
   */
  export type ItemCategory$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * ItemCategory without action
   */
  export type ItemCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    itcd: number | null
    ic_id: number | null
    price: number | null
    stock: number | null
    wc_product_id: number | null
    wc_parent_id: number | null
  }

  export type ItemSumAggregateOutputType = {
    itcd: number | null
    ic_id: number | null
    price: number | null
    stock: number | null
    wc_product_id: number | null
    wc_parent_id: number | null
  }

  export type ItemMinAggregateOutputType = {
    itcd: number | null
    item: string | null
    ic_id: number | null
    sku: string | null
    price: number | null
    stock: number | null
    wc_product_id: number | null
    wc_parent_id: number | null
    sync_status: string | null
    last_sync: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    itcd: number | null
    item: string | null
    ic_id: number | null
    sku: string | null
    price: number | null
    stock: number | null
    wc_product_id: number | null
    wc_parent_id: number | null
    sync_status: string | null
    last_sync: Date | null
  }

  export type ItemCountAggregateOutputType = {
    itcd: number
    item: number
    ic_id: number
    sku: number
    price: number
    stock: number
    wc_product_id: number
    wc_parent_id: number
    sync_status: number
    last_sync: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    itcd?: true
    ic_id?: true
    price?: true
    stock?: true
    wc_product_id?: true
    wc_parent_id?: true
  }

  export type ItemSumAggregateInputType = {
    itcd?: true
    ic_id?: true
    price?: true
    stock?: true
    wc_product_id?: true
    wc_parent_id?: true
  }

  export type ItemMinAggregateInputType = {
    itcd?: true
    item?: true
    ic_id?: true
    sku?: true
    price?: true
    stock?: true
    wc_product_id?: true
    wc_parent_id?: true
    sync_status?: true
    last_sync?: true
  }

  export type ItemMaxAggregateInputType = {
    itcd?: true
    item?: true
    ic_id?: true
    sku?: true
    price?: true
    stock?: true
    wc_product_id?: true
    wc_parent_id?: true
    sync_status?: true
    last_sync?: true
  }

  export type ItemCountAggregateInputType = {
    itcd?: true
    item?: true
    ic_id?: true
    sku?: true
    price?: true
    stock?: true
    wc_product_id?: true
    wc_parent_id?: true
    sync_status?: true
    last_sync?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    itcd: number
    item: string | null
    ic_id: number
    sku: string | null
    price: number | null
    stock: number | null
    wc_product_id: number | null
    wc_parent_id: number | null
    sync_status: string | null
    last_sync: Date | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itcd?: boolean
    item?: boolean
    ic_id?: boolean
    sku?: boolean
    price?: boolean
    stock?: boolean
    wc_product_id?: boolean
    wc_parent_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    itemCategories?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    Transactions?: boolean | Item$TransactionsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itcd?: boolean
    item?: boolean
    ic_id?: boolean
    sku?: boolean
    price?: boolean
    stock?: boolean
    wc_product_id?: boolean
    wc_parent_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    itemCategories?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itcd?: boolean
    item?: boolean
    ic_id?: boolean
    sku?: boolean
    price?: boolean
    stock?: boolean
    wc_product_id?: boolean
    wc_parent_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    itemCategories?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    itcd?: boolean
    item?: boolean
    ic_id?: boolean
    sku?: boolean
    price?: boolean
    stock?: boolean
    wc_product_id?: boolean
    wc_parent_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itcd" | "item" | "ic_id" | "sku" | "price" | "stock" | "wc_product_id" | "wc_parent_id" | "sync_status" | "last_sync", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemCategories?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    Transactions?: boolean | Item$TransactionsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemCategories?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemCategories?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      itemCategories: Prisma.$ItemCategoryPayload<ExtArgs>
      Transactions: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      itcd: number
      item: string | null
      ic_id: number
      sku: string | null
      price: number | null
      stock: number | null
      wc_product_id: number | null
      wc_parent_id: number | null
      sync_status: string | null
      last_sync: Date | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `itcd`
     * const itemWithItcdOnly = await prisma.item.findMany({ select: { itcd: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `itcd`
     * const itemWithItcdOnly = await prisma.item.createManyAndReturn({
     *   select: { itcd: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `itcd`
     * const itemWithItcdOnly = await prisma.item.updateManyAndReturn({
     *   select: { itcd: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemCategories<T extends ItemCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryDefaultArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Transactions<T extends Item$TransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Item$TransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly itcd: FieldRef<"Item", 'Int'>
    readonly item: FieldRef<"Item", 'String'>
    readonly ic_id: FieldRef<"Item", 'Int'>
    readonly sku: FieldRef<"Item", 'String'>
    readonly price: FieldRef<"Item", 'Float'>
    readonly stock: FieldRef<"Item", 'Int'>
    readonly wc_product_id: FieldRef<"Item", 'Int'>
    readonly wc_parent_id: FieldRef<"Item", 'Int'>
    readonly sync_status: FieldRef<"Item", 'String'>
    readonly last_sync: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.Transactions
   */
  export type Item$TransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model Designation
   */

  export type AggregateDesignation = {
    _count: DesignationCountAggregateOutputType | null
    _avg: DesignationAvgAggregateOutputType | null
    _sum: DesignationSumAggregateOutputType | null
    _min: DesignationMinAggregateOutputType | null
    _max: DesignationMaxAggregateOutputType | null
  }

  export type DesignationAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type DesignationSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type DesignationMinAggregateOutputType = {
    id: number | null
    desg_name: string | null
    company_id: number | null
  }

  export type DesignationMaxAggregateOutputType = {
    id: number | null
    desg_name: string | null
    company_id: number | null
  }

  export type DesignationCountAggregateOutputType = {
    id: number
    desg_name: number
    company_id: number
    _all: number
  }


  export type DesignationAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type DesignationSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type DesignationMinAggregateInputType = {
    id?: true
    desg_name?: true
    company_id?: true
  }

  export type DesignationMaxAggregateInputType = {
    id?: true
    desg_name?: true
    company_id?: true
  }

  export type DesignationCountAggregateInputType = {
    id?: true
    desg_name?: true
    company_id?: true
    _all?: true
  }

  export type DesignationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designation to aggregate.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Designations
    **/
    _count?: true | DesignationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignationMaxAggregateInputType
  }

  export type GetDesignationAggregateType<T extends DesignationAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignation[P]>
      : GetScalarType<T[P], AggregateDesignation[P]>
  }




  export type DesignationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignationWhereInput
    orderBy?: DesignationOrderByWithAggregationInput | DesignationOrderByWithAggregationInput[]
    by: DesignationScalarFieldEnum[] | DesignationScalarFieldEnum
    having?: DesignationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignationCountAggregateInputType | true
    _avg?: DesignationAvgAggregateInputType
    _sum?: DesignationSumAggregateInputType
    _min?: DesignationMinAggregateInputType
    _max?: DesignationMaxAggregateInputType
  }

  export type DesignationGroupByOutputType = {
    id: number
    desg_name: string | null
    company_id: number
    _count: DesignationCountAggregateOutputType | null
    _avg: DesignationAvgAggregateOutputType | null
    _sum: DesignationSumAggregateOutputType | null
    _min: DesignationMinAggregateOutputType | null
    _max: DesignationMaxAggregateOutputType | null
  }

  type GetDesignationGroupByPayload<T extends DesignationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignationGroupByOutputType[P]>
            : GetScalarType<T[P], DesignationGroupByOutputType[P]>
        }
      >
    >


  export type DesignationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desg_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designation"]>

  export type DesignationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desg_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designation"]>

  export type DesignationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desg_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designation"]>

  export type DesignationSelectScalar = {
    id?: boolean
    desg_name?: boolean
    company_id?: boolean
  }

  export type DesignationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "desg_name" | "company_id", ExtArgs["result"]["designation"]>
  export type DesignationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DesignationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DesignationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DesignationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Designation"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      desg_name: string | null
      company_id: number
    }, ExtArgs["result"]["designation"]>
    composites: {}
  }

  type DesignationGetPayload<S extends boolean | null | undefined | DesignationDefaultArgs> = $Result.GetResult<Prisma.$DesignationPayload, S>

  type DesignationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignationCountAggregateInputType | true
    }

  export interface DesignationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Designation'], meta: { name: 'Designation' } }
    /**
     * Find zero or one Designation that matches the filter.
     * @param {DesignationFindUniqueArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignationFindUniqueArgs>(args: SelectSubset<T, DesignationFindUniqueArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Designation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignationFindUniqueOrThrowArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignationFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Designation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindFirstArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignationFindFirstArgs>(args?: SelectSubset<T, DesignationFindFirstArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Designation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindFirstOrThrowArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignationFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Designations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Designations
     * const designations = await prisma.designation.findMany()
     * 
     * // Get first 10 Designations
     * const designations = await prisma.designation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designationWithIdOnly = await prisma.designation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignationFindManyArgs>(args?: SelectSubset<T, DesignationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Designation.
     * @param {DesignationCreateArgs} args - Arguments to create a Designation.
     * @example
     * // Create one Designation
     * const Designation = await prisma.designation.create({
     *   data: {
     *     // ... data to create a Designation
     *   }
     * })
     * 
     */
    create<T extends DesignationCreateArgs>(args: SelectSubset<T, DesignationCreateArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Designations.
     * @param {DesignationCreateManyArgs} args - Arguments to create many Designations.
     * @example
     * // Create many Designations
     * const designation = await prisma.designation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignationCreateManyArgs>(args?: SelectSubset<T, DesignationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Designations and returns the data saved in the database.
     * @param {DesignationCreateManyAndReturnArgs} args - Arguments to create many Designations.
     * @example
     * // Create many Designations
     * const designation = await prisma.designation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Designations and only return the `id`
     * const designationWithIdOnly = await prisma.designation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignationCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Designation.
     * @param {DesignationDeleteArgs} args - Arguments to delete one Designation.
     * @example
     * // Delete one Designation
     * const Designation = await prisma.designation.delete({
     *   where: {
     *     // ... filter to delete one Designation
     *   }
     * })
     * 
     */
    delete<T extends DesignationDeleteArgs>(args: SelectSubset<T, DesignationDeleteArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Designation.
     * @param {DesignationUpdateArgs} args - Arguments to update one Designation.
     * @example
     * // Update one Designation
     * const designation = await prisma.designation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignationUpdateArgs>(args: SelectSubset<T, DesignationUpdateArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Designations.
     * @param {DesignationDeleteManyArgs} args - Arguments to filter Designations to delete.
     * @example
     * // Delete a few Designations
     * const { count } = await prisma.designation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignationDeleteManyArgs>(args?: SelectSubset<T, DesignationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Designations
     * const designation = await prisma.designation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignationUpdateManyArgs>(args: SelectSubset<T, DesignationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designations and returns the data updated in the database.
     * @param {DesignationUpdateManyAndReturnArgs} args - Arguments to update many Designations.
     * @example
     * // Update many Designations
     * const designation = await prisma.designation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Designations and only return the `id`
     * const designationWithIdOnly = await prisma.designation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignationUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Designation.
     * @param {DesignationUpsertArgs} args - Arguments to update or create a Designation.
     * @example
     * // Update or create a Designation
     * const designation = await prisma.designation.upsert({
     *   create: {
     *     // ... data to create a Designation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Designation we want to update
     *   }
     * })
     */
    upsert<T extends DesignationUpsertArgs>(args: SelectSubset<T, DesignationUpsertArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Designations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationCountArgs} args - Arguments to filter Designations to count.
     * @example
     * // Count the number of Designations
     * const count = await prisma.designation.count({
     *   where: {
     *     // ... the filter for the Designations we want to count
     *   }
     * })
    **/
    count<T extends DesignationCountArgs>(
      args?: Subset<T, DesignationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Designation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignationAggregateArgs>(args: Subset<T, DesignationAggregateArgs>): Prisma.PrismaPromise<GetDesignationAggregateType<T>>

    /**
     * Group by Designation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignationGroupByArgs['orderBy'] }
        : { orderBy?: DesignationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Designation model
   */
  readonly fields: DesignationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Designation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Designation model
   */
  interface DesignationFieldRefs {
    readonly id: FieldRef<"Designation", 'Int'>
    readonly desg_name: FieldRef<"Designation", 'String'>
    readonly company_id: FieldRef<"Designation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Designation findUnique
   */
  export type DesignationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation findUniqueOrThrow
   */
  export type DesignationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation findFirst
   */
  export type DesignationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designations.
     */
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation findFirstOrThrow
   */
  export type DesignationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designations.
     */
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation findMany
   */
  export type DesignationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designations to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation create
   */
  export type DesignationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The data needed to create a Designation.
     */
    data: XOR<DesignationCreateInput, DesignationUncheckedCreateInput>
  }

  /**
   * Designation createMany
   */
  export type DesignationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Designations.
     */
    data: DesignationCreateManyInput | DesignationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Designation createManyAndReturn
   */
  export type DesignationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * The data used to create many Designations.
     */
    data: DesignationCreateManyInput | DesignationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Designation update
   */
  export type DesignationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The data needed to update a Designation.
     */
    data: XOR<DesignationUpdateInput, DesignationUncheckedUpdateInput>
    /**
     * Choose, which Designation to update.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation updateMany
   */
  export type DesignationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Designations.
     */
    data: XOR<DesignationUpdateManyMutationInput, DesignationUncheckedUpdateManyInput>
    /**
     * Filter which Designations to update
     */
    where?: DesignationWhereInput
    /**
     * Limit how many Designations to update.
     */
    limit?: number
  }

  /**
   * Designation updateManyAndReturn
   */
  export type DesignationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * The data used to update Designations.
     */
    data: XOR<DesignationUpdateManyMutationInput, DesignationUncheckedUpdateManyInput>
    /**
     * Filter which Designations to update
     */
    where?: DesignationWhereInput
    /**
     * Limit how many Designations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Designation upsert
   */
  export type DesignationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The filter to search for the Designation to update in case it exists.
     */
    where: DesignationWhereUniqueInput
    /**
     * In case the Designation found by the `where` argument doesn't exist, create a new Designation with this data.
     */
    create: XOR<DesignationCreateInput, DesignationUncheckedCreateInput>
    /**
     * In case the Designation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignationUpdateInput, DesignationUncheckedUpdateInput>
  }

  /**
   * Designation delete
   */
  export type DesignationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter which Designation to delete.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation deleteMany
   */
  export type DesignationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designations to delete
     */
    where?: DesignationWhereInput
    /**
     * Limit how many Designations to delete.
     */
    limit?: number
  }

  /**
   * Designation without action
   */
  export type DesignationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
  }


  /**
   * Model Godown
   */

  export type AggregateGodown = {
    _count: GodownCountAggregateOutputType | null
    _avg: GodownAvgAggregateOutputType | null
    _sum: GodownSumAggregateOutputType | null
    _min: GodownMinAggregateOutputType | null
    _max: GodownMaxAggregateOutputType | null
  }

  export type GodownAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type GodownSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type GodownMinAggregateOutputType = {
    id: number | null
    godown: string | null
    company_id: number | null
  }

  export type GodownMaxAggregateOutputType = {
    id: number | null
    godown: string | null
    company_id: number | null
  }

  export type GodownCountAggregateOutputType = {
    id: number
    godown: number
    company_id: number
    _all: number
  }


  export type GodownAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type GodownSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type GodownMinAggregateInputType = {
    id?: true
    godown?: true
    company_id?: true
  }

  export type GodownMaxAggregateInputType = {
    id?: true
    godown?: true
    company_id?: true
  }

  export type GodownCountAggregateInputType = {
    id?: true
    godown?: true
    company_id?: true
    _all?: true
  }

  export type GodownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Godown to aggregate.
     */
    where?: GodownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Godowns to fetch.
     */
    orderBy?: GodownOrderByWithRelationInput | GodownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GodownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Godowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Godowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Godowns
    **/
    _count?: true | GodownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GodownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GodownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GodownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GodownMaxAggregateInputType
  }

  export type GetGodownAggregateType<T extends GodownAggregateArgs> = {
        [P in keyof T & keyof AggregateGodown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGodown[P]>
      : GetScalarType<T[P], AggregateGodown[P]>
  }




  export type GodownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GodownWhereInput
    orderBy?: GodownOrderByWithAggregationInput | GodownOrderByWithAggregationInput[]
    by: GodownScalarFieldEnum[] | GodownScalarFieldEnum
    having?: GodownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GodownCountAggregateInputType | true
    _avg?: GodownAvgAggregateInputType
    _sum?: GodownSumAggregateInputType
    _min?: GodownMinAggregateInputType
    _max?: GodownMaxAggregateInputType
  }

  export type GodownGroupByOutputType = {
    id: number
    godown: string
    company_id: number
    _count: GodownCountAggregateOutputType | null
    _avg: GodownAvgAggregateOutputType | null
    _sum: GodownSumAggregateOutputType | null
    _min: GodownMinAggregateOutputType | null
    _max: GodownMaxAggregateOutputType | null
  }

  type GetGodownGroupByPayload<T extends GodownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GodownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GodownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GodownGroupByOutputType[P]>
            : GetScalarType<T[P], GodownGroupByOutputType[P]>
        }
      >
    >


  export type GodownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    godown?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    TransactionsMaster?: boolean | Godown$TransactionsMasterArgs<ExtArgs>
    Transaction?: boolean | Godown$TransactionArgs<ExtArgs>
    _count?: boolean | GodownCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["godown"]>

  export type GodownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    godown?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["godown"]>

  export type GodownSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    godown?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["godown"]>

  export type GodownSelectScalar = {
    id?: boolean
    godown?: boolean
    company_id?: boolean
  }

  export type GodownOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "godown" | "company_id", ExtArgs["result"]["godown"]>
  export type GodownInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    TransactionsMaster?: boolean | Godown$TransactionsMasterArgs<ExtArgs>
    Transaction?: boolean | Godown$TransactionArgs<ExtArgs>
    _count?: boolean | GodownCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GodownIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type GodownIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $GodownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Godown"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      TransactionsMaster: Prisma.$TransactionsMasterPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      godown: string
      company_id: number
    }, ExtArgs["result"]["godown"]>
    composites: {}
  }

  type GodownGetPayload<S extends boolean | null | undefined | GodownDefaultArgs> = $Result.GetResult<Prisma.$GodownPayload, S>

  type GodownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GodownFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GodownCountAggregateInputType | true
    }

  export interface GodownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Godown'], meta: { name: 'Godown' } }
    /**
     * Find zero or one Godown that matches the filter.
     * @param {GodownFindUniqueArgs} args - Arguments to find a Godown
     * @example
     * // Get one Godown
     * const godown = await prisma.godown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GodownFindUniqueArgs>(args: SelectSubset<T, GodownFindUniqueArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Godown that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GodownFindUniqueOrThrowArgs} args - Arguments to find a Godown
     * @example
     * // Get one Godown
     * const godown = await prisma.godown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GodownFindUniqueOrThrowArgs>(args: SelectSubset<T, GodownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Godown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GodownFindFirstArgs} args - Arguments to find a Godown
     * @example
     * // Get one Godown
     * const godown = await prisma.godown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GodownFindFirstArgs>(args?: SelectSubset<T, GodownFindFirstArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Godown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GodownFindFirstOrThrowArgs} args - Arguments to find a Godown
     * @example
     * // Get one Godown
     * const godown = await prisma.godown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GodownFindFirstOrThrowArgs>(args?: SelectSubset<T, GodownFindFirstOrThrowArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Godowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GodownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Godowns
     * const godowns = await prisma.godown.findMany()
     * 
     * // Get first 10 Godowns
     * const godowns = await prisma.godown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const godownWithIdOnly = await prisma.godown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GodownFindManyArgs>(args?: SelectSubset<T, GodownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Godown.
     * @param {GodownCreateArgs} args - Arguments to create a Godown.
     * @example
     * // Create one Godown
     * const Godown = await prisma.godown.create({
     *   data: {
     *     // ... data to create a Godown
     *   }
     * })
     * 
     */
    create<T extends GodownCreateArgs>(args: SelectSubset<T, GodownCreateArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Godowns.
     * @param {GodownCreateManyArgs} args - Arguments to create many Godowns.
     * @example
     * // Create many Godowns
     * const godown = await prisma.godown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GodownCreateManyArgs>(args?: SelectSubset<T, GodownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Godowns and returns the data saved in the database.
     * @param {GodownCreateManyAndReturnArgs} args - Arguments to create many Godowns.
     * @example
     * // Create many Godowns
     * const godown = await prisma.godown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Godowns and only return the `id`
     * const godownWithIdOnly = await prisma.godown.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GodownCreateManyAndReturnArgs>(args?: SelectSubset<T, GodownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Godown.
     * @param {GodownDeleteArgs} args - Arguments to delete one Godown.
     * @example
     * // Delete one Godown
     * const Godown = await prisma.godown.delete({
     *   where: {
     *     // ... filter to delete one Godown
     *   }
     * })
     * 
     */
    delete<T extends GodownDeleteArgs>(args: SelectSubset<T, GodownDeleteArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Godown.
     * @param {GodownUpdateArgs} args - Arguments to update one Godown.
     * @example
     * // Update one Godown
     * const godown = await prisma.godown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GodownUpdateArgs>(args: SelectSubset<T, GodownUpdateArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Godowns.
     * @param {GodownDeleteManyArgs} args - Arguments to filter Godowns to delete.
     * @example
     * // Delete a few Godowns
     * const { count } = await prisma.godown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GodownDeleteManyArgs>(args?: SelectSubset<T, GodownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Godowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GodownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Godowns
     * const godown = await prisma.godown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GodownUpdateManyArgs>(args: SelectSubset<T, GodownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Godowns and returns the data updated in the database.
     * @param {GodownUpdateManyAndReturnArgs} args - Arguments to update many Godowns.
     * @example
     * // Update many Godowns
     * const godown = await prisma.godown.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Godowns and only return the `id`
     * const godownWithIdOnly = await prisma.godown.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GodownUpdateManyAndReturnArgs>(args: SelectSubset<T, GodownUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Godown.
     * @param {GodownUpsertArgs} args - Arguments to update or create a Godown.
     * @example
     * // Update or create a Godown
     * const godown = await prisma.godown.upsert({
     *   create: {
     *     // ... data to create a Godown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Godown we want to update
     *   }
     * })
     */
    upsert<T extends GodownUpsertArgs>(args: SelectSubset<T, GodownUpsertArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Godowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GodownCountArgs} args - Arguments to filter Godowns to count.
     * @example
     * // Count the number of Godowns
     * const count = await prisma.godown.count({
     *   where: {
     *     // ... the filter for the Godowns we want to count
     *   }
     * })
    **/
    count<T extends GodownCountArgs>(
      args?: Subset<T, GodownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GodownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Godown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GodownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GodownAggregateArgs>(args: Subset<T, GodownAggregateArgs>): Prisma.PrismaPromise<GetGodownAggregateType<T>>

    /**
     * Group by Godown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GodownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GodownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GodownGroupByArgs['orderBy'] }
        : { orderBy?: GodownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GodownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGodownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Godown model
   */
  readonly fields: GodownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Godown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GodownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    TransactionsMaster<T extends Godown$TransactionsMasterArgs<ExtArgs> = {}>(args?: Subset<T, Godown$TransactionsMasterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Godown$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Godown$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Godown model
   */
  interface GodownFieldRefs {
    readonly id: FieldRef<"Godown", 'Int'>
    readonly godown: FieldRef<"Godown", 'String'>
    readonly company_id: FieldRef<"Godown", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Godown findUnique
   */
  export type GodownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * Filter, which Godown to fetch.
     */
    where: GodownWhereUniqueInput
  }

  /**
   * Godown findUniqueOrThrow
   */
  export type GodownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * Filter, which Godown to fetch.
     */
    where: GodownWhereUniqueInput
  }

  /**
   * Godown findFirst
   */
  export type GodownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * Filter, which Godown to fetch.
     */
    where?: GodownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Godowns to fetch.
     */
    orderBy?: GodownOrderByWithRelationInput | GodownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Godowns.
     */
    cursor?: GodownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Godowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Godowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Godowns.
     */
    distinct?: GodownScalarFieldEnum | GodownScalarFieldEnum[]
  }

  /**
   * Godown findFirstOrThrow
   */
  export type GodownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * Filter, which Godown to fetch.
     */
    where?: GodownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Godowns to fetch.
     */
    orderBy?: GodownOrderByWithRelationInput | GodownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Godowns.
     */
    cursor?: GodownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Godowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Godowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Godowns.
     */
    distinct?: GodownScalarFieldEnum | GodownScalarFieldEnum[]
  }

  /**
   * Godown findMany
   */
  export type GodownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * Filter, which Godowns to fetch.
     */
    where?: GodownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Godowns to fetch.
     */
    orderBy?: GodownOrderByWithRelationInput | GodownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Godowns.
     */
    cursor?: GodownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Godowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Godowns.
     */
    skip?: number
    distinct?: GodownScalarFieldEnum | GodownScalarFieldEnum[]
  }

  /**
   * Godown create
   */
  export type GodownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * The data needed to create a Godown.
     */
    data: XOR<GodownCreateInput, GodownUncheckedCreateInput>
  }

  /**
   * Godown createMany
   */
  export type GodownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Godowns.
     */
    data: GodownCreateManyInput | GodownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Godown createManyAndReturn
   */
  export type GodownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * The data used to create many Godowns.
     */
    data: GodownCreateManyInput | GodownCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Godown update
   */
  export type GodownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * The data needed to update a Godown.
     */
    data: XOR<GodownUpdateInput, GodownUncheckedUpdateInput>
    /**
     * Choose, which Godown to update.
     */
    where: GodownWhereUniqueInput
  }

  /**
   * Godown updateMany
   */
  export type GodownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Godowns.
     */
    data: XOR<GodownUpdateManyMutationInput, GodownUncheckedUpdateManyInput>
    /**
     * Filter which Godowns to update
     */
    where?: GodownWhereInput
    /**
     * Limit how many Godowns to update.
     */
    limit?: number
  }

  /**
   * Godown updateManyAndReturn
   */
  export type GodownUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * The data used to update Godowns.
     */
    data: XOR<GodownUpdateManyMutationInput, GodownUncheckedUpdateManyInput>
    /**
     * Filter which Godowns to update
     */
    where?: GodownWhereInput
    /**
     * Limit how many Godowns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Godown upsert
   */
  export type GodownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * The filter to search for the Godown to update in case it exists.
     */
    where: GodownWhereUniqueInput
    /**
     * In case the Godown found by the `where` argument doesn't exist, create a new Godown with this data.
     */
    create: XOR<GodownCreateInput, GodownUncheckedCreateInput>
    /**
     * In case the Godown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GodownUpdateInput, GodownUncheckedUpdateInput>
  }

  /**
   * Godown delete
   */
  export type GodownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    /**
     * Filter which Godown to delete.
     */
    where: GodownWhereUniqueInput
  }

  /**
   * Godown deleteMany
   */
  export type GodownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Godowns to delete
     */
    where?: GodownWhereInput
    /**
     * Limit how many Godowns to delete.
     */
    limit?: number
  }

  /**
   * Godown.TransactionsMaster
   */
  export type Godown$TransactionsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    where?: TransactionsMasterWhereInput
    orderBy?: TransactionsMasterOrderByWithRelationInput | TransactionsMasterOrderByWithRelationInput[]
    cursor?: TransactionsMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsMasterScalarFieldEnum | TransactionsMasterScalarFieldEnum[]
  }

  /**
   * Godown.Transaction
   */
  export type Godown$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Godown without action
   */
  export type GodownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
  }


  /**
   * Model FinancialYear
   */

  export type AggregateFinancialYear = {
    _count: FinancialYearCountAggregateOutputType | null
    _avg: FinancialYearAvgAggregateOutputType | null
    _sum: FinancialYearSumAggregateOutputType | null
    _min: FinancialYearMinAggregateOutputType | null
    _max: FinancialYearMaxAggregateOutputType | null
  }

  export type FinancialYearAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type FinancialYearSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type FinancialYearMinAggregateOutputType = {
    id: number | null
    date_from: Date | null
    date_to: Date | null
    status: string | null
    company_id: number | null
  }

  export type FinancialYearMaxAggregateOutputType = {
    id: number | null
    date_from: Date | null
    date_to: Date | null
    status: string | null
    company_id: number | null
  }

  export type FinancialYearCountAggregateOutputType = {
    id: number
    date_from: number
    date_to: number
    status: number
    company_id: number
    _all: number
  }


  export type FinancialYearAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type FinancialYearSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type FinancialYearMinAggregateInputType = {
    id?: true
    date_from?: true
    date_to?: true
    status?: true
    company_id?: true
  }

  export type FinancialYearMaxAggregateInputType = {
    id?: true
    date_from?: true
    date_to?: true
    status?: true
    company_id?: true
  }

  export type FinancialYearCountAggregateInputType = {
    id?: true
    date_from?: true
    date_to?: true
    status?: true
    company_id?: true
    _all?: true
  }

  export type FinancialYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialYear to aggregate.
     */
    where?: FinancialYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialYears to fetch.
     */
    orderBy?: FinancialYearOrderByWithRelationInput | FinancialYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialYears
    **/
    _count?: true | FinancialYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialYearMaxAggregateInputType
  }

  export type GetFinancialYearAggregateType<T extends FinancialYearAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialYear[P]>
      : GetScalarType<T[P], AggregateFinancialYear[P]>
  }




  export type FinancialYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialYearWhereInput
    orderBy?: FinancialYearOrderByWithAggregationInput | FinancialYearOrderByWithAggregationInput[]
    by: FinancialYearScalarFieldEnum[] | FinancialYearScalarFieldEnum
    having?: FinancialYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialYearCountAggregateInputType | true
    _avg?: FinancialYearAvgAggregateInputType
    _sum?: FinancialYearSumAggregateInputType
    _min?: FinancialYearMinAggregateInputType
    _max?: FinancialYearMaxAggregateInputType
  }

  export type FinancialYearGroupByOutputType = {
    id: number
    date_from: Date
    date_to: Date
    status: string
    company_id: number
    _count: FinancialYearCountAggregateOutputType | null
    _avg: FinancialYearAvgAggregateOutputType | null
    _sum: FinancialYearSumAggregateOutputType | null
    _min: FinancialYearMinAggregateOutputType | null
    _max: FinancialYearMaxAggregateOutputType | null
  }

  type GetFinancialYearGroupByPayload<T extends FinancialYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialYearGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialYearGroupByOutputType[P]>
        }
      >
    >


  export type FinancialYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_from?: boolean
    date_to?: boolean
    status?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialYear"]>

  export type FinancialYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_from?: boolean
    date_to?: boolean
    status?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialYear"]>

  export type FinancialYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_from?: boolean
    date_to?: boolean
    status?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialYear"]>

  export type FinancialYearSelectScalar = {
    id?: boolean
    date_from?: boolean
    date_to?: boolean
    status?: boolean
    company_id?: boolean
  }

  export type FinancialYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date_from" | "date_to" | "status" | "company_id", ExtArgs["result"]["financialYear"]>
  export type FinancialYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type FinancialYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type FinancialYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $FinancialYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialYear"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date_from: Date
      date_to: Date
      status: string
      company_id: number
    }, ExtArgs["result"]["financialYear"]>
    composites: {}
  }

  type FinancialYearGetPayload<S extends boolean | null | undefined | FinancialYearDefaultArgs> = $Result.GetResult<Prisma.$FinancialYearPayload, S>

  type FinancialYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialYearCountAggregateInputType | true
    }

  export interface FinancialYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialYear'], meta: { name: 'FinancialYear' } }
    /**
     * Find zero or one FinancialYear that matches the filter.
     * @param {FinancialYearFindUniqueArgs} args - Arguments to find a FinancialYear
     * @example
     * // Get one FinancialYear
     * const financialYear = await prisma.financialYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialYearFindUniqueArgs>(args: SelectSubset<T, FinancialYearFindUniqueArgs<ExtArgs>>): Prisma__FinancialYearClient<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialYearFindUniqueOrThrowArgs} args - Arguments to find a FinancialYear
     * @example
     * // Get one FinancialYear
     * const financialYear = await prisma.financialYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialYearFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialYearClient<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialYearFindFirstArgs} args - Arguments to find a FinancialYear
     * @example
     * // Get one FinancialYear
     * const financialYear = await prisma.financialYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialYearFindFirstArgs>(args?: SelectSubset<T, FinancialYearFindFirstArgs<ExtArgs>>): Prisma__FinancialYearClient<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialYearFindFirstOrThrowArgs} args - Arguments to find a FinancialYear
     * @example
     * // Get one FinancialYear
     * const financialYear = await prisma.financialYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialYearFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialYearClient<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialYears
     * const financialYears = await prisma.financialYear.findMany()
     * 
     * // Get first 10 FinancialYears
     * const financialYears = await prisma.financialYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialYearWithIdOnly = await prisma.financialYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialYearFindManyArgs>(args?: SelectSubset<T, FinancialYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialYear.
     * @param {FinancialYearCreateArgs} args - Arguments to create a FinancialYear.
     * @example
     * // Create one FinancialYear
     * const FinancialYear = await prisma.financialYear.create({
     *   data: {
     *     // ... data to create a FinancialYear
     *   }
     * })
     * 
     */
    create<T extends FinancialYearCreateArgs>(args: SelectSubset<T, FinancialYearCreateArgs<ExtArgs>>): Prisma__FinancialYearClient<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialYears.
     * @param {FinancialYearCreateManyArgs} args - Arguments to create many FinancialYears.
     * @example
     * // Create many FinancialYears
     * const financialYear = await prisma.financialYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialYearCreateManyArgs>(args?: SelectSubset<T, FinancialYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialYears and returns the data saved in the database.
     * @param {FinancialYearCreateManyAndReturnArgs} args - Arguments to create many FinancialYears.
     * @example
     * // Create many FinancialYears
     * const financialYear = await prisma.financialYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialYears and only return the `id`
     * const financialYearWithIdOnly = await prisma.financialYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialYearCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialYear.
     * @param {FinancialYearDeleteArgs} args - Arguments to delete one FinancialYear.
     * @example
     * // Delete one FinancialYear
     * const FinancialYear = await prisma.financialYear.delete({
     *   where: {
     *     // ... filter to delete one FinancialYear
     *   }
     * })
     * 
     */
    delete<T extends FinancialYearDeleteArgs>(args: SelectSubset<T, FinancialYearDeleteArgs<ExtArgs>>): Prisma__FinancialYearClient<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialYear.
     * @param {FinancialYearUpdateArgs} args - Arguments to update one FinancialYear.
     * @example
     * // Update one FinancialYear
     * const financialYear = await prisma.financialYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialYearUpdateArgs>(args: SelectSubset<T, FinancialYearUpdateArgs<ExtArgs>>): Prisma__FinancialYearClient<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialYears.
     * @param {FinancialYearDeleteManyArgs} args - Arguments to filter FinancialYears to delete.
     * @example
     * // Delete a few FinancialYears
     * const { count } = await prisma.financialYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialYearDeleteManyArgs>(args?: SelectSubset<T, FinancialYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialYears
     * const financialYear = await prisma.financialYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialYearUpdateManyArgs>(args: SelectSubset<T, FinancialYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialYears and returns the data updated in the database.
     * @param {FinancialYearUpdateManyAndReturnArgs} args - Arguments to update many FinancialYears.
     * @example
     * // Update many FinancialYears
     * const financialYear = await prisma.financialYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialYears and only return the `id`
     * const financialYearWithIdOnly = await prisma.financialYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialYearUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialYear.
     * @param {FinancialYearUpsertArgs} args - Arguments to update or create a FinancialYear.
     * @example
     * // Update or create a FinancialYear
     * const financialYear = await prisma.financialYear.upsert({
     *   create: {
     *     // ... data to create a FinancialYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialYear we want to update
     *   }
     * })
     */
    upsert<T extends FinancialYearUpsertArgs>(args: SelectSubset<T, FinancialYearUpsertArgs<ExtArgs>>): Prisma__FinancialYearClient<$Result.GetResult<Prisma.$FinancialYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialYearCountArgs} args - Arguments to filter FinancialYears to count.
     * @example
     * // Count the number of FinancialYears
     * const count = await prisma.financialYear.count({
     *   where: {
     *     // ... the filter for the FinancialYears we want to count
     *   }
     * })
    **/
    count<T extends FinancialYearCountArgs>(
      args?: Subset<T, FinancialYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialYearAggregateArgs>(args: Subset<T, FinancialYearAggregateArgs>): Prisma.PrismaPromise<GetFinancialYearAggregateType<T>>

    /**
     * Group by FinancialYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialYearGroupByArgs['orderBy'] }
        : { orderBy?: FinancialYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialYear model
   */
  readonly fields: FinancialYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialYear model
   */
  interface FinancialYearFieldRefs {
    readonly id: FieldRef<"FinancialYear", 'Int'>
    readonly date_from: FieldRef<"FinancialYear", 'DateTime'>
    readonly date_to: FieldRef<"FinancialYear", 'DateTime'>
    readonly status: FieldRef<"FinancialYear", 'String'>
    readonly company_id: FieldRef<"FinancialYear", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FinancialYear findUnique
   */
  export type FinancialYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * Filter, which FinancialYear to fetch.
     */
    where: FinancialYearWhereUniqueInput
  }

  /**
   * FinancialYear findUniqueOrThrow
   */
  export type FinancialYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * Filter, which FinancialYear to fetch.
     */
    where: FinancialYearWhereUniqueInput
  }

  /**
   * FinancialYear findFirst
   */
  export type FinancialYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * Filter, which FinancialYear to fetch.
     */
    where?: FinancialYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialYears to fetch.
     */
    orderBy?: FinancialYearOrderByWithRelationInput | FinancialYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialYears.
     */
    cursor?: FinancialYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialYears.
     */
    distinct?: FinancialYearScalarFieldEnum | FinancialYearScalarFieldEnum[]
  }

  /**
   * FinancialYear findFirstOrThrow
   */
  export type FinancialYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * Filter, which FinancialYear to fetch.
     */
    where?: FinancialYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialYears to fetch.
     */
    orderBy?: FinancialYearOrderByWithRelationInput | FinancialYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialYears.
     */
    cursor?: FinancialYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialYears.
     */
    distinct?: FinancialYearScalarFieldEnum | FinancialYearScalarFieldEnum[]
  }

  /**
   * FinancialYear findMany
   */
  export type FinancialYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * Filter, which FinancialYears to fetch.
     */
    where?: FinancialYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialYears to fetch.
     */
    orderBy?: FinancialYearOrderByWithRelationInput | FinancialYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialYears.
     */
    cursor?: FinancialYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialYears.
     */
    skip?: number
    distinct?: FinancialYearScalarFieldEnum | FinancialYearScalarFieldEnum[]
  }

  /**
   * FinancialYear create
   */
  export type FinancialYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialYear.
     */
    data: XOR<FinancialYearCreateInput, FinancialYearUncheckedCreateInput>
  }

  /**
   * FinancialYear createMany
   */
  export type FinancialYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialYears.
     */
    data: FinancialYearCreateManyInput | FinancialYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialYear createManyAndReturn
   */
  export type FinancialYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialYears.
     */
    data: FinancialYearCreateManyInput | FinancialYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialYear update
   */
  export type FinancialYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialYear.
     */
    data: XOR<FinancialYearUpdateInput, FinancialYearUncheckedUpdateInput>
    /**
     * Choose, which FinancialYear to update.
     */
    where: FinancialYearWhereUniqueInput
  }

  /**
   * FinancialYear updateMany
   */
  export type FinancialYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialYears.
     */
    data: XOR<FinancialYearUpdateManyMutationInput, FinancialYearUncheckedUpdateManyInput>
    /**
     * Filter which FinancialYears to update
     */
    where?: FinancialYearWhereInput
    /**
     * Limit how many FinancialYears to update.
     */
    limit?: number
  }

  /**
   * FinancialYear updateManyAndReturn
   */
  export type FinancialYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * The data used to update FinancialYears.
     */
    data: XOR<FinancialYearUpdateManyMutationInput, FinancialYearUncheckedUpdateManyInput>
    /**
     * Filter which FinancialYears to update
     */
    where?: FinancialYearWhereInput
    /**
     * Limit how many FinancialYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialYear upsert
   */
  export type FinancialYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialYear to update in case it exists.
     */
    where: FinancialYearWhereUniqueInput
    /**
     * In case the FinancialYear found by the `where` argument doesn't exist, create a new FinancialYear with this data.
     */
    create: XOR<FinancialYearCreateInput, FinancialYearUncheckedCreateInput>
    /**
     * In case the FinancialYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialYearUpdateInput, FinancialYearUncheckedUpdateInput>
  }

  /**
   * FinancialYear delete
   */
  export type FinancialYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
    /**
     * Filter which FinancialYear to delete.
     */
    where: FinancialYearWhereUniqueInput
  }

  /**
   * FinancialYear deleteMany
   */
  export type FinancialYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialYears to delete
     */
    where?: FinancialYearWhereInput
    /**
     * Limit how many FinancialYears to delete.
     */
    limit?: number
  }

  /**
   * FinancialYear without action
   */
  export type FinancialYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialYear
     */
    select?: FinancialYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialYear
     */
    omit?: FinancialYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialYearInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type SeasonSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type SeasonMinAggregateOutputType = {
    id: number | null
    date_from: Date | null
    date_to: Date | null
    status: string | null
    company_id: number | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: number | null
    date_from: Date | null
    date_to: Date | null
    status: string | null
    company_id: number | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    date_from: number
    date_to: number
    status: number
    company_id: number
    _all: number
  }


  export type SeasonAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type SeasonSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type SeasonMinAggregateInputType = {
    id?: true
    date_from?: true
    date_to?: true
    status?: true
    company_id?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    date_from?: true
    date_to?: true
    status?: true
    company_id?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    date_from?: true
    date_to?: true
    status?: true
    company_id?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _avg?: SeasonAvgAggregateInputType
    _sum?: SeasonSumAggregateInputType
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: number
    date_from: Date
    date_to: Date
    status: string
    company_id: number
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_from?: boolean
    date_to?: boolean
    status?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_from?: boolean
    date_to?: boolean
    status?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_from?: boolean
    date_to?: boolean
    status?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectScalar = {
    id?: boolean
    date_from?: boolean
    date_to?: boolean
    status?: boolean
    company_id?: boolean
  }

  export type SeasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date_from" | "date_to" | "status" | "company_id", ExtArgs["result"]["season"]>
  export type SeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date_from: Date
      date_to: Date
      status: string
      company_id: number
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seasons and returns the data saved in the database.
     * @param {SeasonCreateManyAndReturnArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons and returns the data updated in the database.
     * @param {SeasonUpdateManyAndReturnArgs} args - Arguments to update many Seasons.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeasonUpdateManyAndReturnArgs>(args: SelectSubset<T, SeasonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'Int'>
    readonly date_from: FieldRef<"Season", 'DateTime'>
    readonly date_to: FieldRef<"Season", 'DateTime'>
    readonly status: FieldRef<"Season", 'String'>
    readonly company_id: FieldRef<"Season", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Season createManyAndReturn
   */
  export type SeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
  }

  /**
   * Season updateManyAndReturn
   */
  export type SeasonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to delete.
     */
    limit?: number
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
  }


  /**
   * Model PoPrdCat
   */

  export type AggregatePoPrdCat = {
    _count: PoPrdCatCountAggregateOutputType | null
    _avg: PoPrdCatAvgAggregateOutputType | null
    _sum: PoPrdCatSumAggregateOutputType | null
    _min: PoPrdCatMinAggregateOutputType | null
    _max: PoPrdCatMaxAggregateOutputType | null
  }

  export type PoPrdCatAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type PoPrdCatSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type PoPrdCatMinAggregateOutputType = {
    id: number | null
    category_name: string | null
    company_id: number | null
  }

  export type PoPrdCatMaxAggregateOutputType = {
    id: number | null
    category_name: string | null
    company_id: number | null
  }

  export type PoPrdCatCountAggregateOutputType = {
    id: number
    category_name: number
    company_id: number
    _all: number
  }


  export type PoPrdCatAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type PoPrdCatSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type PoPrdCatMinAggregateInputType = {
    id?: true
    category_name?: true
    company_id?: true
  }

  export type PoPrdCatMaxAggregateInputType = {
    id?: true
    category_name?: true
    company_id?: true
  }

  export type PoPrdCatCountAggregateInputType = {
    id?: true
    category_name?: true
    company_id?: true
    _all?: true
  }

  export type PoPrdCatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoPrdCat to aggregate.
     */
    where?: PoPrdCatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoPrdCats to fetch.
     */
    orderBy?: PoPrdCatOrderByWithRelationInput | PoPrdCatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PoPrdCatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoPrdCats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoPrdCats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PoPrdCats
    **/
    _count?: true | PoPrdCatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PoPrdCatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PoPrdCatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoPrdCatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoPrdCatMaxAggregateInputType
  }

  export type GetPoPrdCatAggregateType<T extends PoPrdCatAggregateArgs> = {
        [P in keyof T & keyof AggregatePoPrdCat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoPrdCat[P]>
      : GetScalarType<T[P], AggregatePoPrdCat[P]>
  }




  export type PoPrdCatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoPrdCatWhereInput
    orderBy?: PoPrdCatOrderByWithAggregationInput | PoPrdCatOrderByWithAggregationInput[]
    by: PoPrdCatScalarFieldEnum[] | PoPrdCatScalarFieldEnum
    having?: PoPrdCatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoPrdCatCountAggregateInputType | true
    _avg?: PoPrdCatAvgAggregateInputType
    _sum?: PoPrdCatSumAggregateInputType
    _min?: PoPrdCatMinAggregateInputType
    _max?: PoPrdCatMaxAggregateInputType
  }

  export type PoPrdCatGroupByOutputType = {
    id: number
    category_name: string
    company_id: number
    _count: PoPrdCatCountAggregateOutputType | null
    _avg: PoPrdCatAvgAggregateOutputType | null
    _sum: PoPrdCatSumAggregateOutputType | null
    _min: PoPrdCatMinAggregateOutputType | null
    _max: PoPrdCatMaxAggregateOutputType | null
  }

  type GetPoPrdCatGroupByPayload<T extends PoPrdCatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PoPrdCatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoPrdCatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoPrdCatGroupByOutputType[P]>
            : GetScalarType<T[P], PoPrdCatGroupByOutputType[P]>
        }
      >
    >


  export type PoPrdCatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poPrdCat"]>

  export type PoPrdCatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poPrdCat"]>

  export type PoPrdCatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poPrdCat"]>

  export type PoPrdCatSelectScalar = {
    id?: boolean
    category_name?: boolean
    company_id?: boolean
  }

  export type PoPrdCatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category_name" | "company_id", ExtArgs["result"]["poPrdCat"]>
  export type PoPrdCatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PoPrdCatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PoPrdCatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PoPrdCatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PoPrdCat"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category_name: string
      company_id: number
    }, ExtArgs["result"]["poPrdCat"]>
    composites: {}
  }

  type PoPrdCatGetPayload<S extends boolean | null | undefined | PoPrdCatDefaultArgs> = $Result.GetResult<Prisma.$PoPrdCatPayload, S>

  type PoPrdCatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PoPrdCatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PoPrdCatCountAggregateInputType | true
    }

  export interface PoPrdCatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PoPrdCat'], meta: { name: 'PoPrdCat' } }
    /**
     * Find zero or one PoPrdCat that matches the filter.
     * @param {PoPrdCatFindUniqueArgs} args - Arguments to find a PoPrdCat
     * @example
     * // Get one PoPrdCat
     * const poPrdCat = await prisma.poPrdCat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PoPrdCatFindUniqueArgs>(args: SelectSubset<T, PoPrdCatFindUniqueArgs<ExtArgs>>): Prisma__PoPrdCatClient<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PoPrdCat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PoPrdCatFindUniqueOrThrowArgs} args - Arguments to find a PoPrdCat
     * @example
     * // Get one PoPrdCat
     * const poPrdCat = await prisma.poPrdCat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PoPrdCatFindUniqueOrThrowArgs>(args: SelectSubset<T, PoPrdCatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PoPrdCatClient<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoPrdCat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoPrdCatFindFirstArgs} args - Arguments to find a PoPrdCat
     * @example
     * // Get one PoPrdCat
     * const poPrdCat = await prisma.poPrdCat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PoPrdCatFindFirstArgs>(args?: SelectSubset<T, PoPrdCatFindFirstArgs<ExtArgs>>): Prisma__PoPrdCatClient<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoPrdCat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoPrdCatFindFirstOrThrowArgs} args - Arguments to find a PoPrdCat
     * @example
     * // Get one PoPrdCat
     * const poPrdCat = await prisma.poPrdCat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PoPrdCatFindFirstOrThrowArgs>(args?: SelectSubset<T, PoPrdCatFindFirstOrThrowArgs<ExtArgs>>): Prisma__PoPrdCatClient<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PoPrdCats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoPrdCatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PoPrdCats
     * const poPrdCats = await prisma.poPrdCat.findMany()
     * 
     * // Get first 10 PoPrdCats
     * const poPrdCats = await prisma.poPrdCat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poPrdCatWithIdOnly = await prisma.poPrdCat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PoPrdCatFindManyArgs>(args?: SelectSubset<T, PoPrdCatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PoPrdCat.
     * @param {PoPrdCatCreateArgs} args - Arguments to create a PoPrdCat.
     * @example
     * // Create one PoPrdCat
     * const PoPrdCat = await prisma.poPrdCat.create({
     *   data: {
     *     // ... data to create a PoPrdCat
     *   }
     * })
     * 
     */
    create<T extends PoPrdCatCreateArgs>(args: SelectSubset<T, PoPrdCatCreateArgs<ExtArgs>>): Prisma__PoPrdCatClient<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PoPrdCats.
     * @param {PoPrdCatCreateManyArgs} args - Arguments to create many PoPrdCats.
     * @example
     * // Create many PoPrdCats
     * const poPrdCat = await prisma.poPrdCat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PoPrdCatCreateManyArgs>(args?: SelectSubset<T, PoPrdCatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PoPrdCats and returns the data saved in the database.
     * @param {PoPrdCatCreateManyAndReturnArgs} args - Arguments to create many PoPrdCats.
     * @example
     * // Create many PoPrdCats
     * const poPrdCat = await prisma.poPrdCat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PoPrdCats and only return the `id`
     * const poPrdCatWithIdOnly = await prisma.poPrdCat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PoPrdCatCreateManyAndReturnArgs>(args?: SelectSubset<T, PoPrdCatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PoPrdCat.
     * @param {PoPrdCatDeleteArgs} args - Arguments to delete one PoPrdCat.
     * @example
     * // Delete one PoPrdCat
     * const PoPrdCat = await prisma.poPrdCat.delete({
     *   where: {
     *     // ... filter to delete one PoPrdCat
     *   }
     * })
     * 
     */
    delete<T extends PoPrdCatDeleteArgs>(args: SelectSubset<T, PoPrdCatDeleteArgs<ExtArgs>>): Prisma__PoPrdCatClient<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PoPrdCat.
     * @param {PoPrdCatUpdateArgs} args - Arguments to update one PoPrdCat.
     * @example
     * // Update one PoPrdCat
     * const poPrdCat = await prisma.poPrdCat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PoPrdCatUpdateArgs>(args: SelectSubset<T, PoPrdCatUpdateArgs<ExtArgs>>): Prisma__PoPrdCatClient<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PoPrdCats.
     * @param {PoPrdCatDeleteManyArgs} args - Arguments to filter PoPrdCats to delete.
     * @example
     * // Delete a few PoPrdCats
     * const { count } = await prisma.poPrdCat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PoPrdCatDeleteManyArgs>(args?: SelectSubset<T, PoPrdCatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoPrdCats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoPrdCatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PoPrdCats
     * const poPrdCat = await prisma.poPrdCat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PoPrdCatUpdateManyArgs>(args: SelectSubset<T, PoPrdCatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoPrdCats and returns the data updated in the database.
     * @param {PoPrdCatUpdateManyAndReturnArgs} args - Arguments to update many PoPrdCats.
     * @example
     * // Update many PoPrdCats
     * const poPrdCat = await prisma.poPrdCat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PoPrdCats and only return the `id`
     * const poPrdCatWithIdOnly = await prisma.poPrdCat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PoPrdCatUpdateManyAndReturnArgs>(args: SelectSubset<T, PoPrdCatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PoPrdCat.
     * @param {PoPrdCatUpsertArgs} args - Arguments to update or create a PoPrdCat.
     * @example
     * // Update or create a PoPrdCat
     * const poPrdCat = await prisma.poPrdCat.upsert({
     *   create: {
     *     // ... data to create a PoPrdCat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PoPrdCat we want to update
     *   }
     * })
     */
    upsert<T extends PoPrdCatUpsertArgs>(args: SelectSubset<T, PoPrdCatUpsertArgs<ExtArgs>>): Prisma__PoPrdCatClient<$Result.GetResult<Prisma.$PoPrdCatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PoPrdCats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoPrdCatCountArgs} args - Arguments to filter PoPrdCats to count.
     * @example
     * // Count the number of PoPrdCats
     * const count = await prisma.poPrdCat.count({
     *   where: {
     *     // ... the filter for the PoPrdCats we want to count
     *   }
     * })
    **/
    count<T extends PoPrdCatCountArgs>(
      args?: Subset<T, PoPrdCatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoPrdCatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PoPrdCat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoPrdCatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoPrdCatAggregateArgs>(args: Subset<T, PoPrdCatAggregateArgs>): Prisma.PrismaPromise<GetPoPrdCatAggregateType<T>>

    /**
     * Group by PoPrdCat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoPrdCatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PoPrdCatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PoPrdCatGroupByArgs['orderBy'] }
        : { orderBy?: PoPrdCatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PoPrdCatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoPrdCatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PoPrdCat model
   */
  readonly fields: PoPrdCatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PoPrdCat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PoPrdCatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PoPrdCat model
   */
  interface PoPrdCatFieldRefs {
    readonly id: FieldRef<"PoPrdCat", 'Int'>
    readonly category_name: FieldRef<"PoPrdCat", 'String'>
    readonly company_id: FieldRef<"PoPrdCat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PoPrdCat findUnique
   */
  export type PoPrdCatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * Filter, which PoPrdCat to fetch.
     */
    where: PoPrdCatWhereUniqueInput
  }

  /**
   * PoPrdCat findUniqueOrThrow
   */
  export type PoPrdCatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * Filter, which PoPrdCat to fetch.
     */
    where: PoPrdCatWhereUniqueInput
  }

  /**
   * PoPrdCat findFirst
   */
  export type PoPrdCatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * Filter, which PoPrdCat to fetch.
     */
    where?: PoPrdCatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoPrdCats to fetch.
     */
    orderBy?: PoPrdCatOrderByWithRelationInput | PoPrdCatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoPrdCats.
     */
    cursor?: PoPrdCatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoPrdCats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoPrdCats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoPrdCats.
     */
    distinct?: PoPrdCatScalarFieldEnum | PoPrdCatScalarFieldEnum[]
  }

  /**
   * PoPrdCat findFirstOrThrow
   */
  export type PoPrdCatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * Filter, which PoPrdCat to fetch.
     */
    where?: PoPrdCatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoPrdCats to fetch.
     */
    orderBy?: PoPrdCatOrderByWithRelationInput | PoPrdCatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoPrdCats.
     */
    cursor?: PoPrdCatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoPrdCats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoPrdCats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoPrdCats.
     */
    distinct?: PoPrdCatScalarFieldEnum | PoPrdCatScalarFieldEnum[]
  }

  /**
   * PoPrdCat findMany
   */
  export type PoPrdCatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * Filter, which PoPrdCats to fetch.
     */
    where?: PoPrdCatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoPrdCats to fetch.
     */
    orderBy?: PoPrdCatOrderByWithRelationInput | PoPrdCatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PoPrdCats.
     */
    cursor?: PoPrdCatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoPrdCats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoPrdCats.
     */
    skip?: number
    distinct?: PoPrdCatScalarFieldEnum | PoPrdCatScalarFieldEnum[]
  }

  /**
   * PoPrdCat create
   */
  export type PoPrdCatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * The data needed to create a PoPrdCat.
     */
    data: XOR<PoPrdCatCreateInput, PoPrdCatUncheckedCreateInput>
  }

  /**
   * PoPrdCat createMany
   */
  export type PoPrdCatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PoPrdCats.
     */
    data: PoPrdCatCreateManyInput | PoPrdCatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PoPrdCat createManyAndReturn
   */
  export type PoPrdCatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * The data used to create many PoPrdCats.
     */
    data: PoPrdCatCreateManyInput | PoPrdCatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PoPrdCat update
   */
  export type PoPrdCatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * The data needed to update a PoPrdCat.
     */
    data: XOR<PoPrdCatUpdateInput, PoPrdCatUncheckedUpdateInput>
    /**
     * Choose, which PoPrdCat to update.
     */
    where: PoPrdCatWhereUniqueInput
  }

  /**
   * PoPrdCat updateMany
   */
  export type PoPrdCatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PoPrdCats.
     */
    data: XOR<PoPrdCatUpdateManyMutationInput, PoPrdCatUncheckedUpdateManyInput>
    /**
     * Filter which PoPrdCats to update
     */
    where?: PoPrdCatWhereInput
    /**
     * Limit how many PoPrdCats to update.
     */
    limit?: number
  }

  /**
   * PoPrdCat updateManyAndReturn
   */
  export type PoPrdCatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * The data used to update PoPrdCats.
     */
    data: XOR<PoPrdCatUpdateManyMutationInput, PoPrdCatUncheckedUpdateManyInput>
    /**
     * Filter which PoPrdCats to update
     */
    where?: PoPrdCatWhereInput
    /**
     * Limit how many PoPrdCats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PoPrdCat upsert
   */
  export type PoPrdCatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * The filter to search for the PoPrdCat to update in case it exists.
     */
    where: PoPrdCatWhereUniqueInput
    /**
     * In case the PoPrdCat found by the `where` argument doesn't exist, create a new PoPrdCat with this data.
     */
    create: XOR<PoPrdCatCreateInput, PoPrdCatUncheckedCreateInput>
    /**
     * In case the PoPrdCat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PoPrdCatUpdateInput, PoPrdCatUncheckedUpdateInput>
  }

  /**
   * PoPrdCat delete
   */
  export type PoPrdCatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
    /**
     * Filter which PoPrdCat to delete.
     */
    where: PoPrdCatWhereUniqueInput
  }

  /**
   * PoPrdCat deleteMany
   */
  export type PoPrdCatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoPrdCats to delete
     */
    where?: PoPrdCatWhereInput
    /**
     * Limit how many PoPrdCats to delete.
     */
    limit?: number
  }

  /**
   * PoPrdCat without action
   */
  export type PoPrdCatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoPrdCat
     */
    select?: PoPrdCatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoPrdCat
     */
    omit?: PoPrdCatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoPrdCatInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryMode
   */

  export type AggregateDeliveryMode = {
    _count: DeliveryModeCountAggregateOutputType | null
    _avg: DeliveryModeAvgAggregateOutputType | null
    _sum: DeliveryModeSumAggregateOutputType | null
    _min: DeliveryModeMinAggregateOutputType | null
    _max: DeliveryModeMaxAggregateOutputType | null
  }

  export type DeliveryModeAvgAggregateOutputType = {
    id: number | null
    rate_kg: number | null
    company_id: number | null
  }

  export type DeliveryModeSumAggregateOutputType = {
    id: number | null
    rate_kg: number | null
    company_id: number | null
  }

  export type DeliveryModeMinAggregateOutputType = {
    id: number | null
    delivery_mode: string | null
    rate_kg: number | null
    company_id: number | null
  }

  export type DeliveryModeMaxAggregateOutputType = {
    id: number | null
    delivery_mode: string | null
    rate_kg: number | null
    company_id: number | null
  }

  export type DeliveryModeCountAggregateOutputType = {
    id: number
    delivery_mode: number
    rate_kg: number
    company_id: number
    _all: number
  }


  export type DeliveryModeAvgAggregateInputType = {
    id?: true
    rate_kg?: true
    company_id?: true
  }

  export type DeliveryModeSumAggregateInputType = {
    id?: true
    rate_kg?: true
    company_id?: true
  }

  export type DeliveryModeMinAggregateInputType = {
    id?: true
    delivery_mode?: true
    rate_kg?: true
    company_id?: true
  }

  export type DeliveryModeMaxAggregateInputType = {
    id?: true
    delivery_mode?: true
    rate_kg?: true
    company_id?: true
  }

  export type DeliveryModeCountAggregateInputType = {
    id?: true
    delivery_mode?: true
    rate_kg?: true
    company_id?: true
    _all?: true
  }

  export type DeliveryModeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryMode to aggregate.
     */
    where?: DeliveryModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryModes to fetch.
     */
    orderBy?: DeliveryModeOrderByWithRelationInput | DeliveryModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryModes
    **/
    _count?: true | DeliveryModeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryModeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryModeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryModeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryModeMaxAggregateInputType
  }

  export type GetDeliveryModeAggregateType<T extends DeliveryModeAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryMode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryMode[P]>
      : GetScalarType<T[P], AggregateDeliveryMode[P]>
  }




  export type DeliveryModeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryModeWhereInput
    orderBy?: DeliveryModeOrderByWithAggregationInput | DeliveryModeOrderByWithAggregationInput[]
    by: DeliveryModeScalarFieldEnum[] | DeliveryModeScalarFieldEnum
    having?: DeliveryModeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryModeCountAggregateInputType | true
    _avg?: DeliveryModeAvgAggregateInputType
    _sum?: DeliveryModeSumAggregateInputType
    _min?: DeliveryModeMinAggregateInputType
    _max?: DeliveryModeMaxAggregateInputType
  }

  export type DeliveryModeGroupByOutputType = {
    id: number
    delivery_mode: string
    rate_kg: number
    company_id: number
    _count: DeliveryModeCountAggregateOutputType | null
    _avg: DeliveryModeAvgAggregateOutputType | null
    _sum: DeliveryModeSumAggregateOutputType | null
    _min: DeliveryModeMinAggregateOutputType | null
    _max: DeliveryModeMaxAggregateOutputType | null
  }

  type GetDeliveryModeGroupByPayload<T extends DeliveryModeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryModeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryModeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryModeGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryModeGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryModeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_mode?: boolean
    rate_kg?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryMode"]>

  export type DeliveryModeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_mode?: boolean
    rate_kg?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryMode"]>

  export type DeliveryModeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_mode?: boolean
    rate_kg?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryMode"]>

  export type DeliveryModeSelectScalar = {
    id?: boolean
    delivery_mode?: boolean
    rate_kg?: boolean
    company_id?: boolean
  }

  export type DeliveryModeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "delivery_mode" | "rate_kg" | "company_id", ExtArgs["result"]["deliveryMode"]>
  export type DeliveryModeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DeliveryModeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DeliveryModeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DeliveryModePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryMode"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      delivery_mode: string
      rate_kg: number
      company_id: number
    }, ExtArgs["result"]["deliveryMode"]>
    composites: {}
  }

  type DeliveryModeGetPayload<S extends boolean | null | undefined | DeliveryModeDefaultArgs> = $Result.GetResult<Prisma.$DeliveryModePayload, S>

  type DeliveryModeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryModeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryModeCountAggregateInputType | true
    }

  export interface DeliveryModeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryMode'], meta: { name: 'DeliveryMode' } }
    /**
     * Find zero or one DeliveryMode that matches the filter.
     * @param {DeliveryModeFindUniqueArgs} args - Arguments to find a DeliveryMode
     * @example
     * // Get one DeliveryMode
     * const deliveryMode = await prisma.deliveryMode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryModeFindUniqueArgs>(args: SelectSubset<T, DeliveryModeFindUniqueArgs<ExtArgs>>): Prisma__DeliveryModeClient<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryMode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryModeFindUniqueOrThrowArgs} args - Arguments to find a DeliveryMode
     * @example
     * // Get one DeliveryMode
     * const deliveryMode = await prisma.deliveryMode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryModeFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryModeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryModeClient<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryMode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryModeFindFirstArgs} args - Arguments to find a DeliveryMode
     * @example
     * // Get one DeliveryMode
     * const deliveryMode = await prisma.deliveryMode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryModeFindFirstArgs>(args?: SelectSubset<T, DeliveryModeFindFirstArgs<ExtArgs>>): Prisma__DeliveryModeClient<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryMode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryModeFindFirstOrThrowArgs} args - Arguments to find a DeliveryMode
     * @example
     * // Get one DeliveryMode
     * const deliveryMode = await prisma.deliveryMode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryModeFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryModeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryModeClient<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryModes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryModeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryModes
     * const deliveryModes = await prisma.deliveryMode.findMany()
     * 
     * // Get first 10 DeliveryModes
     * const deliveryModes = await prisma.deliveryMode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryModeWithIdOnly = await prisma.deliveryMode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryModeFindManyArgs>(args?: SelectSubset<T, DeliveryModeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryMode.
     * @param {DeliveryModeCreateArgs} args - Arguments to create a DeliveryMode.
     * @example
     * // Create one DeliveryMode
     * const DeliveryMode = await prisma.deliveryMode.create({
     *   data: {
     *     // ... data to create a DeliveryMode
     *   }
     * })
     * 
     */
    create<T extends DeliveryModeCreateArgs>(args: SelectSubset<T, DeliveryModeCreateArgs<ExtArgs>>): Prisma__DeliveryModeClient<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryModes.
     * @param {DeliveryModeCreateManyArgs} args - Arguments to create many DeliveryModes.
     * @example
     * // Create many DeliveryModes
     * const deliveryMode = await prisma.deliveryMode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryModeCreateManyArgs>(args?: SelectSubset<T, DeliveryModeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryModes and returns the data saved in the database.
     * @param {DeliveryModeCreateManyAndReturnArgs} args - Arguments to create many DeliveryModes.
     * @example
     * // Create many DeliveryModes
     * const deliveryMode = await prisma.deliveryMode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryModes and only return the `id`
     * const deliveryModeWithIdOnly = await prisma.deliveryMode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryModeCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryModeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryMode.
     * @param {DeliveryModeDeleteArgs} args - Arguments to delete one DeliveryMode.
     * @example
     * // Delete one DeliveryMode
     * const DeliveryMode = await prisma.deliveryMode.delete({
     *   where: {
     *     // ... filter to delete one DeliveryMode
     *   }
     * })
     * 
     */
    delete<T extends DeliveryModeDeleteArgs>(args: SelectSubset<T, DeliveryModeDeleteArgs<ExtArgs>>): Prisma__DeliveryModeClient<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryMode.
     * @param {DeliveryModeUpdateArgs} args - Arguments to update one DeliveryMode.
     * @example
     * // Update one DeliveryMode
     * const deliveryMode = await prisma.deliveryMode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryModeUpdateArgs>(args: SelectSubset<T, DeliveryModeUpdateArgs<ExtArgs>>): Prisma__DeliveryModeClient<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryModes.
     * @param {DeliveryModeDeleteManyArgs} args - Arguments to filter DeliveryModes to delete.
     * @example
     * // Delete a few DeliveryModes
     * const { count } = await prisma.deliveryMode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryModeDeleteManyArgs>(args?: SelectSubset<T, DeliveryModeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryModes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryModeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryModes
     * const deliveryMode = await prisma.deliveryMode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryModeUpdateManyArgs>(args: SelectSubset<T, DeliveryModeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryModes and returns the data updated in the database.
     * @param {DeliveryModeUpdateManyAndReturnArgs} args - Arguments to update many DeliveryModes.
     * @example
     * // Update many DeliveryModes
     * const deliveryMode = await prisma.deliveryMode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryModes and only return the `id`
     * const deliveryModeWithIdOnly = await prisma.deliveryMode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryModeUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryModeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryMode.
     * @param {DeliveryModeUpsertArgs} args - Arguments to update or create a DeliveryMode.
     * @example
     * // Update or create a DeliveryMode
     * const deliveryMode = await prisma.deliveryMode.upsert({
     *   create: {
     *     // ... data to create a DeliveryMode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryMode we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryModeUpsertArgs>(args: SelectSubset<T, DeliveryModeUpsertArgs<ExtArgs>>): Prisma__DeliveryModeClient<$Result.GetResult<Prisma.$DeliveryModePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryModes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryModeCountArgs} args - Arguments to filter DeliveryModes to count.
     * @example
     * // Count the number of DeliveryModes
     * const count = await prisma.deliveryMode.count({
     *   where: {
     *     // ... the filter for the DeliveryModes we want to count
     *   }
     * })
    **/
    count<T extends DeliveryModeCountArgs>(
      args?: Subset<T, DeliveryModeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryModeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryMode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryModeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryModeAggregateArgs>(args: Subset<T, DeliveryModeAggregateArgs>): Prisma.PrismaPromise<GetDeliveryModeAggregateType<T>>

    /**
     * Group by DeliveryMode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryModeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryModeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryModeGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryModeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryModeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryModeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryMode model
   */
  readonly fields: DeliveryModeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryMode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryModeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryMode model
   */
  interface DeliveryModeFieldRefs {
    readonly id: FieldRef<"DeliveryMode", 'Int'>
    readonly delivery_mode: FieldRef<"DeliveryMode", 'String'>
    readonly rate_kg: FieldRef<"DeliveryMode", 'Int'>
    readonly company_id: FieldRef<"DeliveryMode", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryMode findUnique
   */
  export type DeliveryModeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMode to fetch.
     */
    where: DeliveryModeWhereUniqueInput
  }

  /**
   * DeliveryMode findUniqueOrThrow
   */
  export type DeliveryModeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMode to fetch.
     */
    where: DeliveryModeWhereUniqueInput
  }

  /**
   * DeliveryMode findFirst
   */
  export type DeliveryModeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMode to fetch.
     */
    where?: DeliveryModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryModes to fetch.
     */
    orderBy?: DeliveryModeOrderByWithRelationInput | DeliveryModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryModes.
     */
    cursor?: DeliveryModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryModes.
     */
    distinct?: DeliveryModeScalarFieldEnum | DeliveryModeScalarFieldEnum[]
  }

  /**
   * DeliveryMode findFirstOrThrow
   */
  export type DeliveryModeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMode to fetch.
     */
    where?: DeliveryModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryModes to fetch.
     */
    orderBy?: DeliveryModeOrderByWithRelationInput | DeliveryModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryModes.
     */
    cursor?: DeliveryModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryModes.
     */
    distinct?: DeliveryModeScalarFieldEnum | DeliveryModeScalarFieldEnum[]
  }

  /**
   * DeliveryMode findMany
   */
  export type DeliveryModeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryModes to fetch.
     */
    where?: DeliveryModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryModes to fetch.
     */
    orderBy?: DeliveryModeOrderByWithRelationInput | DeliveryModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryModes.
     */
    cursor?: DeliveryModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryModes.
     */
    skip?: number
    distinct?: DeliveryModeScalarFieldEnum | DeliveryModeScalarFieldEnum[]
  }

  /**
   * DeliveryMode create
   */
  export type DeliveryModeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryMode.
     */
    data: XOR<DeliveryModeCreateInput, DeliveryModeUncheckedCreateInput>
  }

  /**
   * DeliveryMode createMany
   */
  export type DeliveryModeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryModes.
     */
    data: DeliveryModeCreateManyInput | DeliveryModeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryMode createManyAndReturn
   */
  export type DeliveryModeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryModes.
     */
    data: DeliveryModeCreateManyInput | DeliveryModeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryMode update
   */
  export type DeliveryModeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryMode.
     */
    data: XOR<DeliveryModeUpdateInput, DeliveryModeUncheckedUpdateInput>
    /**
     * Choose, which DeliveryMode to update.
     */
    where: DeliveryModeWhereUniqueInput
  }

  /**
   * DeliveryMode updateMany
   */
  export type DeliveryModeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryModes.
     */
    data: XOR<DeliveryModeUpdateManyMutationInput, DeliveryModeUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryModes to update
     */
    where?: DeliveryModeWhereInput
    /**
     * Limit how many DeliveryModes to update.
     */
    limit?: number
  }

  /**
   * DeliveryMode updateManyAndReturn
   */
  export type DeliveryModeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryModes.
     */
    data: XOR<DeliveryModeUpdateManyMutationInput, DeliveryModeUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryModes to update
     */
    where?: DeliveryModeWhereInput
    /**
     * Limit how many DeliveryModes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryMode upsert
   */
  export type DeliveryModeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryMode to update in case it exists.
     */
    where: DeliveryModeWhereUniqueInput
    /**
     * In case the DeliveryMode found by the `where` argument doesn't exist, create a new DeliveryMode with this data.
     */
    create: XOR<DeliveryModeCreateInput, DeliveryModeUncheckedCreateInput>
    /**
     * In case the DeliveryMode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryModeUpdateInput, DeliveryModeUncheckedUpdateInput>
  }

  /**
   * DeliveryMode delete
   */
  export type DeliveryModeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
    /**
     * Filter which DeliveryMode to delete.
     */
    where: DeliveryModeWhereUniqueInput
  }

  /**
   * DeliveryMode deleteMany
   */
  export type DeliveryModeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryModes to delete
     */
    where?: DeliveryModeWhereInput
    /**
     * Limit how many DeliveryModes to delete.
     */
    limit?: number
  }

  /**
   * DeliveryMode without action
   */
  export type DeliveryModeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMode
     */
    select?: DeliveryModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMode
     */
    omit?: DeliveryModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryModeInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    company_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    company_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    user_id: string | null
    user_name: string | null
    company_id: number | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: string | null
    user_name: string | null
    company_id: number | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    user_name: number
    company_id: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    company_id?: true
  }

  export type UsersSumAggregateInputType = {
    company_id?: true
  }

  export type UsersMinAggregateInputType = {
    user_id?: true
    user_name?: true
    company_id?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    user_name?: true
    company_id?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    user_name?: true
    company_id?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: string
    user_name: string | null
    company_id: number
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    user_name?: boolean
    company_id?: boolean
    transactionsMaster?: boolean | Users$transactionsMasterArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    user_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    user_name?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    user_id?: boolean
    user_name?: boolean
    company_id?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "user_name" | "company_id", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionsMaster?: boolean | Users$transactionsMasterArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      transactionsMaster: Prisma.$TransactionsMasterPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      user_name: string | null
      company_id: number
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactionsMaster<T extends Users$transactionsMasterArgs<ExtArgs> = {}>(args?: Subset<T, Users$transactionsMasterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly user_id: FieldRef<"Users", 'String'>
    readonly user_name: FieldRef<"Users", 'String'>
    readonly company_id: FieldRef<"Users", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.transactionsMaster
   */
  export type Users$transactionsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    where?: TransactionsMasterWhereInput
    orderBy?: TransactionsMasterOrderByWithRelationInput | TransactionsMasterOrderByWithRelationInput[]
    cursor?: TransactionsMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsMasterScalarFieldEnum | TransactionsMasterScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    id: number | null
  }

  export type CurrencySumAggregateOutputType = {
    id: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: number | null
    currency: string | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: number | null
    currency: string | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    currency: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    id?: true
  }

  export type CurrencySumAggregateInputType = {
    id?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    currency?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    currency?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    currency?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: number
    currency: string
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency?: boolean
    transactions?: boolean | Currency$transactionsArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    currency?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currency", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Currency$transactionsArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      currency: string
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Currency$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'Int'>
    readonly currency: FieldRef<"Currency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency.transactions
   */
  export type Currency$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model TransactionsMaster
   */

  export type AggregateTransactionsMaster = {
    _count: TransactionsMasterCountAggregateOutputType | null
    _avg: TransactionsMasterAvgAggregateOutputType | null
    _sum: TransactionsMasterSumAggregateOutputType | null
    _min: TransactionsMasterMinAggregateOutputType | null
    _max: TransactionsMasterMaxAggregateOutputType | null
  }

  export type TransactionsMasterAvgAggregateOutputType = {
    tran_id: number | null
    company_id: number | null
    tran_code: number | null
    vr_no: number | null
    godown: number | null
    wc_order_id: number | null
  }

  export type TransactionsMasterSumAggregateOutputType = {
    tran_id: number | null
    company_id: number | null
    tran_code: number | null
    vr_no: number | null
    godown: number | null
    wc_order_id: number | null
  }

  export type TransactionsMasterMinAggregateOutputType = {
    tran_id: number | null
    company_id: number | null
    dateD: Date | null
    time: Date | null
    tran_code: number | null
    vr_no: number | null
    pycd: string | null
    check_no: string | null
    check_date: Date | null
    rmk: string | null
    rmk1: string | null
    rmk2: string | null
    rmk3: string | null
    rmk4: string | null
    rmk5: string | null
    userId: string | null
    invoice_no: string | null
    godown: number | null
    wc_order_id: number | null
    sync_status: string | null
    last_sync: Date | null
  }

  export type TransactionsMasterMaxAggregateOutputType = {
    tran_id: number | null
    company_id: number | null
    dateD: Date | null
    time: Date | null
    tran_code: number | null
    vr_no: number | null
    pycd: string | null
    check_no: string | null
    check_date: Date | null
    rmk: string | null
    rmk1: string | null
    rmk2: string | null
    rmk3: string | null
    rmk4: string | null
    rmk5: string | null
    userId: string | null
    invoice_no: string | null
    godown: number | null
    wc_order_id: number | null
    sync_status: string | null
    last_sync: Date | null
  }

  export type TransactionsMasterCountAggregateOutputType = {
    tran_id: number
    company_id: number
    dateD: number
    time: number
    tran_code: number
    vr_no: number
    pycd: number
    check_no: number
    check_date: number
    rmk: number
    rmk1: number
    rmk2: number
    rmk3: number
    rmk4: number
    rmk5: number
    userId: number
    invoice_no: number
    godown: number
    wc_order_id: number
    sync_status: number
    last_sync: number
    _all: number
  }


  export type TransactionsMasterAvgAggregateInputType = {
    tran_id?: true
    company_id?: true
    tran_code?: true
    vr_no?: true
    godown?: true
    wc_order_id?: true
  }

  export type TransactionsMasterSumAggregateInputType = {
    tran_id?: true
    company_id?: true
    tran_code?: true
    vr_no?: true
    godown?: true
    wc_order_id?: true
  }

  export type TransactionsMasterMinAggregateInputType = {
    tran_id?: true
    company_id?: true
    dateD?: true
    time?: true
    tran_code?: true
    vr_no?: true
    pycd?: true
    check_no?: true
    check_date?: true
    rmk?: true
    rmk1?: true
    rmk2?: true
    rmk3?: true
    rmk4?: true
    rmk5?: true
    userId?: true
    invoice_no?: true
    godown?: true
    wc_order_id?: true
    sync_status?: true
    last_sync?: true
  }

  export type TransactionsMasterMaxAggregateInputType = {
    tran_id?: true
    company_id?: true
    dateD?: true
    time?: true
    tran_code?: true
    vr_no?: true
    pycd?: true
    check_no?: true
    check_date?: true
    rmk?: true
    rmk1?: true
    rmk2?: true
    rmk3?: true
    rmk4?: true
    rmk5?: true
    userId?: true
    invoice_no?: true
    godown?: true
    wc_order_id?: true
    sync_status?: true
    last_sync?: true
  }

  export type TransactionsMasterCountAggregateInputType = {
    tran_id?: true
    company_id?: true
    dateD?: true
    time?: true
    tran_code?: true
    vr_no?: true
    pycd?: true
    check_no?: true
    check_date?: true
    rmk?: true
    rmk1?: true
    rmk2?: true
    rmk3?: true
    rmk4?: true
    rmk5?: true
    userId?: true
    invoice_no?: true
    godown?: true
    wc_order_id?: true
    sync_status?: true
    last_sync?: true
    _all?: true
  }

  export type TransactionsMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionsMaster to aggregate.
     */
    where?: TransactionsMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionsMasters to fetch.
     */
    orderBy?: TransactionsMasterOrderByWithRelationInput | TransactionsMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionsMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionsMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionsMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionsMasters
    **/
    _count?: true | TransactionsMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMasterMaxAggregateInputType
  }

  export type GetTransactionsMasterAggregateType<T extends TransactionsMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionsMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionsMaster[P]>
      : GetScalarType<T[P], AggregateTransactionsMaster[P]>
  }




  export type TransactionsMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsMasterWhereInput
    orderBy?: TransactionsMasterOrderByWithAggregationInput | TransactionsMasterOrderByWithAggregationInput[]
    by: TransactionsMasterScalarFieldEnum[] | TransactionsMasterScalarFieldEnum
    having?: TransactionsMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsMasterCountAggregateInputType | true
    _avg?: TransactionsMasterAvgAggregateInputType
    _sum?: TransactionsMasterSumAggregateInputType
    _min?: TransactionsMasterMinAggregateInputType
    _max?: TransactionsMasterMaxAggregateInputType
  }

  export type TransactionsMasterGroupByOutputType = {
    tran_id: number
    company_id: number | null
    dateD: Date | null
    time: Date | null
    tran_code: number | null
    vr_no: number | null
    pycd: string | null
    check_no: string | null
    check_date: Date | null
    rmk: string | null
    rmk1: string | null
    rmk2: string | null
    rmk3: string | null
    rmk4: string | null
    rmk5: string | null
    userId: string | null
    invoice_no: string | null
    godown: number | null
    wc_order_id: number | null
    sync_status: string | null
    last_sync: Date | null
    _count: TransactionsMasterCountAggregateOutputType | null
    _avg: TransactionsMasterAvgAggregateOutputType | null
    _sum: TransactionsMasterSumAggregateOutputType | null
    _min: TransactionsMasterMinAggregateOutputType | null
    _max: TransactionsMasterMaxAggregateOutputType | null
  }

  type GetTransactionsMasterGroupByPayload<T extends TransactionsMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsMasterGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsMasterGroupByOutputType[P]>
        }
      >
    >


  export type TransactionsMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tran_id?: boolean
    company_id?: boolean
    dateD?: boolean
    time?: boolean
    tran_code?: boolean
    vr_no?: boolean
    pycd?: boolean
    check_no?: boolean
    check_date?: boolean
    rmk?: boolean
    rmk1?: boolean
    rmk2?: boolean
    rmk3?: boolean
    rmk4?: boolean
    rmk5?: boolean
    userId?: boolean
    invoice_no?: boolean
    godown?: boolean
    wc_order_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    user?: boolean | TransactionsMaster$userArgs<ExtArgs>
    company?: boolean | TransactionsMaster$companyArgs<ExtArgs>
    godownDetails?: boolean | TransactionsMaster$godownDetailsArgs<ExtArgs>
    acno?: boolean | TransactionsMaster$acnoArgs<ExtArgs>
    transactions?: boolean | TransactionsMaster$transactionsArgs<ExtArgs>
    _count?: boolean | TransactionsMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionsMaster"]>

  export type TransactionsMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tran_id?: boolean
    company_id?: boolean
    dateD?: boolean
    time?: boolean
    tran_code?: boolean
    vr_no?: boolean
    pycd?: boolean
    check_no?: boolean
    check_date?: boolean
    rmk?: boolean
    rmk1?: boolean
    rmk2?: boolean
    rmk3?: boolean
    rmk4?: boolean
    rmk5?: boolean
    userId?: boolean
    invoice_no?: boolean
    godown?: boolean
    wc_order_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    user?: boolean | TransactionsMaster$userArgs<ExtArgs>
    company?: boolean | TransactionsMaster$companyArgs<ExtArgs>
    godownDetails?: boolean | TransactionsMaster$godownDetailsArgs<ExtArgs>
    acno?: boolean | TransactionsMaster$acnoArgs<ExtArgs>
  }, ExtArgs["result"]["transactionsMaster"]>

  export type TransactionsMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tran_id?: boolean
    company_id?: boolean
    dateD?: boolean
    time?: boolean
    tran_code?: boolean
    vr_no?: boolean
    pycd?: boolean
    check_no?: boolean
    check_date?: boolean
    rmk?: boolean
    rmk1?: boolean
    rmk2?: boolean
    rmk3?: boolean
    rmk4?: boolean
    rmk5?: boolean
    userId?: boolean
    invoice_no?: boolean
    godown?: boolean
    wc_order_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
    user?: boolean | TransactionsMaster$userArgs<ExtArgs>
    company?: boolean | TransactionsMaster$companyArgs<ExtArgs>
    godownDetails?: boolean | TransactionsMaster$godownDetailsArgs<ExtArgs>
    acno?: boolean | TransactionsMaster$acnoArgs<ExtArgs>
  }, ExtArgs["result"]["transactionsMaster"]>

  export type TransactionsMasterSelectScalar = {
    tran_id?: boolean
    company_id?: boolean
    dateD?: boolean
    time?: boolean
    tran_code?: boolean
    vr_no?: boolean
    pycd?: boolean
    check_no?: boolean
    check_date?: boolean
    rmk?: boolean
    rmk1?: boolean
    rmk2?: boolean
    rmk3?: boolean
    rmk4?: boolean
    rmk5?: boolean
    userId?: boolean
    invoice_no?: boolean
    godown?: boolean
    wc_order_id?: boolean
    sync_status?: boolean
    last_sync?: boolean
  }

  export type TransactionsMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tran_id" | "company_id" | "dateD" | "time" | "tran_code" | "vr_no" | "pycd" | "check_no" | "check_date" | "rmk" | "rmk1" | "rmk2" | "rmk3" | "rmk4" | "rmk5" | "userId" | "invoice_no" | "godown" | "wc_order_id" | "sync_status" | "last_sync", ExtArgs["result"]["transactionsMaster"]>
  export type TransactionsMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | TransactionsMaster$userArgs<ExtArgs>
    company?: boolean | TransactionsMaster$companyArgs<ExtArgs>
    godownDetails?: boolean | TransactionsMaster$godownDetailsArgs<ExtArgs>
    acno?: boolean | TransactionsMaster$acnoArgs<ExtArgs>
    transactions?: boolean | TransactionsMaster$transactionsArgs<ExtArgs>
    _count?: boolean | TransactionsMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionsMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | TransactionsMaster$userArgs<ExtArgs>
    company?: boolean | TransactionsMaster$companyArgs<ExtArgs>
    godownDetails?: boolean | TransactionsMaster$godownDetailsArgs<ExtArgs>
    acno?: boolean | TransactionsMaster$acnoArgs<ExtArgs>
  }
  export type TransactionsMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | TransactionsMaster$userArgs<ExtArgs>
    company?: boolean | TransactionsMaster$companyArgs<ExtArgs>
    godownDetails?: boolean | TransactionsMaster$godownDetailsArgs<ExtArgs>
    acno?: boolean | TransactionsMaster$acnoArgs<ExtArgs>
  }

  export type $TransactionsMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionsMaster"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
      godownDetails: Prisma.$GodownPayload<ExtArgs> | null
      acno: Prisma.$ACNOPayload<ExtArgs> | null
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tran_id: number
      company_id: number | null
      dateD: Date | null
      time: Date | null
      tran_code: number | null
      vr_no: number | null
      pycd: string | null
      check_no: string | null
      check_date: Date | null
      rmk: string | null
      rmk1: string | null
      rmk2: string | null
      rmk3: string | null
      rmk4: string | null
      rmk5: string | null
      userId: string | null
      invoice_no: string | null
      godown: number | null
      wc_order_id: number | null
      sync_status: string | null
      last_sync: Date | null
    }, ExtArgs["result"]["transactionsMaster"]>
    composites: {}
  }

  type TransactionsMasterGetPayload<S extends boolean | null | undefined | TransactionsMasterDefaultArgs> = $Result.GetResult<Prisma.$TransactionsMasterPayload, S>

  type TransactionsMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionsMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsMasterCountAggregateInputType | true
    }

  export interface TransactionsMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionsMaster'], meta: { name: 'TransactionsMaster' } }
    /**
     * Find zero or one TransactionsMaster that matches the filter.
     * @param {TransactionsMasterFindUniqueArgs} args - Arguments to find a TransactionsMaster
     * @example
     * // Get one TransactionsMaster
     * const transactionsMaster = await prisma.transactionsMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionsMasterFindUniqueArgs>(args: SelectSubset<T, TransactionsMasterFindUniqueArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionsMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionsMasterFindUniqueOrThrowArgs} args - Arguments to find a TransactionsMaster
     * @example
     * // Get one TransactionsMaster
     * const transactionsMaster = await prisma.transactionsMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionsMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionsMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionsMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsMasterFindFirstArgs} args - Arguments to find a TransactionsMaster
     * @example
     * // Get one TransactionsMaster
     * const transactionsMaster = await prisma.transactionsMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionsMasterFindFirstArgs>(args?: SelectSubset<T, TransactionsMasterFindFirstArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionsMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsMasterFindFirstOrThrowArgs} args - Arguments to find a TransactionsMaster
     * @example
     * // Get one TransactionsMaster
     * const transactionsMaster = await prisma.transactionsMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionsMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionsMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionsMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionsMasters
     * const transactionsMasters = await prisma.transactionsMaster.findMany()
     * 
     * // Get first 10 TransactionsMasters
     * const transactionsMasters = await prisma.transactionsMaster.findMany({ take: 10 })
     * 
     * // Only select the `tran_id`
     * const transactionsMasterWithTran_idOnly = await prisma.transactionsMaster.findMany({ select: { tran_id: true } })
     * 
     */
    findMany<T extends TransactionsMasterFindManyArgs>(args?: SelectSubset<T, TransactionsMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionsMaster.
     * @param {TransactionsMasterCreateArgs} args - Arguments to create a TransactionsMaster.
     * @example
     * // Create one TransactionsMaster
     * const TransactionsMaster = await prisma.transactionsMaster.create({
     *   data: {
     *     // ... data to create a TransactionsMaster
     *   }
     * })
     * 
     */
    create<T extends TransactionsMasterCreateArgs>(args: SelectSubset<T, TransactionsMasterCreateArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionsMasters.
     * @param {TransactionsMasterCreateManyArgs} args - Arguments to create many TransactionsMasters.
     * @example
     * // Create many TransactionsMasters
     * const transactionsMaster = await prisma.transactionsMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionsMasterCreateManyArgs>(args?: SelectSubset<T, TransactionsMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionsMasters and returns the data saved in the database.
     * @param {TransactionsMasterCreateManyAndReturnArgs} args - Arguments to create many TransactionsMasters.
     * @example
     * // Create many TransactionsMasters
     * const transactionsMaster = await prisma.transactionsMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionsMasters and only return the `tran_id`
     * const transactionsMasterWithTran_idOnly = await prisma.transactionsMaster.createManyAndReturn({
     *   select: { tran_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionsMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionsMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionsMaster.
     * @param {TransactionsMasterDeleteArgs} args - Arguments to delete one TransactionsMaster.
     * @example
     * // Delete one TransactionsMaster
     * const TransactionsMaster = await prisma.transactionsMaster.delete({
     *   where: {
     *     // ... filter to delete one TransactionsMaster
     *   }
     * })
     * 
     */
    delete<T extends TransactionsMasterDeleteArgs>(args: SelectSubset<T, TransactionsMasterDeleteArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionsMaster.
     * @param {TransactionsMasterUpdateArgs} args - Arguments to update one TransactionsMaster.
     * @example
     * // Update one TransactionsMaster
     * const transactionsMaster = await prisma.transactionsMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionsMasterUpdateArgs>(args: SelectSubset<T, TransactionsMasterUpdateArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionsMasters.
     * @param {TransactionsMasterDeleteManyArgs} args - Arguments to filter TransactionsMasters to delete.
     * @example
     * // Delete a few TransactionsMasters
     * const { count } = await prisma.transactionsMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionsMasterDeleteManyArgs>(args?: SelectSubset<T, TransactionsMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionsMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionsMasters
     * const transactionsMaster = await prisma.transactionsMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionsMasterUpdateManyArgs>(args: SelectSubset<T, TransactionsMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionsMasters and returns the data updated in the database.
     * @param {TransactionsMasterUpdateManyAndReturnArgs} args - Arguments to update many TransactionsMasters.
     * @example
     * // Update many TransactionsMasters
     * const transactionsMaster = await prisma.transactionsMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionsMasters and only return the `tran_id`
     * const transactionsMasterWithTran_idOnly = await prisma.transactionsMaster.updateManyAndReturn({
     *   select: { tran_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionsMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionsMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionsMaster.
     * @param {TransactionsMasterUpsertArgs} args - Arguments to update or create a TransactionsMaster.
     * @example
     * // Update or create a TransactionsMaster
     * const transactionsMaster = await prisma.transactionsMaster.upsert({
     *   create: {
     *     // ... data to create a TransactionsMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionsMaster we want to update
     *   }
     * })
     */
    upsert<T extends TransactionsMasterUpsertArgs>(args: SelectSubset<T, TransactionsMasterUpsertArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionsMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsMasterCountArgs} args - Arguments to filter TransactionsMasters to count.
     * @example
     * // Count the number of TransactionsMasters
     * const count = await prisma.transactionsMaster.count({
     *   where: {
     *     // ... the filter for the TransactionsMasters we want to count
     *   }
     * })
    **/
    count<T extends TransactionsMasterCountArgs>(
      args?: Subset<T, TransactionsMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionsMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsMasterAggregateArgs>(args: Subset<T, TransactionsMasterAggregateArgs>): Prisma.PrismaPromise<GetTransactionsMasterAggregateType<T>>

    /**
     * Group by TransactionsMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionsMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionsMasterGroupByArgs['orderBy'] }
        : { orderBy?: TransactionsMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionsMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionsMaster model
   */
  readonly fields: TransactionsMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionsMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionsMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends TransactionsMaster$userArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsMaster$userArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends TransactionsMaster$companyArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsMaster$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    godownDetails<T extends TransactionsMaster$godownDetailsArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsMaster$godownDetailsArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    acno<T extends TransactionsMaster$acnoArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsMaster$acnoArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends TransactionsMaster$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsMaster$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionsMaster model
   */
  interface TransactionsMasterFieldRefs {
    readonly tran_id: FieldRef<"TransactionsMaster", 'Int'>
    readonly company_id: FieldRef<"TransactionsMaster", 'Int'>
    readonly dateD: FieldRef<"TransactionsMaster", 'DateTime'>
    readonly time: FieldRef<"TransactionsMaster", 'DateTime'>
    readonly tran_code: FieldRef<"TransactionsMaster", 'Int'>
    readonly vr_no: FieldRef<"TransactionsMaster", 'Int'>
    readonly pycd: FieldRef<"TransactionsMaster", 'String'>
    readonly check_no: FieldRef<"TransactionsMaster", 'String'>
    readonly check_date: FieldRef<"TransactionsMaster", 'DateTime'>
    readonly rmk: FieldRef<"TransactionsMaster", 'String'>
    readonly rmk1: FieldRef<"TransactionsMaster", 'String'>
    readonly rmk2: FieldRef<"TransactionsMaster", 'String'>
    readonly rmk3: FieldRef<"TransactionsMaster", 'String'>
    readonly rmk4: FieldRef<"TransactionsMaster", 'String'>
    readonly rmk5: FieldRef<"TransactionsMaster", 'String'>
    readonly userId: FieldRef<"TransactionsMaster", 'String'>
    readonly invoice_no: FieldRef<"TransactionsMaster", 'String'>
    readonly godown: FieldRef<"TransactionsMaster", 'Int'>
    readonly wc_order_id: FieldRef<"TransactionsMaster", 'Int'>
    readonly sync_status: FieldRef<"TransactionsMaster", 'String'>
    readonly last_sync: FieldRef<"TransactionsMaster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionsMaster findUnique
   */
  export type TransactionsMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * Filter, which TransactionsMaster to fetch.
     */
    where: TransactionsMasterWhereUniqueInput
  }

  /**
   * TransactionsMaster findUniqueOrThrow
   */
  export type TransactionsMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * Filter, which TransactionsMaster to fetch.
     */
    where: TransactionsMasterWhereUniqueInput
  }

  /**
   * TransactionsMaster findFirst
   */
  export type TransactionsMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * Filter, which TransactionsMaster to fetch.
     */
    where?: TransactionsMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionsMasters to fetch.
     */
    orderBy?: TransactionsMasterOrderByWithRelationInput | TransactionsMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionsMasters.
     */
    cursor?: TransactionsMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionsMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionsMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionsMasters.
     */
    distinct?: TransactionsMasterScalarFieldEnum | TransactionsMasterScalarFieldEnum[]
  }

  /**
   * TransactionsMaster findFirstOrThrow
   */
  export type TransactionsMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * Filter, which TransactionsMaster to fetch.
     */
    where?: TransactionsMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionsMasters to fetch.
     */
    orderBy?: TransactionsMasterOrderByWithRelationInput | TransactionsMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionsMasters.
     */
    cursor?: TransactionsMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionsMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionsMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionsMasters.
     */
    distinct?: TransactionsMasterScalarFieldEnum | TransactionsMasterScalarFieldEnum[]
  }

  /**
   * TransactionsMaster findMany
   */
  export type TransactionsMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * Filter, which TransactionsMasters to fetch.
     */
    where?: TransactionsMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionsMasters to fetch.
     */
    orderBy?: TransactionsMasterOrderByWithRelationInput | TransactionsMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionsMasters.
     */
    cursor?: TransactionsMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionsMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionsMasters.
     */
    skip?: number
    distinct?: TransactionsMasterScalarFieldEnum | TransactionsMasterScalarFieldEnum[]
  }

  /**
   * TransactionsMaster create
   */
  export type TransactionsMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionsMaster.
     */
    data?: XOR<TransactionsMasterCreateInput, TransactionsMasterUncheckedCreateInput>
  }

  /**
   * TransactionsMaster createMany
   */
  export type TransactionsMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionsMasters.
     */
    data: TransactionsMasterCreateManyInput | TransactionsMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionsMaster createManyAndReturn
   */
  export type TransactionsMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionsMasters.
     */
    data: TransactionsMasterCreateManyInput | TransactionsMasterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionsMaster update
   */
  export type TransactionsMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionsMaster.
     */
    data: XOR<TransactionsMasterUpdateInput, TransactionsMasterUncheckedUpdateInput>
    /**
     * Choose, which TransactionsMaster to update.
     */
    where: TransactionsMasterWhereUniqueInput
  }

  /**
   * TransactionsMaster updateMany
   */
  export type TransactionsMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionsMasters.
     */
    data: XOR<TransactionsMasterUpdateManyMutationInput, TransactionsMasterUncheckedUpdateManyInput>
    /**
     * Filter which TransactionsMasters to update
     */
    where?: TransactionsMasterWhereInput
    /**
     * Limit how many TransactionsMasters to update.
     */
    limit?: number
  }

  /**
   * TransactionsMaster updateManyAndReturn
   */
  export type TransactionsMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * The data used to update TransactionsMasters.
     */
    data: XOR<TransactionsMasterUpdateManyMutationInput, TransactionsMasterUncheckedUpdateManyInput>
    /**
     * Filter which TransactionsMasters to update
     */
    where?: TransactionsMasterWhereInput
    /**
     * Limit how many TransactionsMasters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionsMaster upsert
   */
  export type TransactionsMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionsMaster to update in case it exists.
     */
    where: TransactionsMasterWhereUniqueInput
    /**
     * In case the TransactionsMaster found by the `where` argument doesn't exist, create a new TransactionsMaster with this data.
     */
    create: XOR<TransactionsMasterCreateInput, TransactionsMasterUncheckedCreateInput>
    /**
     * In case the TransactionsMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionsMasterUpdateInput, TransactionsMasterUncheckedUpdateInput>
  }

  /**
   * TransactionsMaster delete
   */
  export type TransactionsMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
    /**
     * Filter which TransactionsMaster to delete.
     */
    where: TransactionsMasterWhereUniqueInput
  }

  /**
   * TransactionsMaster deleteMany
   */
  export type TransactionsMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionsMasters to delete
     */
    where?: TransactionsMasterWhereInput
    /**
     * Limit how many TransactionsMasters to delete.
     */
    limit?: number
  }

  /**
   * TransactionsMaster.user
   */
  export type TransactionsMaster$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * TransactionsMaster.company
   */
  export type TransactionsMaster$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * TransactionsMaster.godownDetails
   */
  export type TransactionsMaster$godownDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    where?: GodownWhereInput
  }

  /**
   * TransactionsMaster.acno
   */
  export type TransactionsMaster$acnoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    where?: ACNOWhereInput
  }

  /**
   * TransactionsMaster.transactions
   */
  export type TransactionsMaster$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * TransactionsMaster without action
   */
  export type TransactionsMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsMaster
     */
    select?: TransactionsMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionsMaster
     */
    omit?: TransactionsMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsMasterInclude<ExtArgs> | null
  }


  /**
   * Model Transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    id: number | null
    tran_id: number | null
    itcd: number | null
    ccno: number | null
    damt: number | null
    camt: number | null
    qty: number | null
    rate: number | null
    wht_rate: number | null
    st_rate: number | null
    godown: number | null
    sub_tran_id: number | null
    currency: number | null
    gross_amount: number | null
    fc_amount: number | null
    no_of_pack: number | null
    qty_per_pack: number | null
    st_amount: number | null
    additional_tax: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    id: number | null
    tran_id: number | null
    itcd: number | null
    ccno: number | null
    damt: number | null
    camt: number | null
    qty: number | null
    rate: number | null
    wht_rate: number | null
    st_rate: number | null
    godown: number | null
    sub_tran_id: number | null
    currency: number | null
    gross_amount: number | null
    fc_amount: number | null
    no_of_pack: number | null
    qty_per_pack: number | null
    st_amount: number | null
    additional_tax: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: number | null
    tran_id: number | null
    acno: string | null
    itcd: number | null
    ccno: number | null
    narration1: string | null
    narration2: string | null
    narration3: string | null
    narration4: string | null
    narration5: string | null
    chno: string | null
    check_date: Date | null
    party_name: string | null
    damt: number | null
    camt: number | null
    qty: number | null
    rate: number | null
    wht_rate: number | null
    st_rate: number | null
    godown: number | null
    invoice_no: string | null
    sub_tran_id: number | null
    currency: number | null
    gross_amount: number | null
    fc_amount: number | null
    no_of_pack: number | null
    qty_per_pack: number | null
    st_amount: number | null
    additional_tax: number | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: number | null
    tran_id: number | null
    acno: string | null
    itcd: number | null
    ccno: number | null
    narration1: string | null
    narration2: string | null
    narration3: string | null
    narration4: string | null
    narration5: string | null
    chno: string | null
    check_date: Date | null
    party_name: string | null
    damt: number | null
    camt: number | null
    qty: number | null
    rate: number | null
    wht_rate: number | null
    st_rate: number | null
    godown: number | null
    invoice_no: string | null
    sub_tran_id: number | null
    currency: number | null
    gross_amount: number | null
    fc_amount: number | null
    no_of_pack: number | null
    qty_per_pack: number | null
    st_amount: number | null
    additional_tax: number | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    tran_id: number
    acno: number
    itcd: number
    ccno: number
    narration1: number
    narration2: number
    narration3: number
    narration4: number
    narration5: number
    chno: number
    check_date: number
    party_name: number
    damt: number
    camt: number
    qty: number
    rate: number
    wht_rate: number
    st_rate: number
    godown: number
    invoice_no: number
    sub_tran_id: number
    currency: number
    gross_amount: number
    fc_amount: number
    no_of_pack: number
    qty_per_pack: number
    st_amount: number
    additional_tax: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    id?: true
    tran_id?: true
    itcd?: true
    ccno?: true
    damt?: true
    camt?: true
    qty?: true
    rate?: true
    wht_rate?: true
    st_rate?: true
    godown?: true
    sub_tran_id?: true
    currency?: true
    gross_amount?: true
    fc_amount?: true
    no_of_pack?: true
    qty_per_pack?: true
    st_amount?: true
    additional_tax?: true
  }

  export type TransactionsSumAggregateInputType = {
    id?: true
    tran_id?: true
    itcd?: true
    ccno?: true
    damt?: true
    camt?: true
    qty?: true
    rate?: true
    wht_rate?: true
    st_rate?: true
    godown?: true
    sub_tran_id?: true
    currency?: true
    gross_amount?: true
    fc_amount?: true
    no_of_pack?: true
    qty_per_pack?: true
    st_amount?: true
    additional_tax?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    tran_id?: true
    acno?: true
    itcd?: true
    ccno?: true
    narration1?: true
    narration2?: true
    narration3?: true
    narration4?: true
    narration5?: true
    chno?: true
    check_date?: true
    party_name?: true
    damt?: true
    camt?: true
    qty?: true
    rate?: true
    wht_rate?: true
    st_rate?: true
    godown?: true
    invoice_no?: true
    sub_tran_id?: true
    currency?: true
    gross_amount?: true
    fc_amount?: true
    no_of_pack?: true
    qty_per_pack?: true
    st_amount?: true
    additional_tax?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    tran_id?: true
    acno?: true
    itcd?: true
    ccno?: true
    narration1?: true
    narration2?: true
    narration3?: true
    narration4?: true
    narration5?: true
    chno?: true
    check_date?: true
    party_name?: true
    damt?: true
    camt?: true
    qty?: true
    rate?: true
    wht_rate?: true
    st_rate?: true
    godown?: true
    invoice_no?: true
    sub_tran_id?: true
    currency?: true
    gross_amount?: true
    fc_amount?: true
    no_of_pack?: true
    qty_per_pack?: true
    st_amount?: true
    additional_tax?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    tran_id?: true
    acno?: true
    itcd?: true
    ccno?: true
    narration1?: true
    narration2?: true
    narration3?: true
    narration4?: true
    narration5?: true
    chno?: true
    check_date?: true
    party_name?: true
    damt?: true
    camt?: true
    qty?: true
    rate?: true
    wht_rate?: true
    st_rate?: true
    godown?: true
    invoice_no?: true
    sub_tran_id?: true
    currency?: true
    gross_amount?: true
    fc_amount?: true
    no_of_pack?: true
    qty_per_pack?: true
    st_amount?: true
    additional_tax?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to aggregate.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type TransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithAggregationInput | TransactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: TransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: number
    tran_id: number
    acno: string | null
    itcd: number | null
    ccno: number | null
    narration1: string | null
    narration2: string | null
    narration3: string | null
    narration4: string | null
    narration5: string | null
    chno: string | null
    check_date: Date | null
    party_name: string | null
    damt: number | null
    camt: number | null
    qty: number | null
    rate: number | null
    wht_rate: number | null
    st_rate: number | null
    godown: number | null
    invoice_no: string | null
    sub_tran_id: number | null
    currency: number | null
    gross_amount: number | null
    fc_amount: number | null
    no_of_pack: number | null
    qty_per_pack: number | null
    st_amount: number | null
    additional_tax: number | null
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends TransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type TransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tran_id?: boolean
    acno?: boolean
    itcd?: boolean
    ccno?: boolean
    narration1?: boolean
    narration2?: boolean
    narration3?: boolean
    narration4?: boolean
    narration5?: boolean
    chno?: boolean
    check_date?: boolean
    party_name?: boolean
    damt?: boolean
    camt?: boolean
    qty?: boolean
    rate?: boolean
    wht_rate?: boolean
    st_rate?: boolean
    godown?: boolean
    invoice_no?: boolean
    sub_tran_id?: boolean
    currency?: boolean
    gross_amount?: boolean
    fc_amount?: boolean
    no_of_pack?: boolean
    qty_per_pack?: boolean
    st_amount?: boolean
    additional_tax?: boolean
    acnoDetails?: boolean | Transactions$acnoDetailsArgs<ExtArgs>
    costCenter?: boolean | Transactions$costCenterArgs<ExtArgs>
    currencyDetails?: boolean | Transactions$currencyDetailsArgs<ExtArgs>
    godownDetails?: boolean | Transactions$godownDetailsArgs<ExtArgs>
    itemDetails?: boolean | Transactions$itemDetailsArgs<ExtArgs>
    transactionsMaster?: boolean | TransactionsMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tran_id?: boolean
    acno?: boolean
    itcd?: boolean
    ccno?: boolean
    narration1?: boolean
    narration2?: boolean
    narration3?: boolean
    narration4?: boolean
    narration5?: boolean
    chno?: boolean
    check_date?: boolean
    party_name?: boolean
    damt?: boolean
    camt?: boolean
    qty?: boolean
    rate?: boolean
    wht_rate?: boolean
    st_rate?: boolean
    godown?: boolean
    invoice_no?: boolean
    sub_tran_id?: boolean
    currency?: boolean
    gross_amount?: boolean
    fc_amount?: boolean
    no_of_pack?: boolean
    qty_per_pack?: boolean
    st_amount?: boolean
    additional_tax?: boolean
    acnoDetails?: boolean | Transactions$acnoDetailsArgs<ExtArgs>
    costCenter?: boolean | Transactions$costCenterArgs<ExtArgs>
    currencyDetails?: boolean | Transactions$currencyDetailsArgs<ExtArgs>
    godownDetails?: boolean | Transactions$godownDetailsArgs<ExtArgs>
    itemDetails?: boolean | Transactions$itemDetailsArgs<ExtArgs>
    transactionsMaster?: boolean | TransactionsMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tran_id?: boolean
    acno?: boolean
    itcd?: boolean
    ccno?: boolean
    narration1?: boolean
    narration2?: boolean
    narration3?: boolean
    narration4?: boolean
    narration5?: boolean
    chno?: boolean
    check_date?: boolean
    party_name?: boolean
    damt?: boolean
    camt?: boolean
    qty?: boolean
    rate?: boolean
    wht_rate?: boolean
    st_rate?: boolean
    godown?: boolean
    invoice_no?: boolean
    sub_tran_id?: boolean
    currency?: boolean
    gross_amount?: boolean
    fc_amount?: boolean
    no_of_pack?: boolean
    qty_per_pack?: boolean
    st_amount?: boolean
    additional_tax?: boolean
    acnoDetails?: boolean | Transactions$acnoDetailsArgs<ExtArgs>
    costCenter?: boolean | Transactions$costCenterArgs<ExtArgs>
    currencyDetails?: boolean | Transactions$currencyDetailsArgs<ExtArgs>
    godownDetails?: boolean | Transactions$godownDetailsArgs<ExtArgs>
    itemDetails?: boolean | Transactions$itemDetailsArgs<ExtArgs>
    transactionsMaster?: boolean | TransactionsMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectScalar = {
    id?: boolean
    tran_id?: boolean
    acno?: boolean
    itcd?: boolean
    ccno?: boolean
    narration1?: boolean
    narration2?: boolean
    narration3?: boolean
    narration4?: boolean
    narration5?: boolean
    chno?: boolean
    check_date?: boolean
    party_name?: boolean
    damt?: boolean
    camt?: boolean
    qty?: boolean
    rate?: boolean
    wht_rate?: boolean
    st_rate?: boolean
    godown?: boolean
    invoice_no?: boolean
    sub_tran_id?: boolean
    currency?: boolean
    gross_amount?: boolean
    fc_amount?: boolean
    no_of_pack?: boolean
    qty_per_pack?: boolean
    st_amount?: boolean
    additional_tax?: boolean
  }

  export type TransactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tran_id" | "acno" | "itcd" | "ccno" | "narration1" | "narration2" | "narration3" | "narration4" | "narration5" | "chno" | "check_date" | "party_name" | "damt" | "camt" | "qty" | "rate" | "wht_rate" | "st_rate" | "godown" | "invoice_no" | "sub_tran_id" | "currency" | "gross_amount" | "fc_amount" | "no_of_pack" | "qty_per_pack" | "st_amount" | "additional_tax", ExtArgs["result"]["transactions"]>
  export type TransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acnoDetails?: boolean | Transactions$acnoDetailsArgs<ExtArgs>
    costCenter?: boolean | Transactions$costCenterArgs<ExtArgs>
    currencyDetails?: boolean | Transactions$currencyDetailsArgs<ExtArgs>
    godownDetails?: boolean | Transactions$godownDetailsArgs<ExtArgs>
    itemDetails?: boolean | Transactions$itemDetailsArgs<ExtArgs>
    transactionsMaster?: boolean | TransactionsMasterDefaultArgs<ExtArgs>
  }
  export type TransactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acnoDetails?: boolean | Transactions$acnoDetailsArgs<ExtArgs>
    costCenter?: boolean | Transactions$costCenterArgs<ExtArgs>
    currencyDetails?: boolean | Transactions$currencyDetailsArgs<ExtArgs>
    godownDetails?: boolean | Transactions$godownDetailsArgs<ExtArgs>
    itemDetails?: boolean | Transactions$itemDetailsArgs<ExtArgs>
    transactionsMaster?: boolean | TransactionsMasterDefaultArgs<ExtArgs>
  }
  export type TransactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acnoDetails?: boolean | Transactions$acnoDetailsArgs<ExtArgs>
    costCenter?: boolean | Transactions$costCenterArgs<ExtArgs>
    currencyDetails?: boolean | Transactions$currencyDetailsArgs<ExtArgs>
    godownDetails?: boolean | Transactions$godownDetailsArgs<ExtArgs>
    itemDetails?: boolean | Transactions$itemDetailsArgs<ExtArgs>
    transactionsMaster?: boolean | TransactionsMasterDefaultArgs<ExtArgs>
  }

  export type $TransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transactions"
    objects: {
      acnoDetails: Prisma.$ACNOPayload<ExtArgs> | null
      costCenter: Prisma.$CostCenterPayload<ExtArgs> | null
      currencyDetails: Prisma.$CurrencyPayload<ExtArgs> | null
      godownDetails: Prisma.$GodownPayload<ExtArgs> | null
      itemDetails: Prisma.$ItemPayload<ExtArgs> | null
      transactionsMaster: Prisma.$TransactionsMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tran_id: number
      acno: string | null
      itcd: number | null
      ccno: number | null
      narration1: string | null
      narration2: string | null
      narration3: string | null
      narration4: string | null
      narration5: string | null
      chno: string | null
      check_date: Date | null
      party_name: string | null
      damt: number | null
      camt: number | null
      qty: number | null
      rate: number | null
      wht_rate: number | null
      st_rate: number | null
      godown: number | null
      invoice_no: string | null
      sub_tran_id: number | null
      currency: number | null
      gross_amount: number | null
      fc_amount: number | null
      no_of_pack: number | null
      qty_per_pack: number | null
      st_amount: number | null
      additional_tax: number | null
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type TransactionsGetPayload<S extends boolean | null | undefined | TransactionsDefaultArgs> = $Result.GetResult<Prisma.$TransactionsPayload, S>

  type TransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface TransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transactions'], meta: { name: 'Transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {TransactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionsFindUniqueArgs>(args: SelectSubset<T, TransactionsFindUniqueArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionsFindFirstArgs>(args?: SelectSubset<T, TransactionsFindFirstArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionsFindManyArgs>(args?: SelectSubset<T, TransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {TransactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends TransactionsCreateArgs>(args: SelectSubset<T, TransactionsCreateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionsCreateManyArgs>(args?: SelectSubset<T, TransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionsCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transactions.
     * @param {TransactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends TransactionsDeleteArgs>(args: SelectSubset<T, TransactionsDeleteArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {TransactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionsUpdateArgs>(args: SelectSubset<T, TransactionsUpdateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionsDeleteManyArgs>(args?: SelectSubset<T, TransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionsUpdateManyArgs>(args: SelectSubset<T, TransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionsUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transactions.
     * @param {TransactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends TransactionsUpsertArgs>(args: SelectSubset<T, TransactionsUpsertArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionsCountArgs>(
      args?: Subset<T, TransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionsGroupByArgs['orderBy'] }
        : { orderBy?: TransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transactions model
   */
  readonly fields: TransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    acnoDetails<T extends Transactions$acnoDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$acnoDetailsArgs<ExtArgs>>): Prisma__ACNOClient<$Result.GetResult<Prisma.$ACNOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    costCenter<T extends Transactions$costCenterArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$costCenterArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currencyDetails<T extends Transactions$currencyDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$currencyDetailsArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    godownDetails<T extends Transactions$godownDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$godownDetailsArgs<ExtArgs>>): Prisma__GodownClient<$Result.GetResult<Prisma.$GodownPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemDetails<T extends Transactions$itemDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$itemDetailsArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactionsMaster<T extends TransactionsMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsMasterDefaultArgs<ExtArgs>>): Prisma__TransactionsMasterClient<$Result.GetResult<Prisma.$TransactionsMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transactions model
   */
  interface TransactionsFieldRefs {
    readonly id: FieldRef<"Transactions", 'Int'>
    readonly tran_id: FieldRef<"Transactions", 'Int'>
    readonly acno: FieldRef<"Transactions", 'String'>
    readonly itcd: FieldRef<"Transactions", 'Int'>
    readonly ccno: FieldRef<"Transactions", 'Int'>
    readonly narration1: FieldRef<"Transactions", 'String'>
    readonly narration2: FieldRef<"Transactions", 'String'>
    readonly narration3: FieldRef<"Transactions", 'String'>
    readonly narration4: FieldRef<"Transactions", 'String'>
    readonly narration5: FieldRef<"Transactions", 'String'>
    readonly chno: FieldRef<"Transactions", 'String'>
    readonly check_date: FieldRef<"Transactions", 'DateTime'>
    readonly party_name: FieldRef<"Transactions", 'String'>
    readonly damt: FieldRef<"Transactions", 'Float'>
    readonly camt: FieldRef<"Transactions", 'Float'>
    readonly qty: FieldRef<"Transactions", 'Float'>
    readonly rate: FieldRef<"Transactions", 'Float'>
    readonly wht_rate: FieldRef<"Transactions", 'Float'>
    readonly st_rate: FieldRef<"Transactions", 'Float'>
    readonly godown: FieldRef<"Transactions", 'Int'>
    readonly invoice_no: FieldRef<"Transactions", 'String'>
    readonly sub_tran_id: FieldRef<"Transactions", 'Int'>
    readonly currency: FieldRef<"Transactions", 'Int'>
    readonly gross_amount: FieldRef<"Transactions", 'Float'>
    readonly fc_amount: FieldRef<"Transactions", 'Float'>
    readonly no_of_pack: FieldRef<"Transactions", 'Float'>
    readonly qty_per_pack: FieldRef<"Transactions", 'Float'>
    readonly st_amount: FieldRef<"Transactions", 'Float'>
    readonly additional_tax: FieldRef<"Transactions", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Transactions findUnique
   */
  export type TransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findUniqueOrThrow
   */
  export type TransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findFirst
   */
  export type TransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findFirstOrThrow
   */
  export type TransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findMany
   */
  export type TransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions create
   */
  export type TransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Transactions.
     */
    data: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
  }

  /**
   * Transactions createMany
   */
  export type TransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transactions createManyAndReturn
   */
  export type TransactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions update
   */
  export type TransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Transactions.
     */
    data: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
    /**
     * Choose, which Transactions to update.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions updateMany
   */
  export type TransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transactions updateManyAndReturn
   */
  export type TransactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions upsert
   */
  export type TransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Transactions to update in case it exists.
     */
    where: TransactionsWhereUniqueInput
    /**
     * In case the Transactions found by the `where` argument doesn't exist, create a new Transactions with this data.
     */
    create: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
    /**
     * In case the Transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
  }

  /**
   * Transactions delete
   */
  export type TransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter which Transactions to delete.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions deleteMany
   */
  export type TransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transactions.acnoDetails
   */
  export type Transactions$acnoDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACNO
     */
    select?: ACNOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ACNO
     */
    omit?: ACNOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACNOInclude<ExtArgs> | null
    where?: ACNOWhereInput
  }

  /**
   * Transactions.costCenter
   */
  export type Transactions$costCenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCenter
     */
    omit?: CostCenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    where?: CostCenterWhereInput
  }

  /**
   * Transactions.currencyDetails
   */
  export type Transactions$currencyDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
  }

  /**
   * Transactions.godownDetails
   */
  export type Transactions$godownDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Godown
     */
    select?: GodownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Godown
     */
    omit?: GodownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GodownInclude<ExtArgs> | null
    where?: GodownWhereInput
  }

  /**
   * Transactions.itemDetails
   */
  export type Transactions$itemDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Transactions without action
   */
  export type TransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryTerm
   */

  export type AggregateDeliveryTerm = {
    _count: DeliveryTermCountAggregateOutputType | null
    _avg: DeliveryTermAvgAggregateOutputType | null
    _sum: DeliveryTermSumAggregateOutputType | null
    _min: DeliveryTermMinAggregateOutputType | null
    _max: DeliveryTermMaxAggregateOutputType | null
  }

  export type DeliveryTermAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type DeliveryTermSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type DeliveryTermMinAggregateOutputType = {
    id: number | null
    delivery_term: string | null
    company_id: number | null
  }

  export type DeliveryTermMaxAggregateOutputType = {
    id: number | null
    delivery_term: string | null
    company_id: number | null
  }

  export type DeliveryTermCountAggregateOutputType = {
    id: number
    delivery_term: number
    company_id: number
    _all: number
  }


  export type DeliveryTermAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type DeliveryTermSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type DeliveryTermMinAggregateInputType = {
    id?: true
    delivery_term?: true
    company_id?: true
  }

  export type DeliveryTermMaxAggregateInputType = {
    id?: true
    delivery_term?: true
    company_id?: true
  }

  export type DeliveryTermCountAggregateInputType = {
    id?: true
    delivery_term?: true
    company_id?: true
    _all?: true
  }

  export type DeliveryTermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTerm to aggregate.
     */
    where?: DeliveryTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTerms to fetch.
     */
    orderBy?: DeliveryTermOrderByWithRelationInput | DeliveryTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryTerms
    **/
    _count?: true | DeliveryTermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryTermAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryTermSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryTermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryTermMaxAggregateInputType
  }

  export type GetDeliveryTermAggregateType<T extends DeliveryTermAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryTerm[P]>
      : GetScalarType<T[P], AggregateDeliveryTerm[P]>
  }




  export type DeliveryTermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTermWhereInput
    orderBy?: DeliveryTermOrderByWithAggregationInput | DeliveryTermOrderByWithAggregationInput[]
    by: DeliveryTermScalarFieldEnum[] | DeliveryTermScalarFieldEnum
    having?: DeliveryTermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryTermCountAggregateInputType | true
    _avg?: DeliveryTermAvgAggregateInputType
    _sum?: DeliveryTermSumAggregateInputType
    _min?: DeliveryTermMinAggregateInputType
    _max?: DeliveryTermMaxAggregateInputType
  }

  export type DeliveryTermGroupByOutputType = {
    id: number
    delivery_term: string
    company_id: number
    _count: DeliveryTermCountAggregateOutputType | null
    _avg: DeliveryTermAvgAggregateOutputType | null
    _sum: DeliveryTermSumAggregateOutputType | null
    _min: DeliveryTermMinAggregateOutputType | null
    _max: DeliveryTermMaxAggregateOutputType | null
  }

  type GetDeliveryTermGroupByPayload<T extends DeliveryTermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryTermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryTermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryTermGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryTermGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryTermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_term?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTerm"]>

  export type DeliveryTermSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_term?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTerm"]>

  export type DeliveryTermSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_term?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTerm"]>

  export type DeliveryTermSelectScalar = {
    id?: boolean
    delivery_term?: boolean
    company_id?: boolean
  }

  export type DeliveryTermOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "delivery_term" | "company_id", ExtArgs["result"]["deliveryTerm"]>
  export type DeliveryTermInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DeliveryTermIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DeliveryTermIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DeliveryTermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryTerm"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      delivery_term: string
      company_id: number
    }, ExtArgs["result"]["deliveryTerm"]>
    composites: {}
  }

  type DeliveryTermGetPayload<S extends boolean | null | undefined | DeliveryTermDefaultArgs> = $Result.GetResult<Prisma.$DeliveryTermPayload, S>

  type DeliveryTermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryTermFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryTermCountAggregateInputType | true
    }

  export interface DeliveryTermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryTerm'], meta: { name: 'DeliveryTerm' } }
    /**
     * Find zero or one DeliveryTerm that matches the filter.
     * @param {DeliveryTermFindUniqueArgs} args - Arguments to find a DeliveryTerm
     * @example
     * // Get one DeliveryTerm
     * const deliveryTerm = await prisma.deliveryTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryTermFindUniqueArgs>(args: SelectSubset<T, DeliveryTermFindUniqueArgs<ExtArgs>>): Prisma__DeliveryTermClient<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryTerm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryTermFindUniqueOrThrowArgs} args - Arguments to find a DeliveryTerm
     * @example
     * // Get one DeliveryTerm
     * const deliveryTerm = await prisma.deliveryTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryTermFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryTermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryTermClient<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTermFindFirstArgs} args - Arguments to find a DeliveryTerm
     * @example
     * // Get one DeliveryTerm
     * const deliveryTerm = await prisma.deliveryTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryTermFindFirstArgs>(args?: SelectSubset<T, DeliveryTermFindFirstArgs<ExtArgs>>): Prisma__DeliveryTermClient<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTermFindFirstOrThrowArgs} args - Arguments to find a DeliveryTerm
     * @example
     * // Get one DeliveryTerm
     * const deliveryTerm = await prisma.deliveryTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryTermFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryTermFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryTermClient<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryTerms
     * const deliveryTerms = await prisma.deliveryTerm.findMany()
     * 
     * // Get first 10 DeliveryTerms
     * const deliveryTerms = await prisma.deliveryTerm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryTermWithIdOnly = await prisma.deliveryTerm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryTermFindManyArgs>(args?: SelectSubset<T, DeliveryTermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryTerm.
     * @param {DeliveryTermCreateArgs} args - Arguments to create a DeliveryTerm.
     * @example
     * // Create one DeliveryTerm
     * const DeliveryTerm = await prisma.deliveryTerm.create({
     *   data: {
     *     // ... data to create a DeliveryTerm
     *   }
     * })
     * 
     */
    create<T extends DeliveryTermCreateArgs>(args: SelectSubset<T, DeliveryTermCreateArgs<ExtArgs>>): Prisma__DeliveryTermClient<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryTerms.
     * @param {DeliveryTermCreateManyArgs} args - Arguments to create many DeliveryTerms.
     * @example
     * // Create many DeliveryTerms
     * const deliveryTerm = await prisma.deliveryTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryTermCreateManyArgs>(args?: SelectSubset<T, DeliveryTermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryTerms and returns the data saved in the database.
     * @param {DeliveryTermCreateManyAndReturnArgs} args - Arguments to create many DeliveryTerms.
     * @example
     * // Create many DeliveryTerms
     * const deliveryTerm = await prisma.deliveryTerm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryTerms and only return the `id`
     * const deliveryTermWithIdOnly = await prisma.deliveryTerm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryTermCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryTermCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryTerm.
     * @param {DeliveryTermDeleteArgs} args - Arguments to delete one DeliveryTerm.
     * @example
     * // Delete one DeliveryTerm
     * const DeliveryTerm = await prisma.deliveryTerm.delete({
     *   where: {
     *     // ... filter to delete one DeliveryTerm
     *   }
     * })
     * 
     */
    delete<T extends DeliveryTermDeleteArgs>(args: SelectSubset<T, DeliveryTermDeleteArgs<ExtArgs>>): Prisma__DeliveryTermClient<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryTerm.
     * @param {DeliveryTermUpdateArgs} args - Arguments to update one DeliveryTerm.
     * @example
     * // Update one DeliveryTerm
     * const deliveryTerm = await prisma.deliveryTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryTermUpdateArgs>(args: SelectSubset<T, DeliveryTermUpdateArgs<ExtArgs>>): Prisma__DeliveryTermClient<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryTerms.
     * @param {DeliveryTermDeleteManyArgs} args - Arguments to filter DeliveryTerms to delete.
     * @example
     * // Delete a few DeliveryTerms
     * const { count } = await prisma.deliveryTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryTermDeleteManyArgs>(args?: SelectSubset<T, DeliveryTermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryTerms
     * const deliveryTerm = await prisma.deliveryTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryTermUpdateManyArgs>(args: SelectSubset<T, DeliveryTermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTerms and returns the data updated in the database.
     * @param {DeliveryTermUpdateManyAndReturnArgs} args - Arguments to update many DeliveryTerms.
     * @example
     * // Update many DeliveryTerms
     * const deliveryTerm = await prisma.deliveryTerm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryTerms and only return the `id`
     * const deliveryTermWithIdOnly = await prisma.deliveryTerm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryTermUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryTermUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryTerm.
     * @param {DeliveryTermUpsertArgs} args - Arguments to update or create a DeliveryTerm.
     * @example
     * // Update or create a DeliveryTerm
     * const deliveryTerm = await prisma.deliveryTerm.upsert({
     *   create: {
     *     // ... data to create a DeliveryTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryTerm we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryTermUpsertArgs>(args: SelectSubset<T, DeliveryTermUpsertArgs<ExtArgs>>): Prisma__DeliveryTermClient<$Result.GetResult<Prisma.$DeliveryTermPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTermCountArgs} args - Arguments to filter DeliveryTerms to count.
     * @example
     * // Count the number of DeliveryTerms
     * const count = await prisma.deliveryTerm.count({
     *   where: {
     *     // ... the filter for the DeliveryTerms we want to count
     *   }
     * })
    **/
    count<T extends DeliveryTermCountArgs>(
      args?: Subset<T, DeliveryTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryTermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryTermAggregateArgs>(args: Subset<T, DeliveryTermAggregateArgs>): Prisma.PrismaPromise<GetDeliveryTermAggregateType<T>>

    /**
     * Group by DeliveryTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryTermGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryTermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryTermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryTerm model
   */
  readonly fields: DeliveryTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryTermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryTerm model
   */
  interface DeliveryTermFieldRefs {
    readonly id: FieldRef<"DeliveryTerm", 'Int'>
    readonly delivery_term: FieldRef<"DeliveryTerm", 'String'>
    readonly company_id: FieldRef<"DeliveryTerm", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryTerm findUnique
   */
  export type DeliveryTermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTerm to fetch.
     */
    where: DeliveryTermWhereUniqueInput
  }

  /**
   * DeliveryTerm findUniqueOrThrow
   */
  export type DeliveryTermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTerm to fetch.
     */
    where: DeliveryTermWhereUniqueInput
  }

  /**
   * DeliveryTerm findFirst
   */
  export type DeliveryTermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTerm to fetch.
     */
    where?: DeliveryTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTerms to fetch.
     */
    orderBy?: DeliveryTermOrderByWithRelationInput | DeliveryTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTerms.
     */
    cursor?: DeliveryTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTerms.
     */
    distinct?: DeliveryTermScalarFieldEnum | DeliveryTermScalarFieldEnum[]
  }

  /**
   * DeliveryTerm findFirstOrThrow
   */
  export type DeliveryTermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTerm to fetch.
     */
    where?: DeliveryTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTerms to fetch.
     */
    orderBy?: DeliveryTermOrderByWithRelationInput | DeliveryTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTerms.
     */
    cursor?: DeliveryTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTerms.
     */
    distinct?: DeliveryTermScalarFieldEnum | DeliveryTermScalarFieldEnum[]
  }

  /**
   * DeliveryTerm findMany
   */
  export type DeliveryTermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTerms to fetch.
     */
    where?: DeliveryTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTerms to fetch.
     */
    orderBy?: DeliveryTermOrderByWithRelationInput | DeliveryTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryTerms.
     */
    cursor?: DeliveryTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTerms.
     */
    skip?: number
    distinct?: DeliveryTermScalarFieldEnum | DeliveryTermScalarFieldEnum[]
  }

  /**
   * DeliveryTerm create
   */
  export type DeliveryTermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryTerm.
     */
    data: XOR<DeliveryTermCreateInput, DeliveryTermUncheckedCreateInput>
  }

  /**
   * DeliveryTerm createMany
   */
  export type DeliveryTermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryTerms.
     */
    data: DeliveryTermCreateManyInput | DeliveryTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryTerm createManyAndReturn
   */
  export type DeliveryTermCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryTerms.
     */
    data: DeliveryTermCreateManyInput | DeliveryTermCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryTerm update
   */
  export type DeliveryTermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryTerm.
     */
    data: XOR<DeliveryTermUpdateInput, DeliveryTermUncheckedUpdateInput>
    /**
     * Choose, which DeliveryTerm to update.
     */
    where: DeliveryTermWhereUniqueInput
  }

  /**
   * DeliveryTerm updateMany
   */
  export type DeliveryTermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryTerms.
     */
    data: XOR<DeliveryTermUpdateManyMutationInput, DeliveryTermUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTerms to update
     */
    where?: DeliveryTermWhereInput
    /**
     * Limit how many DeliveryTerms to update.
     */
    limit?: number
  }

  /**
   * DeliveryTerm updateManyAndReturn
   */
  export type DeliveryTermUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryTerms.
     */
    data: XOR<DeliveryTermUpdateManyMutationInput, DeliveryTermUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTerms to update
     */
    where?: DeliveryTermWhereInput
    /**
     * Limit how many DeliveryTerms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryTerm upsert
   */
  export type DeliveryTermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryTerm to update in case it exists.
     */
    where: DeliveryTermWhereUniqueInput
    /**
     * In case the DeliveryTerm found by the `where` argument doesn't exist, create a new DeliveryTerm with this data.
     */
    create: XOR<DeliveryTermCreateInput, DeliveryTermUncheckedCreateInput>
    /**
     * In case the DeliveryTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryTermUpdateInput, DeliveryTermUncheckedUpdateInput>
  }

  /**
   * DeliveryTerm delete
   */
  export type DeliveryTermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
    /**
     * Filter which DeliveryTerm to delete.
     */
    where: DeliveryTermWhereUniqueInput
  }

  /**
   * DeliveryTerm deleteMany
   */
  export type DeliveryTermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTerms to delete
     */
    where?: DeliveryTermWhereInput
    /**
     * Limit how many DeliveryTerms to delete.
     */
    limit?: number
  }

  /**
   * DeliveryTerm without action
   */
  export type DeliveryTermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTerm
     */
    select?: DeliveryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTerm
     */
    omit?: DeliveryTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTermInclude<ExtArgs> | null
  }


  /**
   * Model CommissionTerm
   */

  export type AggregateCommissionTerm = {
    _count: CommissionTermCountAggregateOutputType | null
    _avg: CommissionTermAvgAggregateOutputType | null
    _sum: CommissionTermSumAggregateOutputType | null
    _min: CommissionTermMinAggregateOutputType | null
    _max: CommissionTermMaxAggregateOutputType | null
  }

  export type CommissionTermAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type CommissionTermSumAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type CommissionTermMinAggregateOutputType = {
    id: number | null
    commission_term: string | null
    company_id: number | null
  }

  export type CommissionTermMaxAggregateOutputType = {
    id: number | null
    commission_term: string | null
    company_id: number | null
  }

  export type CommissionTermCountAggregateOutputType = {
    id: number
    commission_term: number
    company_id: number
    _all: number
  }


  export type CommissionTermAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type CommissionTermSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type CommissionTermMinAggregateInputType = {
    id?: true
    commission_term?: true
    company_id?: true
  }

  export type CommissionTermMaxAggregateInputType = {
    id?: true
    commission_term?: true
    company_id?: true
  }

  export type CommissionTermCountAggregateInputType = {
    id?: true
    commission_term?: true
    company_id?: true
    _all?: true
  }

  export type CommissionTermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionTerm to aggregate.
     */
    where?: CommissionTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionTerms to fetch.
     */
    orderBy?: CommissionTermOrderByWithRelationInput | CommissionTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommissionTerms
    **/
    _count?: true | CommissionTermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionTermAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionTermSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionTermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionTermMaxAggregateInputType
  }

  export type GetCommissionTermAggregateType<T extends CommissionTermAggregateArgs> = {
        [P in keyof T & keyof AggregateCommissionTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommissionTerm[P]>
      : GetScalarType<T[P], AggregateCommissionTerm[P]>
  }




  export type CommissionTermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionTermWhereInput
    orderBy?: CommissionTermOrderByWithAggregationInput | CommissionTermOrderByWithAggregationInput[]
    by: CommissionTermScalarFieldEnum[] | CommissionTermScalarFieldEnum
    having?: CommissionTermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionTermCountAggregateInputType | true
    _avg?: CommissionTermAvgAggregateInputType
    _sum?: CommissionTermSumAggregateInputType
    _min?: CommissionTermMinAggregateInputType
    _max?: CommissionTermMaxAggregateInputType
  }

  export type CommissionTermGroupByOutputType = {
    id: number
    commission_term: string
    company_id: number
    _count: CommissionTermCountAggregateOutputType | null
    _avg: CommissionTermAvgAggregateOutputType | null
    _sum: CommissionTermSumAggregateOutputType | null
    _min: CommissionTermMinAggregateOutputType | null
    _max: CommissionTermMaxAggregateOutputType | null
  }

  type GetCommissionTermGroupByPayload<T extends CommissionTermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionTermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionTermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionTermGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionTermGroupByOutputType[P]>
        }
      >
    >


  export type CommissionTermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commission_term?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionTerm"]>

  export type CommissionTermSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commission_term?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionTerm"]>

  export type CommissionTermSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commission_term?: boolean
    company_id?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionTerm"]>

  export type CommissionTermSelectScalar = {
    id?: boolean
    commission_term?: boolean
    company_id?: boolean
  }

  export type CommissionTermOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commission_term" | "company_id", ExtArgs["result"]["commissionTerm"]>
  export type CommissionTermInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CommissionTermIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CommissionTermIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CommissionTermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommissionTerm"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commission_term: string
      company_id: number
    }, ExtArgs["result"]["commissionTerm"]>
    composites: {}
  }

  type CommissionTermGetPayload<S extends boolean | null | undefined | CommissionTermDefaultArgs> = $Result.GetResult<Prisma.$CommissionTermPayload, S>

  type CommissionTermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommissionTermFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommissionTermCountAggregateInputType | true
    }

  export interface CommissionTermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommissionTerm'], meta: { name: 'CommissionTerm' } }
    /**
     * Find zero or one CommissionTerm that matches the filter.
     * @param {CommissionTermFindUniqueArgs} args - Arguments to find a CommissionTerm
     * @example
     * // Get one CommissionTerm
     * const commissionTerm = await prisma.commissionTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionTermFindUniqueArgs>(args: SelectSubset<T, CommissionTermFindUniqueArgs<ExtArgs>>): Prisma__CommissionTermClient<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommissionTerm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommissionTermFindUniqueOrThrowArgs} args - Arguments to find a CommissionTerm
     * @example
     * // Get one CommissionTerm
     * const commissionTerm = await prisma.commissionTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionTermFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionTermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionTermClient<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommissionTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionTermFindFirstArgs} args - Arguments to find a CommissionTerm
     * @example
     * // Get one CommissionTerm
     * const commissionTerm = await prisma.commissionTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionTermFindFirstArgs>(args?: SelectSubset<T, CommissionTermFindFirstArgs<ExtArgs>>): Prisma__CommissionTermClient<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommissionTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionTermFindFirstOrThrowArgs} args - Arguments to find a CommissionTerm
     * @example
     * // Get one CommissionTerm
     * const commissionTerm = await prisma.commissionTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionTermFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionTermFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionTermClient<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommissionTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommissionTerms
     * const commissionTerms = await prisma.commissionTerm.findMany()
     * 
     * // Get first 10 CommissionTerms
     * const commissionTerms = await prisma.commissionTerm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionTermWithIdOnly = await prisma.commissionTerm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionTermFindManyArgs>(args?: SelectSubset<T, CommissionTermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommissionTerm.
     * @param {CommissionTermCreateArgs} args - Arguments to create a CommissionTerm.
     * @example
     * // Create one CommissionTerm
     * const CommissionTerm = await prisma.commissionTerm.create({
     *   data: {
     *     // ... data to create a CommissionTerm
     *   }
     * })
     * 
     */
    create<T extends CommissionTermCreateArgs>(args: SelectSubset<T, CommissionTermCreateArgs<ExtArgs>>): Prisma__CommissionTermClient<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommissionTerms.
     * @param {CommissionTermCreateManyArgs} args - Arguments to create many CommissionTerms.
     * @example
     * // Create many CommissionTerms
     * const commissionTerm = await prisma.commissionTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionTermCreateManyArgs>(args?: SelectSubset<T, CommissionTermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommissionTerms and returns the data saved in the database.
     * @param {CommissionTermCreateManyAndReturnArgs} args - Arguments to create many CommissionTerms.
     * @example
     * // Create many CommissionTerms
     * const commissionTerm = await prisma.commissionTerm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommissionTerms and only return the `id`
     * const commissionTermWithIdOnly = await prisma.commissionTerm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionTermCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionTermCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommissionTerm.
     * @param {CommissionTermDeleteArgs} args - Arguments to delete one CommissionTerm.
     * @example
     * // Delete one CommissionTerm
     * const CommissionTerm = await prisma.commissionTerm.delete({
     *   where: {
     *     // ... filter to delete one CommissionTerm
     *   }
     * })
     * 
     */
    delete<T extends CommissionTermDeleteArgs>(args: SelectSubset<T, CommissionTermDeleteArgs<ExtArgs>>): Prisma__CommissionTermClient<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommissionTerm.
     * @param {CommissionTermUpdateArgs} args - Arguments to update one CommissionTerm.
     * @example
     * // Update one CommissionTerm
     * const commissionTerm = await prisma.commissionTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionTermUpdateArgs>(args: SelectSubset<T, CommissionTermUpdateArgs<ExtArgs>>): Prisma__CommissionTermClient<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommissionTerms.
     * @param {CommissionTermDeleteManyArgs} args - Arguments to filter CommissionTerms to delete.
     * @example
     * // Delete a few CommissionTerms
     * const { count } = await prisma.commissionTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionTermDeleteManyArgs>(args?: SelectSubset<T, CommissionTermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommissionTerms
     * const commissionTerm = await prisma.commissionTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionTermUpdateManyArgs>(args: SelectSubset<T, CommissionTermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionTerms and returns the data updated in the database.
     * @param {CommissionTermUpdateManyAndReturnArgs} args - Arguments to update many CommissionTerms.
     * @example
     * // Update many CommissionTerms
     * const commissionTerm = await prisma.commissionTerm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommissionTerms and only return the `id`
     * const commissionTermWithIdOnly = await prisma.commissionTerm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommissionTermUpdateManyAndReturnArgs>(args: SelectSubset<T, CommissionTermUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommissionTerm.
     * @param {CommissionTermUpsertArgs} args - Arguments to update or create a CommissionTerm.
     * @example
     * // Update or create a CommissionTerm
     * const commissionTerm = await prisma.commissionTerm.upsert({
     *   create: {
     *     // ... data to create a CommissionTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommissionTerm we want to update
     *   }
     * })
     */
    upsert<T extends CommissionTermUpsertArgs>(args: SelectSubset<T, CommissionTermUpsertArgs<ExtArgs>>): Prisma__CommissionTermClient<$Result.GetResult<Prisma.$CommissionTermPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommissionTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionTermCountArgs} args - Arguments to filter CommissionTerms to count.
     * @example
     * // Count the number of CommissionTerms
     * const count = await prisma.commissionTerm.count({
     *   where: {
     *     // ... the filter for the CommissionTerms we want to count
     *   }
     * })
    **/
    count<T extends CommissionTermCountArgs>(
      args?: Subset<T, CommissionTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionTermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommissionTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionTermAggregateArgs>(args: Subset<T, CommissionTermAggregateArgs>): Prisma.PrismaPromise<GetCommissionTermAggregateType<T>>

    /**
     * Group by CommissionTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionTermGroupByArgs['orderBy'] }
        : { orderBy?: CommissionTermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionTermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommissionTerm model
   */
  readonly fields: CommissionTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommissionTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionTermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommissionTerm model
   */
  interface CommissionTermFieldRefs {
    readonly id: FieldRef<"CommissionTerm", 'Int'>
    readonly commission_term: FieldRef<"CommissionTerm", 'String'>
    readonly company_id: FieldRef<"CommissionTerm", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CommissionTerm findUnique
   */
  export type CommissionTermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * Filter, which CommissionTerm to fetch.
     */
    where: CommissionTermWhereUniqueInput
  }

  /**
   * CommissionTerm findUniqueOrThrow
   */
  export type CommissionTermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * Filter, which CommissionTerm to fetch.
     */
    where: CommissionTermWhereUniqueInput
  }

  /**
   * CommissionTerm findFirst
   */
  export type CommissionTermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * Filter, which CommissionTerm to fetch.
     */
    where?: CommissionTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionTerms to fetch.
     */
    orderBy?: CommissionTermOrderByWithRelationInput | CommissionTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionTerms.
     */
    cursor?: CommissionTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionTerms.
     */
    distinct?: CommissionTermScalarFieldEnum | CommissionTermScalarFieldEnum[]
  }

  /**
   * CommissionTerm findFirstOrThrow
   */
  export type CommissionTermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * Filter, which CommissionTerm to fetch.
     */
    where?: CommissionTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionTerms to fetch.
     */
    orderBy?: CommissionTermOrderByWithRelationInput | CommissionTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionTerms.
     */
    cursor?: CommissionTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionTerms.
     */
    distinct?: CommissionTermScalarFieldEnum | CommissionTermScalarFieldEnum[]
  }

  /**
   * CommissionTerm findMany
   */
  export type CommissionTermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * Filter, which CommissionTerms to fetch.
     */
    where?: CommissionTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionTerms to fetch.
     */
    orderBy?: CommissionTermOrderByWithRelationInput | CommissionTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommissionTerms.
     */
    cursor?: CommissionTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionTerms.
     */
    skip?: number
    distinct?: CommissionTermScalarFieldEnum | CommissionTermScalarFieldEnum[]
  }

  /**
   * CommissionTerm create
   */
  export type CommissionTermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * The data needed to create a CommissionTerm.
     */
    data: XOR<CommissionTermCreateInput, CommissionTermUncheckedCreateInput>
  }

  /**
   * CommissionTerm createMany
   */
  export type CommissionTermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommissionTerms.
     */
    data: CommissionTermCreateManyInput | CommissionTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommissionTerm createManyAndReturn
   */
  export type CommissionTermCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * The data used to create many CommissionTerms.
     */
    data: CommissionTermCreateManyInput | CommissionTermCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommissionTerm update
   */
  export type CommissionTermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * The data needed to update a CommissionTerm.
     */
    data: XOR<CommissionTermUpdateInput, CommissionTermUncheckedUpdateInput>
    /**
     * Choose, which CommissionTerm to update.
     */
    where: CommissionTermWhereUniqueInput
  }

  /**
   * CommissionTerm updateMany
   */
  export type CommissionTermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommissionTerms.
     */
    data: XOR<CommissionTermUpdateManyMutationInput, CommissionTermUncheckedUpdateManyInput>
    /**
     * Filter which CommissionTerms to update
     */
    where?: CommissionTermWhereInput
    /**
     * Limit how many CommissionTerms to update.
     */
    limit?: number
  }

  /**
   * CommissionTerm updateManyAndReturn
   */
  export type CommissionTermUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * The data used to update CommissionTerms.
     */
    data: XOR<CommissionTermUpdateManyMutationInput, CommissionTermUncheckedUpdateManyInput>
    /**
     * Filter which CommissionTerms to update
     */
    where?: CommissionTermWhereInput
    /**
     * Limit how many CommissionTerms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommissionTerm upsert
   */
  export type CommissionTermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * The filter to search for the CommissionTerm to update in case it exists.
     */
    where: CommissionTermWhereUniqueInput
    /**
     * In case the CommissionTerm found by the `where` argument doesn't exist, create a new CommissionTerm with this data.
     */
    create: XOR<CommissionTermCreateInput, CommissionTermUncheckedCreateInput>
    /**
     * In case the CommissionTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionTermUpdateInput, CommissionTermUncheckedUpdateInput>
  }

  /**
   * CommissionTerm delete
   */
  export type CommissionTermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
    /**
     * Filter which CommissionTerm to delete.
     */
    where: CommissionTermWhereUniqueInput
  }

  /**
   * CommissionTerm deleteMany
   */
  export type CommissionTermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionTerms to delete
     */
    where?: CommissionTermWhereInput
    /**
     * Limit how many CommissionTerms to delete.
     */
    limit?: number
  }

  /**
   * CommissionTerm without action
   */
  export type CommissionTermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionTerm
     */
    select?: CommissionTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionTerm
     */
    omit?: CommissionTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionTermInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    rate_per_hour: number | null
    company_id: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    rate_per_hour: number | null
    company_id: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    first_name: string | null
    middle_name: string | null
    surname: string | null
    dob: Date | null
    gender: $Enums.Gender | null
    phone_number: string | null
    npf_number: string | null
    email_address: string | null
    village: string | null
    status: $Enums.Status | null
    hire_date: Date | null
    job_title: string | null
    department: string | null
    work_location: string | null
    manager_id: string | null
    client_id: string | null
    employee_id: string | null
    payment_method: $Enums.PaymentMethod | null
    bank_name: string | null
    account_name: string | null
    account_number: string | null
    pay_type: $Enums.PayType | null
    rate_per_hour: number | null
    pay_frequency: $Enums.PayFrequency | null
    employee_type: string | null
    cost_center: string | null
    allownce_eligible: boolean | null
    profile_image: string | null
    created_on: Date | null
    updated_on: Date | null
    company_id: number | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    first_name: string | null
    middle_name: string | null
    surname: string | null
    dob: Date | null
    gender: $Enums.Gender | null
    phone_number: string | null
    npf_number: string | null
    email_address: string | null
    village: string | null
    status: $Enums.Status | null
    hire_date: Date | null
    job_title: string | null
    department: string | null
    work_location: string | null
    manager_id: string | null
    client_id: string | null
    employee_id: string | null
    payment_method: $Enums.PaymentMethod | null
    bank_name: string | null
    account_name: string | null
    account_number: string | null
    pay_type: $Enums.PayType | null
    rate_per_hour: number | null
    pay_frequency: $Enums.PayFrequency | null
    employee_type: string | null
    cost_center: string | null
    allownce_eligible: boolean | null
    profile_image: string | null
    created_on: Date | null
    updated_on: Date | null
    company_id: number | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    first_name: number
    middle_name: number
    surname: number
    dob: number
    gender: number
    phone_number: number
    npf_number: number
    email_address: number
    village: number
    status: number
    hire_date: number
    job_title: number
    department: number
    work_location: number
    manager_id: number
    client_id: number
    employee_id: number
    payment_method: number
    bank_name: number
    account_name: number
    account_number: number
    pay_type: number
    rate_per_hour: number
    pay_frequency: number
    employee_type: number
    cost_center: number
    allownces: number
    allownce_eligible: number
    deductions: number
    profile_image: number
    created_on: number
    updated_on: number
    company_id: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    rate_per_hour?: true
    company_id?: true
  }

  export type EmployeeSumAggregateInputType = {
    rate_per_hour?: true
    company_id?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    first_name?: true
    middle_name?: true
    surname?: true
    dob?: true
    gender?: true
    phone_number?: true
    npf_number?: true
    email_address?: true
    village?: true
    status?: true
    hire_date?: true
    job_title?: true
    department?: true
    work_location?: true
    manager_id?: true
    client_id?: true
    employee_id?: true
    payment_method?: true
    bank_name?: true
    account_name?: true
    account_number?: true
    pay_type?: true
    rate_per_hour?: true
    pay_frequency?: true
    employee_type?: true
    cost_center?: true
    allownce_eligible?: true
    profile_image?: true
    created_on?: true
    updated_on?: true
    company_id?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    first_name?: true
    middle_name?: true
    surname?: true
    dob?: true
    gender?: true
    phone_number?: true
    npf_number?: true
    email_address?: true
    village?: true
    status?: true
    hire_date?: true
    job_title?: true
    department?: true
    work_location?: true
    manager_id?: true
    client_id?: true
    employee_id?: true
    payment_method?: true
    bank_name?: true
    account_name?: true
    account_number?: true
    pay_type?: true
    rate_per_hour?: true
    pay_frequency?: true
    employee_type?: true
    cost_center?: true
    allownce_eligible?: true
    profile_image?: true
    created_on?: true
    updated_on?: true
    company_id?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    first_name?: true
    middle_name?: true
    surname?: true
    dob?: true
    gender?: true
    phone_number?: true
    npf_number?: true
    email_address?: true
    village?: true
    status?: true
    hire_date?: true
    job_title?: true
    department?: true
    work_location?: true
    manager_id?: true
    client_id?: true
    employee_id?: true
    payment_method?: true
    bank_name?: true
    account_name?: true
    account_number?: true
    pay_type?: true
    rate_per_hour?: true
    pay_frequency?: true
    employee_type?: true
    cost_center?: true
    allownces?: true
    allownce_eligible?: true
    deductions?: true
    profile_image?: true
    created_on?: true
    updated_on?: true
    company_id?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    first_name: string
    middle_name: string | null
    surname: string
    dob: Date
    gender: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status: $Enums.Status | null
    hire_date: Date
    job_title: string
    department: string
    work_location: string
    manager_id: string | null
    client_id: string
    employee_id: string
    payment_method: $Enums.PaymentMethod | null
    bank_name: string | null
    account_name: string | null
    account_number: string | null
    pay_type: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonValue
    allownce_eligible: boolean
    deductions: JsonValue
    profile_image: string | null
    created_on: Date
    updated_on: Date
    company_id: number
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    middle_name?: boolean
    surname?: boolean
    dob?: boolean
    gender?: boolean
    phone_number?: boolean
    npf_number?: boolean
    email_address?: boolean
    village?: boolean
    status?: boolean
    hire_date?: boolean
    job_title?: boolean
    department?: boolean
    work_location?: boolean
    manager_id?: boolean
    client_id?: boolean
    employee_id?: boolean
    payment_method?: boolean
    bank_name?: boolean
    account_name?: boolean
    account_number?: boolean
    pay_type?: boolean
    rate_per_hour?: boolean
    pay_frequency?: boolean
    employee_type?: boolean
    cost_center?: boolean
    allownces?: boolean
    allownce_eligible?: boolean
    deductions?: boolean
    profile_image?: boolean
    created_on?: boolean
    updated_on?: boolean
    company_id?: boolean
    manager?: boolean | Employee$managerArgs<ExtArgs>
    employer?: boolean | EmployerDefaultArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    middle_name?: boolean
    surname?: boolean
    dob?: boolean
    gender?: boolean
    phone_number?: boolean
    npf_number?: boolean
    email_address?: boolean
    village?: boolean
    status?: boolean
    hire_date?: boolean
    job_title?: boolean
    department?: boolean
    work_location?: boolean
    manager_id?: boolean
    client_id?: boolean
    employee_id?: boolean
    payment_method?: boolean
    bank_name?: boolean
    account_name?: boolean
    account_number?: boolean
    pay_type?: boolean
    rate_per_hour?: boolean
    pay_frequency?: boolean
    employee_type?: boolean
    cost_center?: boolean
    allownces?: boolean
    allownce_eligible?: boolean
    deductions?: boolean
    profile_image?: boolean
    created_on?: boolean
    updated_on?: boolean
    company_id?: boolean
    manager?: boolean | Employee$managerArgs<ExtArgs>
    employer?: boolean | EmployerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    middle_name?: boolean
    surname?: boolean
    dob?: boolean
    gender?: boolean
    phone_number?: boolean
    npf_number?: boolean
    email_address?: boolean
    village?: boolean
    status?: boolean
    hire_date?: boolean
    job_title?: boolean
    department?: boolean
    work_location?: boolean
    manager_id?: boolean
    client_id?: boolean
    employee_id?: boolean
    payment_method?: boolean
    bank_name?: boolean
    account_name?: boolean
    account_number?: boolean
    pay_type?: boolean
    rate_per_hour?: boolean
    pay_frequency?: boolean
    employee_type?: boolean
    cost_center?: boolean
    allownces?: boolean
    allownce_eligible?: boolean
    deductions?: boolean
    profile_image?: boolean
    created_on?: boolean
    updated_on?: boolean
    company_id?: boolean
    manager?: boolean | Employee$managerArgs<ExtArgs>
    employer?: boolean | EmployerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    first_name?: boolean
    middle_name?: boolean
    surname?: boolean
    dob?: boolean
    gender?: boolean
    phone_number?: boolean
    npf_number?: boolean
    email_address?: boolean
    village?: boolean
    status?: boolean
    hire_date?: boolean
    job_title?: boolean
    department?: boolean
    work_location?: boolean
    manager_id?: boolean
    client_id?: boolean
    employee_id?: boolean
    payment_method?: boolean
    bank_name?: boolean
    account_name?: boolean
    account_number?: boolean
    pay_type?: boolean
    rate_per_hour?: boolean
    pay_frequency?: boolean
    employee_type?: boolean
    cost_center?: boolean
    allownces?: boolean
    allownce_eligible?: boolean
    deductions?: boolean
    profile_image?: boolean
    created_on?: boolean
    updated_on?: boolean
    company_id?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "middle_name" | "surname" | "dob" | "gender" | "phone_number" | "npf_number" | "email_address" | "village" | "status" | "hire_date" | "job_title" | "department" | "work_location" | "manager_id" | "client_id" | "employee_id" | "payment_method" | "bank_name" | "account_name" | "account_number" | "pay_type" | "rate_per_hour" | "pay_frequency" | "employee_type" | "cost_center" | "allownces" | "allownce_eligible" | "deductions" | "profile_image" | "created_on" | "updated_on" | "company_id", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | Employee$managerArgs<ExtArgs>
    employer?: boolean | EmployerDefaultArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | Employee$managerArgs<ExtArgs>
    employer?: boolean | EmployerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | Employee$managerArgs<ExtArgs>
    employer?: boolean | EmployerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      manager: Prisma.$ManagerPayload<ExtArgs> | null
      employer: Prisma.$EmployerPayload<ExtArgs>
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      first_name: string
      middle_name: string | null
      surname: string
      dob: Date
      gender: $Enums.Gender | null
      phone_number: string
      npf_number: string
      email_address: string
      village: string
      status: $Enums.Status | null
      hire_date: Date
      job_title: string
      department: string
      work_location: string
      manager_id: string | null
      client_id: string
      employee_id: string
      payment_method: $Enums.PaymentMethod | null
      bank_name: string | null
      account_name: string | null
      account_number: string | null
      pay_type: $Enums.PayType | null
      rate_per_hour: number
      pay_frequency: $Enums.PayFrequency | null
      employee_type: string
      cost_center: string
      allownces: Prisma.JsonValue
      allownce_eligible: boolean
      deductions: Prisma.JsonValue
      profile_image: string | null
      created_on: Date
      updated_on: Date
      company_id: number
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manager<T extends Employee$managerArgs<ExtArgs> = {}>(args?: Subset<T, Employee$managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employer<T extends EmployerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployerDefaultArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leaves<T extends Employee$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Employee$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly first_name: FieldRef<"Employee", 'String'>
    readonly middle_name: FieldRef<"Employee", 'String'>
    readonly surname: FieldRef<"Employee", 'String'>
    readonly dob: FieldRef<"Employee", 'DateTime'>
    readonly gender: FieldRef<"Employee", 'Gender'>
    readonly phone_number: FieldRef<"Employee", 'String'>
    readonly npf_number: FieldRef<"Employee", 'String'>
    readonly email_address: FieldRef<"Employee", 'String'>
    readonly village: FieldRef<"Employee", 'String'>
    readonly status: FieldRef<"Employee", 'Status'>
    readonly hire_date: FieldRef<"Employee", 'DateTime'>
    readonly job_title: FieldRef<"Employee", 'String'>
    readonly department: FieldRef<"Employee", 'String'>
    readonly work_location: FieldRef<"Employee", 'String'>
    readonly manager_id: FieldRef<"Employee", 'String'>
    readonly client_id: FieldRef<"Employee", 'String'>
    readonly employee_id: FieldRef<"Employee", 'String'>
    readonly payment_method: FieldRef<"Employee", 'PaymentMethod'>
    readonly bank_name: FieldRef<"Employee", 'String'>
    readonly account_name: FieldRef<"Employee", 'String'>
    readonly account_number: FieldRef<"Employee", 'String'>
    readonly pay_type: FieldRef<"Employee", 'PayType'>
    readonly rate_per_hour: FieldRef<"Employee", 'Float'>
    readonly pay_frequency: FieldRef<"Employee", 'PayFrequency'>
    readonly employee_type: FieldRef<"Employee", 'String'>
    readonly cost_center: FieldRef<"Employee", 'String'>
    readonly allownces: FieldRef<"Employee", 'Json'>
    readonly allownce_eligible: FieldRef<"Employee", 'Boolean'>
    readonly deductions: FieldRef<"Employee", 'Json'>
    readonly profile_image: FieldRef<"Employee", 'String'>
    readonly created_on: FieldRef<"Employee", 'DateTime'>
    readonly updated_on: FieldRef<"Employee", 'DateTime'>
    readonly company_id: FieldRef<"Employee", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.manager
   */
  export type Employee$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * Employee.leaves
   */
  export type Employee$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Employee.documents
   */
  export type Employee$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveAvgAggregateOutputType = {
    available: number | null
  }

  export type LeaveSumAggregateOutputType = {
    available: number | null
  }

  export type LeaveMinAggregateOutputType = {
    id: string | null
    leave_id: string | null
    available: number | null
    employee_id: string | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: string | null
    leave_id: string | null
    available: number | null
    employee_id: string | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    leave_id: number
    available: number
    employee_id: number
    _all: number
  }


  export type LeaveAvgAggregateInputType = {
    available?: true
  }

  export type LeaveSumAggregateInputType = {
    available?: true
  }

  export type LeaveMinAggregateInputType = {
    id?: true
    leave_id?: true
    available?: true
    employee_id?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    leave_id?: true
    available?: true
    employee_id?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    leave_id?: true
    available?: true
    employee_id?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _avg?: LeaveAvgAggregateInputType
    _sum?: LeaveSumAggregateInputType
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: string
    leave_id: string
    available: number
    employee_id: string
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leave_id?: boolean
    available?: boolean
    employee_id?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leave_id?: boolean
    available?: boolean
    employee_id?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leave_id?: boolean
    available?: boolean
    employee_id?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectScalar = {
    id?: boolean
    leave_id?: boolean
    available?: boolean
    employee_id?: boolean
  }

  export type LeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leave_id" | "available" | "employee_id", ExtArgs["result"]["leave"]>
  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leave_id: string
      available: number
      employee_id: string
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaves and returns the data saved in the database.
     * @param {LeaveCreateManyAndReturnArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves and returns the data updated in the database.
     * @param {LeaveUpdateManyAndReturnArgs} args - Arguments to update many Leaves.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'String'>
    readonly leave_id: FieldRef<"Leave", 'String'>
    readonly available: FieldRef<"Leave", 'Float'>
    readonly employee_id: FieldRef<"Leave", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave createManyAndReturn
   */
  export type LeaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
  }

  /**
   * Leave updateManyAndReturn
   */
  export type LeaveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to delete.
     */
    limit?: number
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    url: string | null
    name: string | null
    description: string | null
    employee_id: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    url: string | null
    name: string | null
    description: string | null
    employee_id: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    url: number
    name: number
    description: number
    employee_id: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    url?: true
    name?: true
    description?: true
    employee_id?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    url?: true
    name?: true
    description?: true
    employee_id?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    url?: true
    name?: true
    description?: true
    employee_id?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    url: string
    name: string
    description: string | null
    employee_id: string
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    employee_id?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    employee_id?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    employee_id?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    url?: boolean
    name?: boolean
    description?: boolean
    employee_id?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "name" | "description" | "employee_id", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      name: string
      description: string | null
      employee_id: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly employee_id: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerMinAggregateOutputType = {
    id: string | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: string | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ManagerMinAggregateInputType = {
    id?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    id: string
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employees?: boolean | Manager$employeesArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectScalar = {
    id?: boolean
  }

  export type ManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["manager"]>
  export type ManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Manager$employeesArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }

  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerFindUniqueArgs>(args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerFindFirstArgs>(args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagerFindManyArgs>(args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
     */
    create<T extends ManagerCreateArgs>(args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Managers.
     * @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCreateManyArgs>(args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Managers and returns the data saved in the database.
     * @param {ManagerCreateManyAndReturnArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Managers and only return the `id`
     * const managerWithIdOnly = await prisma.manager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
     */
    delete<T extends ManagerDeleteArgs>(args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerUpdateArgs>(args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerDeleteManyArgs>(args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerUpdateManyArgs>(args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers and returns the data updated in the database.
     * @param {ManagerUpdateManyAndReturnArgs} args - Arguments to update many Managers.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Managers and only return the `id`
     * const managerWithIdOnly = await prisma.manager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, ManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
     */
    upsert<T extends ManagerUpsertArgs>(args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Manager$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Manager$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manager model
   */
  interface ManagerFieldRefs {
    readonly id: FieldRef<"Manager", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data?: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }

  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager createManyAndReturn
   */
  export type ManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager updateManyAndReturn
   */
  export type ManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }

  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to delete.
     */
    limit?: number
  }

  /**
   * Manager.employees
   */
  export type Manager$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
  }


  /**
   * Model Employer
   */

  export type AggregateEmployer = {
    _count: EmployerCountAggregateOutputType | null
    _min: EmployerMinAggregateOutputType | null
    _max: EmployerMaxAggregateOutputType | null
  }

  export type EmployerMinAggregateOutputType = {
    employer_id: string | null
  }

  export type EmployerMaxAggregateOutputType = {
    employer_id: string | null
  }

  export type EmployerCountAggregateOutputType = {
    employer_id: number
    _all: number
  }


  export type EmployerMinAggregateInputType = {
    employer_id?: true
  }

  export type EmployerMaxAggregateInputType = {
    employer_id?: true
  }

  export type EmployerCountAggregateInputType = {
    employer_id?: true
    _all?: true
  }

  export type EmployerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employer to aggregate.
     */
    where?: EmployerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employers to fetch.
     */
    orderBy?: EmployerOrderByWithRelationInput | EmployerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employers
    **/
    _count?: true | EmployerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployerMaxAggregateInputType
  }

  export type GetEmployerAggregateType<T extends EmployerAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployer[P]>
      : GetScalarType<T[P], AggregateEmployer[P]>
  }




  export type EmployerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployerWhereInput
    orderBy?: EmployerOrderByWithAggregationInput | EmployerOrderByWithAggregationInput[]
    by: EmployerScalarFieldEnum[] | EmployerScalarFieldEnum
    having?: EmployerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployerCountAggregateInputType | true
    _min?: EmployerMinAggregateInputType
    _max?: EmployerMaxAggregateInputType
  }

  export type EmployerGroupByOutputType = {
    employer_id: string
    _count: EmployerCountAggregateOutputType | null
    _min: EmployerMinAggregateOutputType | null
    _max: EmployerMaxAggregateOutputType | null
  }

  type GetEmployerGroupByPayload<T extends EmployerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployerGroupByOutputType[P]>
            : GetScalarType<T[P], EmployerGroupByOutputType[P]>
        }
      >
    >


  export type EmployerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employer_id?: boolean
    employees?: boolean | Employer$employeesArgs<ExtArgs>
    _count?: boolean | EmployerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employer"]>

  export type EmployerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employer_id?: boolean
  }, ExtArgs["result"]["employer"]>

  export type EmployerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employer_id?: boolean
  }, ExtArgs["result"]["employer"]>

  export type EmployerSelectScalar = {
    employer_id?: boolean
  }

  export type EmployerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employer_id", ExtArgs["result"]["employer"]>
  export type EmployerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Employer$employeesArgs<ExtArgs>
    _count?: boolean | EmployerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmployerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employer"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      employer_id: string
    }, ExtArgs["result"]["employer"]>
    composites: {}
  }

  type EmployerGetPayload<S extends boolean | null | undefined | EmployerDefaultArgs> = $Result.GetResult<Prisma.$EmployerPayload, S>

  type EmployerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployerCountAggregateInputType | true
    }

  export interface EmployerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employer'], meta: { name: 'Employer' } }
    /**
     * Find zero or one Employer that matches the filter.
     * @param {EmployerFindUniqueArgs} args - Arguments to find a Employer
     * @example
     * // Get one Employer
     * const employer = await prisma.employer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployerFindUniqueArgs>(args: SelectSubset<T, EmployerFindUniqueArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployerFindUniqueOrThrowArgs} args - Arguments to find a Employer
     * @example
     * // Get one Employer
     * const employer = await prisma.employer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployerFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerFindFirstArgs} args - Arguments to find a Employer
     * @example
     * // Get one Employer
     * const employer = await prisma.employer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployerFindFirstArgs>(args?: SelectSubset<T, EmployerFindFirstArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerFindFirstOrThrowArgs} args - Arguments to find a Employer
     * @example
     * // Get one Employer
     * const employer = await prisma.employer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployerFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployerFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employers
     * const employers = await prisma.employer.findMany()
     * 
     * // Get first 10 Employers
     * const employers = await prisma.employer.findMany({ take: 10 })
     * 
     * // Only select the `employer_id`
     * const employerWithEmployer_idOnly = await prisma.employer.findMany({ select: { employer_id: true } })
     * 
     */
    findMany<T extends EmployerFindManyArgs>(args?: SelectSubset<T, EmployerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employer.
     * @param {EmployerCreateArgs} args - Arguments to create a Employer.
     * @example
     * // Create one Employer
     * const Employer = await prisma.employer.create({
     *   data: {
     *     // ... data to create a Employer
     *   }
     * })
     * 
     */
    create<T extends EmployerCreateArgs>(args: SelectSubset<T, EmployerCreateArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employers.
     * @param {EmployerCreateManyArgs} args - Arguments to create many Employers.
     * @example
     * // Create many Employers
     * const employer = await prisma.employer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployerCreateManyArgs>(args?: SelectSubset<T, EmployerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employers and returns the data saved in the database.
     * @param {EmployerCreateManyAndReturnArgs} args - Arguments to create many Employers.
     * @example
     * // Create many Employers
     * const employer = await prisma.employer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employers and only return the `employer_id`
     * const employerWithEmployer_idOnly = await prisma.employer.createManyAndReturn({
     *   select: { employer_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployerCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employer.
     * @param {EmployerDeleteArgs} args - Arguments to delete one Employer.
     * @example
     * // Delete one Employer
     * const Employer = await prisma.employer.delete({
     *   where: {
     *     // ... filter to delete one Employer
     *   }
     * })
     * 
     */
    delete<T extends EmployerDeleteArgs>(args: SelectSubset<T, EmployerDeleteArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employer.
     * @param {EmployerUpdateArgs} args - Arguments to update one Employer.
     * @example
     * // Update one Employer
     * const employer = await prisma.employer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployerUpdateArgs>(args: SelectSubset<T, EmployerUpdateArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employers.
     * @param {EmployerDeleteManyArgs} args - Arguments to filter Employers to delete.
     * @example
     * // Delete a few Employers
     * const { count } = await prisma.employer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployerDeleteManyArgs>(args?: SelectSubset<T, EmployerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employers
     * const employer = await prisma.employer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployerUpdateManyArgs>(args: SelectSubset<T, EmployerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employers and returns the data updated in the database.
     * @param {EmployerUpdateManyAndReturnArgs} args - Arguments to update many Employers.
     * @example
     * // Update many Employers
     * const employer = await prisma.employer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employers and only return the `employer_id`
     * const employerWithEmployer_idOnly = await prisma.employer.updateManyAndReturn({
     *   select: { employer_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployerUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employer.
     * @param {EmployerUpsertArgs} args - Arguments to update or create a Employer.
     * @example
     * // Update or create a Employer
     * const employer = await prisma.employer.upsert({
     *   create: {
     *     // ... data to create a Employer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employer we want to update
     *   }
     * })
     */
    upsert<T extends EmployerUpsertArgs>(args: SelectSubset<T, EmployerUpsertArgs<ExtArgs>>): Prisma__EmployerClient<$Result.GetResult<Prisma.$EmployerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerCountArgs} args - Arguments to filter Employers to count.
     * @example
     * // Count the number of Employers
     * const count = await prisma.employer.count({
     *   where: {
     *     // ... the filter for the Employers we want to count
     *   }
     * })
    **/
    count<T extends EmployerCountArgs>(
      args?: Subset<T, EmployerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployerAggregateArgs>(args: Subset<T, EmployerAggregateArgs>): Prisma.PrismaPromise<GetEmployerAggregateType<T>>

    /**
     * Group by Employer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployerGroupByArgs['orderBy'] }
        : { orderBy?: EmployerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employer model
   */
  readonly fields: EmployerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Employer$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Employer$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employer model
   */
  interface EmployerFieldRefs {
    readonly employer_id: FieldRef<"Employer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employer findUnique
   */
  export type EmployerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * Filter, which Employer to fetch.
     */
    where: EmployerWhereUniqueInput
  }

  /**
   * Employer findUniqueOrThrow
   */
  export type EmployerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * Filter, which Employer to fetch.
     */
    where: EmployerWhereUniqueInput
  }

  /**
   * Employer findFirst
   */
  export type EmployerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * Filter, which Employer to fetch.
     */
    where?: EmployerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employers to fetch.
     */
    orderBy?: EmployerOrderByWithRelationInput | EmployerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employers.
     */
    cursor?: EmployerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employers.
     */
    distinct?: EmployerScalarFieldEnum | EmployerScalarFieldEnum[]
  }

  /**
   * Employer findFirstOrThrow
   */
  export type EmployerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * Filter, which Employer to fetch.
     */
    where?: EmployerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employers to fetch.
     */
    orderBy?: EmployerOrderByWithRelationInput | EmployerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employers.
     */
    cursor?: EmployerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employers.
     */
    distinct?: EmployerScalarFieldEnum | EmployerScalarFieldEnum[]
  }

  /**
   * Employer findMany
   */
  export type EmployerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * Filter, which Employers to fetch.
     */
    where?: EmployerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employers to fetch.
     */
    orderBy?: EmployerOrderByWithRelationInput | EmployerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employers.
     */
    cursor?: EmployerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employers.
     */
    skip?: number
    distinct?: EmployerScalarFieldEnum | EmployerScalarFieldEnum[]
  }

  /**
   * Employer create
   */
  export type EmployerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * The data needed to create a Employer.
     */
    data: XOR<EmployerCreateInput, EmployerUncheckedCreateInput>
  }

  /**
   * Employer createMany
   */
  export type EmployerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employers.
     */
    data: EmployerCreateManyInput | EmployerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employer createManyAndReturn
   */
  export type EmployerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * The data used to create many Employers.
     */
    data: EmployerCreateManyInput | EmployerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employer update
   */
  export type EmployerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * The data needed to update a Employer.
     */
    data: XOR<EmployerUpdateInput, EmployerUncheckedUpdateInput>
    /**
     * Choose, which Employer to update.
     */
    where: EmployerWhereUniqueInput
  }

  /**
   * Employer updateMany
   */
  export type EmployerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employers.
     */
    data: XOR<EmployerUpdateManyMutationInput, EmployerUncheckedUpdateManyInput>
    /**
     * Filter which Employers to update
     */
    where?: EmployerWhereInput
    /**
     * Limit how many Employers to update.
     */
    limit?: number
  }

  /**
   * Employer updateManyAndReturn
   */
  export type EmployerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * The data used to update Employers.
     */
    data: XOR<EmployerUpdateManyMutationInput, EmployerUncheckedUpdateManyInput>
    /**
     * Filter which Employers to update
     */
    where?: EmployerWhereInput
    /**
     * Limit how many Employers to update.
     */
    limit?: number
  }

  /**
   * Employer upsert
   */
  export type EmployerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * The filter to search for the Employer to update in case it exists.
     */
    where: EmployerWhereUniqueInput
    /**
     * In case the Employer found by the `where` argument doesn't exist, create a new Employer with this data.
     */
    create: XOR<EmployerCreateInput, EmployerUncheckedCreateInput>
    /**
     * In case the Employer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployerUpdateInput, EmployerUncheckedUpdateInput>
  }

  /**
   * Employer delete
   */
  export type EmployerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
    /**
     * Filter which Employer to delete.
     */
    where: EmployerWhereUniqueInput
  }

  /**
   * Employer deleteMany
   */
  export type EmployerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employers to delete
     */
    where?: EmployerWhereInput
    /**
     * Limit how many Employers to delete.
     */
    limit?: number
  }

  /**
   * Employer.employees
   */
  export type Employer$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employer without action
   */
  export type EmployerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employer
     */
    select?: EmployerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employer
     */
    omit?: EmployerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MBSCDScalarFieldEnum: {
    bscd: 'bscd',
    bscdDetail: 'bscdDetail'
  };

  export type MBSCDScalarFieldEnum = (typeof MBSCDScalarFieldEnum)[keyof typeof MBSCDScalarFieldEnum]


  export const BSCDScalarFieldEnum: {
    bscd: 'bscd',
    mbscd: 'mbscd',
    bscdDetail: 'bscdDetail'
  };

  export type BSCDScalarFieldEnum = (typeof BSCDScalarFieldEnum)[keyof typeof BSCDScalarFieldEnum]


  export const MACNOScalarFieldEnum: {
    macno: 'macno',
    bscd: 'bscd',
    macname: 'macname'
  };

  export type MACNOScalarFieldEnum = (typeof MACNOScalarFieldEnum)[keyof typeof MACNOScalarFieldEnum]


  export const ACNOScalarFieldEnum: {
    acno: 'acno',
    macno: 'macno',
    acname: 'acname',
    bankAccountNo: 'bankAccountNo',
    address: 'address',
    city: 'city',
    phoneFax: 'phoneFax',
    email: 'email',
    website: 'website',
    crDays: 'crDays',
    stRate: 'stRate',
    area: 'area',
    category: 'category',
    subCategory: 'subCategory',
    country: 'country',
    customerBank: 'customerBank',
    customerBankAddr: 'customerBankAddr',
    stRegNo: 'stRegNo',
    ntnNo: 'ntnNo',
    contactPerson: 'contactPerson',
    crLimit: 'crLimit',
    salesArea: 'salesArea'
  };

  export type ACNOScalarFieldEnum = (typeof ACNOScalarFieldEnum)[keyof typeof ACNOScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    company: 'company',
    addr1: 'addr1',
    addr2: 'addr2',
    city: 'city',
    phone: 'phone',
    fax: 'fax',
    email: 'email'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CostCenterScalarFieldEnum: {
    ccno: 'ccno',
    company_id: 'company_id',
    ccname: 'ccname'
  };

  export type CostCenterScalarFieldEnum = (typeof CostCenterScalarFieldEnum)[keyof typeof CostCenterScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    dept_name: 'dept_name',
    company_id: 'company_id'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ProductMasterCategoryScalarFieldEnum: {
    id: 'id',
    pmc_name: 'pmc_name'
  };

  export type ProductMasterCategoryScalarFieldEnum = (typeof ProductMasterCategoryScalarFieldEnum)[keyof typeof ProductMasterCategoryScalarFieldEnum]


  export const ProductGroupScalarFieldEnum: {
    id: 'id',
    pg_name: 'pg_name',
    pmc_id: 'pmc_id'
  };

  export type ProductGroupScalarFieldEnum = (typeof ProductGroupScalarFieldEnum)[keyof typeof ProductGroupScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    pc_name: 'pc_name',
    pg_id: 'pg_id'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const MainCategoryScalarFieldEnum: {
    id: 'id',
    mc_name: 'mc_name',
    pc_id: 'pc_id'
  };

  export type MainCategoryScalarFieldEnum = (typeof MainCategoryScalarFieldEnum)[keyof typeof MainCategoryScalarFieldEnum]


  export const ItemCategoryScalarFieldEnum: {
    id: 'id',
    ic_name: 'ic_name',
    mc_id: 'mc_id',
    wc_category_id: 'wc_category_id',
    sync_status: 'sync_status',
    last_sync: 'last_sync'
  };

  export type ItemCategoryScalarFieldEnum = (typeof ItemCategoryScalarFieldEnum)[keyof typeof ItemCategoryScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    itcd: 'itcd',
    item: 'item',
    ic_id: 'ic_id',
    sku: 'sku',
    price: 'price',
    stock: 'stock',
    wc_product_id: 'wc_product_id',
    wc_parent_id: 'wc_parent_id',
    sync_status: 'sync_status',
    last_sync: 'last_sync'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const DesignationScalarFieldEnum: {
    id: 'id',
    desg_name: 'desg_name',
    company_id: 'company_id'
  };

  export type DesignationScalarFieldEnum = (typeof DesignationScalarFieldEnum)[keyof typeof DesignationScalarFieldEnum]


  export const GodownScalarFieldEnum: {
    id: 'id',
    godown: 'godown',
    company_id: 'company_id'
  };

  export type GodownScalarFieldEnum = (typeof GodownScalarFieldEnum)[keyof typeof GodownScalarFieldEnum]


  export const FinancialYearScalarFieldEnum: {
    id: 'id',
    date_from: 'date_from',
    date_to: 'date_to',
    status: 'status',
    company_id: 'company_id'
  };

  export type FinancialYearScalarFieldEnum = (typeof FinancialYearScalarFieldEnum)[keyof typeof FinancialYearScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    date_from: 'date_from',
    date_to: 'date_to',
    status: 'status',
    company_id: 'company_id'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const PoPrdCatScalarFieldEnum: {
    id: 'id',
    category_name: 'category_name',
    company_id: 'company_id'
  };

  export type PoPrdCatScalarFieldEnum = (typeof PoPrdCatScalarFieldEnum)[keyof typeof PoPrdCatScalarFieldEnum]


  export const DeliveryModeScalarFieldEnum: {
    id: 'id',
    delivery_mode: 'delivery_mode',
    rate_kg: 'rate_kg',
    company_id: 'company_id'
  };

  export type DeliveryModeScalarFieldEnum = (typeof DeliveryModeScalarFieldEnum)[keyof typeof DeliveryModeScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    user_name: 'user_name',
    company_id: 'company_id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    currency: 'currency'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const TransactionsMasterScalarFieldEnum: {
    tran_id: 'tran_id',
    company_id: 'company_id',
    dateD: 'dateD',
    time: 'time',
    tran_code: 'tran_code',
    vr_no: 'vr_no',
    pycd: 'pycd',
    check_no: 'check_no',
    check_date: 'check_date',
    rmk: 'rmk',
    rmk1: 'rmk1',
    rmk2: 'rmk2',
    rmk3: 'rmk3',
    rmk4: 'rmk4',
    rmk5: 'rmk5',
    userId: 'userId',
    invoice_no: 'invoice_no',
    godown: 'godown',
    wc_order_id: 'wc_order_id',
    sync_status: 'sync_status',
    last_sync: 'last_sync'
  };

  export type TransactionsMasterScalarFieldEnum = (typeof TransactionsMasterScalarFieldEnum)[keyof typeof TransactionsMasterScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    tran_id: 'tran_id',
    acno: 'acno',
    itcd: 'itcd',
    ccno: 'ccno',
    narration1: 'narration1',
    narration2: 'narration2',
    narration3: 'narration3',
    narration4: 'narration4',
    narration5: 'narration5',
    chno: 'chno',
    check_date: 'check_date',
    party_name: 'party_name',
    damt: 'damt',
    camt: 'camt',
    qty: 'qty',
    rate: 'rate',
    wht_rate: 'wht_rate',
    st_rate: 'st_rate',
    godown: 'godown',
    invoice_no: 'invoice_no',
    sub_tran_id: 'sub_tran_id',
    currency: 'currency',
    gross_amount: 'gross_amount',
    fc_amount: 'fc_amount',
    no_of_pack: 'no_of_pack',
    qty_per_pack: 'qty_per_pack',
    st_amount: 'st_amount',
    additional_tax: 'additional_tax'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const DeliveryTermScalarFieldEnum: {
    id: 'id',
    delivery_term: 'delivery_term',
    company_id: 'company_id'
  };

  export type DeliveryTermScalarFieldEnum = (typeof DeliveryTermScalarFieldEnum)[keyof typeof DeliveryTermScalarFieldEnum]


  export const CommissionTermScalarFieldEnum: {
    id: 'id',
    commission_term: 'commission_term',
    company_id: 'company_id'
  };

  export type CommissionTermScalarFieldEnum = (typeof CommissionTermScalarFieldEnum)[keyof typeof CommissionTermScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    middle_name: 'middle_name',
    surname: 'surname',
    dob: 'dob',
    gender: 'gender',
    phone_number: 'phone_number',
    npf_number: 'npf_number',
    email_address: 'email_address',
    village: 'village',
    status: 'status',
    hire_date: 'hire_date',
    job_title: 'job_title',
    department: 'department',
    work_location: 'work_location',
    manager_id: 'manager_id',
    client_id: 'client_id',
    employee_id: 'employee_id',
    payment_method: 'payment_method',
    bank_name: 'bank_name',
    account_name: 'account_name',
    account_number: 'account_number',
    pay_type: 'pay_type',
    rate_per_hour: 'rate_per_hour',
    pay_frequency: 'pay_frequency',
    employee_type: 'employee_type',
    cost_center: 'cost_center',
    allownces: 'allownces',
    allownce_eligible: 'allownce_eligible',
    deductions: 'deductions',
    profile_image: 'profile_image',
    created_on: 'created_on',
    updated_on: 'updated_on',
    company_id: 'company_id'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    leave_id: 'leave_id',
    available: 'available',
    employee_id: 'employee_id'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    url: 'url',
    name: 'name',
    description: 'description',
    employee_id: 'employee_id'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const EmployerScalarFieldEnum: {
    employer_id: 'employer_id'
  };

  export type EmployerScalarFieldEnum = (typeof EmployerScalarFieldEnum)[keyof typeof EmployerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PayType'
   */
  export type EnumPayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayType'>
    


  /**
   * Reference to a field of type 'PayType[]'
   */
  export type ListEnumPayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayType[]'>
    


  /**
   * Reference to a field of type 'PayFrequency'
   */
  export type EnumPayFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayFrequency'>
    


  /**
   * Reference to a field of type 'PayFrequency[]'
   */
  export type ListEnumPayFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayFrequency[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type MBSCDWhereInput = {
    AND?: MBSCDWhereInput | MBSCDWhereInput[]
    OR?: MBSCDWhereInput[]
    NOT?: MBSCDWhereInput | MBSCDWhereInput[]
    bscd?: StringFilter<"MBSCD"> | string
    bscdDetail?: StringFilter<"MBSCD"> | string
    bscdItems?: BSCDListRelationFilter
  }

  export type MBSCDOrderByWithRelationInput = {
    bscd?: SortOrder
    bscdDetail?: SortOrder
    bscdItems?: BSCDOrderByRelationAggregateInput
  }

  export type MBSCDWhereUniqueInput = Prisma.AtLeast<{
    bscd?: string
    AND?: MBSCDWhereInput | MBSCDWhereInput[]
    OR?: MBSCDWhereInput[]
    NOT?: MBSCDWhereInput | MBSCDWhereInput[]
    bscdDetail?: StringFilter<"MBSCD"> | string
    bscdItems?: BSCDListRelationFilter
  }, "bscd" | "bscd">

  export type MBSCDOrderByWithAggregationInput = {
    bscd?: SortOrder
    bscdDetail?: SortOrder
    _count?: MBSCDCountOrderByAggregateInput
    _max?: MBSCDMaxOrderByAggregateInput
    _min?: MBSCDMinOrderByAggregateInput
  }

  export type MBSCDScalarWhereWithAggregatesInput = {
    AND?: MBSCDScalarWhereWithAggregatesInput | MBSCDScalarWhereWithAggregatesInput[]
    OR?: MBSCDScalarWhereWithAggregatesInput[]
    NOT?: MBSCDScalarWhereWithAggregatesInput | MBSCDScalarWhereWithAggregatesInput[]
    bscd?: StringWithAggregatesFilter<"MBSCD"> | string
    bscdDetail?: StringWithAggregatesFilter<"MBSCD"> | string
  }

  export type BSCDWhereInput = {
    AND?: BSCDWhereInput | BSCDWhereInput[]
    OR?: BSCDWhereInput[]
    NOT?: BSCDWhereInput | BSCDWhereInput[]
    bscd?: StringFilter<"BSCD"> | string
    mbscd?: StringFilter<"BSCD"> | string
    bscdDetail?: StringFilter<"BSCD"> | string
    mainBscd?: XOR<MBSCDScalarRelationFilter, MBSCDWhereInput>
    macnoItems?: MACNOListRelationFilter
  }

  export type BSCDOrderByWithRelationInput = {
    bscd?: SortOrder
    mbscd?: SortOrder
    bscdDetail?: SortOrder
    mainBscd?: MBSCDOrderByWithRelationInput
    macnoItems?: MACNOOrderByRelationAggregateInput
  }

  export type BSCDWhereUniqueInput = Prisma.AtLeast<{
    bscd?: string
    mbscd_bscd?: BSCDMbscdBscdCompoundUniqueInput
    AND?: BSCDWhereInput | BSCDWhereInput[]
    OR?: BSCDWhereInput[]
    NOT?: BSCDWhereInput | BSCDWhereInput[]
    mbscd?: StringFilter<"BSCD"> | string
    bscdDetail?: StringFilter<"BSCD"> | string
    mainBscd?: XOR<MBSCDScalarRelationFilter, MBSCDWhereInput>
    macnoItems?: MACNOListRelationFilter
  }, "mbscd_bscd" | "bscd">

  export type BSCDOrderByWithAggregationInput = {
    bscd?: SortOrder
    mbscd?: SortOrder
    bscdDetail?: SortOrder
    _count?: BSCDCountOrderByAggregateInput
    _max?: BSCDMaxOrderByAggregateInput
    _min?: BSCDMinOrderByAggregateInput
  }

  export type BSCDScalarWhereWithAggregatesInput = {
    AND?: BSCDScalarWhereWithAggregatesInput | BSCDScalarWhereWithAggregatesInput[]
    OR?: BSCDScalarWhereWithAggregatesInput[]
    NOT?: BSCDScalarWhereWithAggregatesInput | BSCDScalarWhereWithAggregatesInput[]
    bscd?: StringWithAggregatesFilter<"BSCD"> | string
    mbscd?: StringWithAggregatesFilter<"BSCD"> | string
    bscdDetail?: StringWithAggregatesFilter<"BSCD"> | string
  }

  export type MACNOWhereInput = {
    AND?: MACNOWhereInput | MACNOWhereInput[]
    OR?: MACNOWhereInput[]
    NOT?: MACNOWhereInput | MACNOWhereInput[]
    macno?: StringFilter<"MACNO"> | string
    bscd?: StringFilter<"MACNO"> | string
    macname?: StringFilter<"MACNO"> | string
    bscdRef?: XOR<BSCDScalarRelationFilter, BSCDWhereInput>
    accounts?: ACNOListRelationFilter
  }

  export type MACNOOrderByWithRelationInput = {
    macno?: SortOrder
    bscd?: SortOrder
    macname?: SortOrder
    bscdRef?: BSCDOrderByWithRelationInput
    accounts?: ACNOOrderByRelationAggregateInput
  }

  export type MACNOWhereUniqueInput = Prisma.AtLeast<{
    macno?: string
    bscd_macno?: MACNOBscdMacnoCompoundUniqueInput
    AND?: MACNOWhereInput | MACNOWhereInput[]
    OR?: MACNOWhereInput[]
    NOT?: MACNOWhereInput | MACNOWhereInput[]
    bscd?: StringFilter<"MACNO"> | string
    macname?: StringFilter<"MACNO"> | string
    bscdRef?: XOR<BSCDScalarRelationFilter, BSCDWhereInput>
    accounts?: ACNOListRelationFilter
  }, "bscd_macno" | "macno">

  export type MACNOOrderByWithAggregationInput = {
    macno?: SortOrder
    bscd?: SortOrder
    macname?: SortOrder
    _count?: MACNOCountOrderByAggregateInput
    _max?: MACNOMaxOrderByAggregateInput
    _min?: MACNOMinOrderByAggregateInput
  }

  export type MACNOScalarWhereWithAggregatesInput = {
    AND?: MACNOScalarWhereWithAggregatesInput | MACNOScalarWhereWithAggregatesInput[]
    OR?: MACNOScalarWhereWithAggregatesInput[]
    NOT?: MACNOScalarWhereWithAggregatesInput | MACNOScalarWhereWithAggregatesInput[]
    macno?: StringWithAggregatesFilter<"MACNO"> | string
    bscd?: StringWithAggregatesFilter<"MACNO"> | string
    macname?: StringWithAggregatesFilter<"MACNO"> | string
  }

  export type ACNOWhereInput = {
    AND?: ACNOWhereInput | ACNOWhereInput[]
    OR?: ACNOWhereInput[]
    NOT?: ACNOWhereInput | ACNOWhereInput[]
    acno?: StringFilter<"ACNO"> | string
    macno?: StringFilter<"ACNO"> | string
    acname?: StringFilter<"ACNO"> | string
    bankAccountNo?: StringNullableFilter<"ACNO"> | string | null
    address?: StringNullableFilter<"ACNO"> | string | null
    city?: StringNullableFilter<"ACNO"> | string | null
    phoneFax?: StringNullableFilter<"ACNO"> | string | null
    email?: StringNullableFilter<"ACNO"> | string | null
    website?: StringNullableFilter<"ACNO"> | string | null
    crDays?: IntNullableFilter<"ACNO"> | number | null
    stRate?: DecimalNullableFilter<"ACNO"> | Decimal | DecimalJsLike | number | string | null
    area?: StringNullableFilter<"ACNO"> | string | null
    category?: StringNullableFilter<"ACNO"> | string | null
    subCategory?: StringNullableFilter<"ACNO"> | string | null
    country?: StringNullableFilter<"ACNO"> | string | null
    customerBank?: StringNullableFilter<"ACNO"> | string | null
    customerBankAddr?: StringNullableFilter<"ACNO"> | string | null
    stRegNo?: StringNullableFilter<"ACNO"> | string | null
    ntnNo?: StringNullableFilter<"ACNO"> | string | null
    contactPerson?: StringNullableFilter<"ACNO"> | string | null
    crLimit?: IntNullableFilter<"ACNO"> | number | null
    salesArea?: StringNullableFilter<"ACNO"> | string | null
    transactionsMaster?: TransactionsMasterListRelationFilter
    transactions?: TransactionsListRelationFilter
    mainAccount?: XOR<MACNOScalarRelationFilter, MACNOWhereInput>
  }

  export type ACNOOrderByWithRelationInput = {
    acno?: SortOrder
    macno?: SortOrder
    acname?: SortOrder
    bankAccountNo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    phoneFax?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    crDays?: SortOrderInput | SortOrder
    stRate?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subCategory?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    customerBank?: SortOrderInput | SortOrder
    customerBankAddr?: SortOrderInput | SortOrder
    stRegNo?: SortOrderInput | SortOrder
    ntnNo?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    crLimit?: SortOrderInput | SortOrder
    salesArea?: SortOrderInput | SortOrder
    transactionsMaster?: TransactionsMasterOrderByRelationAggregateInput
    transactions?: TransactionsOrderByRelationAggregateInput
    mainAccount?: MACNOOrderByWithRelationInput
  }

  export type ACNOWhereUniqueInput = Prisma.AtLeast<{
    acno?: string
    macno_acno?: ACNOMacnoAcnoCompoundUniqueInput
    AND?: ACNOWhereInput | ACNOWhereInput[]
    OR?: ACNOWhereInput[]
    NOT?: ACNOWhereInput | ACNOWhereInput[]
    macno?: StringFilter<"ACNO"> | string
    acname?: StringFilter<"ACNO"> | string
    bankAccountNo?: StringNullableFilter<"ACNO"> | string | null
    address?: StringNullableFilter<"ACNO"> | string | null
    city?: StringNullableFilter<"ACNO"> | string | null
    phoneFax?: StringNullableFilter<"ACNO"> | string | null
    email?: StringNullableFilter<"ACNO"> | string | null
    website?: StringNullableFilter<"ACNO"> | string | null
    crDays?: IntNullableFilter<"ACNO"> | number | null
    stRate?: DecimalNullableFilter<"ACNO"> | Decimal | DecimalJsLike | number | string | null
    area?: StringNullableFilter<"ACNO"> | string | null
    category?: StringNullableFilter<"ACNO"> | string | null
    subCategory?: StringNullableFilter<"ACNO"> | string | null
    country?: StringNullableFilter<"ACNO"> | string | null
    customerBank?: StringNullableFilter<"ACNO"> | string | null
    customerBankAddr?: StringNullableFilter<"ACNO"> | string | null
    stRegNo?: StringNullableFilter<"ACNO"> | string | null
    ntnNo?: StringNullableFilter<"ACNO"> | string | null
    contactPerson?: StringNullableFilter<"ACNO"> | string | null
    crLimit?: IntNullableFilter<"ACNO"> | number | null
    salesArea?: StringNullableFilter<"ACNO"> | string | null
    transactionsMaster?: TransactionsMasterListRelationFilter
    transactions?: TransactionsListRelationFilter
    mainAccount?: XOR<MACNOScalarRelationFilter, MACNOWhereInput>
  }, "macno_acno" | "acno">

  export type ACNOOrderByWithAggregationInput = {
    acno?: SortOrder
    macno?: SortOrder
    acname?: SortOrder
    bankAccountNo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    phoneFax?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    crDays?: SortOrderInput | SortOrder
    stRate?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subCategory?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    customerBank?: SortOrderInput | SortOrder
    customerBankAddr?: SortOrderInput | SortOrder
    stRegNo?: SortOrderInput | SortOrder
    ntnNo?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    crLimit?: SortOrderInput | SortOrder
    salesArea?: SortOrderInput | SortOrder
    _count?: ACNOCountOrderByAggregateInput
    _avg?: ACNOAvgOrderByAggregateInput
    _max?: ACNOMaxOrderByAggregateInput
    _min?: ACNOMinOrderByAggregateInput
    _sum?: ACNOSumOrderByAggregateInput
  }

  export type ACNOScalarWhereWithAggregatesInput = {
    AND?: ACNOScalarWhereWithAggregatesInput | ACNOScalarWhereWithAggregatesInput[]
    OR?: ACNOScalarWhereWithAggregatesInput[]
    NOT?: ACNOScalarWhereWithAggregatesInput | ACNOScalarWhereWithAggregatesInput[]
    acno?: StringWithAggregatesFilter<"ACNO"> | string
    macno?: StringWithAggregatesFilter<"ACNO"> | string
    acname?: StringWithAggregatesFilter<"ACNO"> | string
    bankAccountNo?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    address?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    city?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    phoneFax?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    email?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    website?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    crDays?: IntNullableWithAggregatesFilter<"ACNO"> | number | null
    stRate?: DecimalNullableWithAggregatesFilter<"ACNO"> | Decimal | DecimalJsLike | number | string | null
    area?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    category?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    subCategory?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    country?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    customerBank?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    customerBankAddr?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    stRegNo?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    ntnNo?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
    crLimit?: IntNullableWithAggregatesFilter<"ACNO"> | number | null
    salesArea?: StringNullableWithAggregatesFilter<"ACNO"> | string | null
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    company?: StringNullableFilter<"Company"> | string | null
    addr1?: StringNullableFilter<"Company"> | string | null
    addr2?: StringNullableFilter<"Company"> | string | null
    city?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    fax?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    costCenters?: CostCenterListRelationFilter
    departments?: DepartmentListRelationFilter
    designations?: DesignationListRelationFilter
    godowns?: GodownListRelationFilter
    TransactionsMaster?: TransactionsMasterListRelationFilter
    users?: UsersListRelationFilter
    financialYears?: FinancialYearListRelationFilter
    seasons?: SeasonListRelationFilter
    poPrdCats?: PoPrdCatListRelationFilter
    deliveryModes?: DeliveryModeListRelationFilter
    deliveryTerms?: DeliveryTermListRelationFilter
    commissionTerms?: CommissionTermListRelationFilter
    employees?: EmployeeListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    company?: SortOrderInput | SortOrder
    addr1?: SortOrderInput | SortOrder
    addr2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    costCenters?: CostCenterOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
    designations?: DesignationOrderByRelationAggregateInput
    godowns?: GodownOrderByRelationAggregateInput
    TransactionsMaster?: TransactionsMasterOrderByRelationAggregateInput
    users?: UsersOrderByRelationAggregateInput
    financialYears?: FinancialYearOrderByRelationAggregateInput
    seasons?: SeasonOrderByRelationAggregateInput
    poPrdCats?: PoPrdCatOrderByRelationAggregateInput
    deliveryModes?: DeliveryModeOrderByRelationAggregateInput
    deliveryTerms?: DeliveryTermOrderByRelationAggregateInput
    commissionTerms?: CommissionTermOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    company?: StringNullableFilter<"Company"> | string | null
    addr1?: StringNullableFilter<"Company"> | string | null
    addr2?: StringNullableFilter<"Company"> | string | null
    city?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    fax?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    costCenters?: CostCenterListRelationFilter
    departments?: DepartmentListRelationFilter
    designations?: DesignationListRelationFilter
    godowns?: GodownListRelationFilter
    TransactionsMaster?: TransactionsMasterListRelationFilter
    users?: UsersListRelationFilter
    financialYears?: FinancialYearListRelationFilter
    seasons?: SeasonListRelationFilter
    poPrdCats?: PoPrdCatListRelationFilter
    deliveryModes?: DeliveryModeListRelationFilter
    deliveryTerms?: DeliveryTermListRelationFilter
    commissionTerms?: CommissionTermListRelationFilter
    employees?: EmployeeListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    company?: SortOrderInput | SortOrder
    addr1?: SortOrderInput | SortOrder
    addr2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    company?: StringNullableWithAggregatesFilter<"Company"> | string | null
    addr1?: StringNullableWithAggregatesFilter<"Company"> | string | null
    addr2?: StringNullableWithAggregatesFilter<"Company"> | string | null
    city?: StringNullableWithAggregatesFilter<"Company"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    fax?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
  }

  export type CostCenterWhereInput = {
    AND?: CostCenterWhereInput | CostCenterWhereInput[]
    OR?: CostCenterWhereInput[]
    NOT?: CostCenterWhereInput | CostCenterWhereInput[]
    ccno?: IntFilter<"CostCenter"> | number
    company_id?: IntFilter<"CostCenter"> | number
    ccname?: StringNullableFilter<"CostCenter"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    Transaction?: TransactionsListRelationFilter
  }

  export type CostCenterOrderByWithRelationInput = {
    ccno?: SortOrder
    company_id?: SortOrder
    ccname?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    Transaction?: TransactionsOrderByRelationAggregateInput
  }

  export type CostCenterWhereUniqueInput = Prisma.AtLeast<{
    ccno?: number
    AND?: CostCenterWhereInput | CostCenterWhereInput[]
    OR?: CostCenterWhereInput[]
    NOT?: CostCenterWhereInput | CostCenterWhereInput[]
    company_id?: IntFilter<"CostCenter"> | number
    ccname?: StringNullableFilter<"CostCenter"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    Transaction?: TransactionsListRelationFilter
  }, "ccno">

  export type CostCenterOrderByWithAggregationInput = {
    ccno?: SortOrder
    company_id?: SortOrder
    ccname?: SortOrderInput | SortOrder
    _count?: CostCenterCountOrderByAggregateInput
    _avg?: CostCenterAvgOrderByAggregateInput
    _max?: CostCenterMaxOrderByAggregateInput
    _min?: CostCenterMinOrderByAggregateInput
    _sum?: CostCenterSumOrderByAggregateInput
  }

  export type CostCenterScalarWhereWithAggregatesInput = {
    AND?: CostCenterScalarWhereWithAggregatesInput | CostCenterScalarWhereWithAggregatesInput[]
    OR?: CostCenterScalarWhereWithAggregatesInput[]
    NOT?: CostCenterScalarWhereWithAggregatesInput | CostCenterScalarWhereWithAggregatesInput[]
    ccno?: IntWithAggregatesFilter<"CostCenter"> | number
    company_id?: IntWithAggregatesFilter<"CostCenter"> | number
    ccname?: StringNullableWithAggregatesFilter<"CostCenter"> | string | null
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    dept_name?: StringNullableFilter<"Department"> | string | null
    company_id?: IntFilter<"Department"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    dept_name?: SortOrderInput | SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    dept_name?: StringNullableFilter<"Department"> | string | null
    company_id?: IntFilter<"Department"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    dept_name?: SortOrderInput | SortOrder
    company_id?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    dept_name?: StringNullableWithAggregatesFilter<"Department"> | string | null
    company_id?: IntWithAggregatesFilter<"Department"> | number
  }

  export type ProductMasterCategoryWhereInput = {
    AND?: ProductMasterCategoryWhereInput | ProductMasterCategoryWhereInput[]
    OR?: ProductMasterCategoryWhereInput[]
    NOT?: ProductMasterCategoryWhereInput | ProductMasterCategoryWhereInput[]
    id?: IntFilter<"ProductMasterCategory"> | number
    pmc_name?: StringNullableFilter<"ProductMasterCategory"> | string | null
    productGroups?: ProductGroupListRelationFilter
  }

  export type ProductMasterCategoryOrderByWithRelationInput = {
    id?: SortOrder
    pmc_name?: SortOrderInput | SortOrder
    productGroups?: ProductGroupOrderByRelationAggregateInput
  }

  export type ProductMasterCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductMasterCategoryWhereInput | ProductMasterCategoryWhereInput[]
    OR?: ProductMasterCategoryWhereInput[]
    NOT?: ProductMasterCategoryWhereInput | ProductMasterCategoryWhereInput[]
    pmc_name?: StringNullableFilter<"ProductMasterCategory"> | string | null
    productGroups?: ProductGroupListRelationFilter
  }, "id">

  export type ProductMasterCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    pmc_name?: SortOrderInput | SortOrder
    _count?: ProductMasterCategoryCountOrderByAggregateInput
    _avg?: ProductMasterCategoryAvgOrderByAggregateInput
    _max?: ProductMasterCategoryMaxOrderByAggregateInput
    _min?: ProductMasterCategoryMinOrderByAggregateInput
    _sum?: ProductMasterCategorySumOrderByAggregateInput
  }

  export type ProductMasterCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductMasterCategoryScalarWhereWithAggregatesInput | ProductMasterCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductMasterCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductMasterCategoryScalarWhereWithAggregatesInput | ProductMasterCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductMasterCategory"> | number
    pmc_name?: StringNullableWithAggregatesFilter<"ProductMasterCategory"> | string | null
  }

  export type ProductGroupWhereInput = {
    AND?: ProductGroupWhereInput | ProductGroupWhereInput[]
    OR?: ProductGroupWhereInput[]
    NOT?: ProductGroupWhereInput | ProductGroupWhereInput[]
    id?: IntFilter<"ProductGroup"> | number
    pg_name?: StringNullableFilter<"ProductGroup"> | string | null
    pmc_id?: IntFilter<"ProductGroup"> | number
    productCategories?: ProductCategoryListRelationFilter
    ProductMasterCategories?: XOR<ProductMasterCategoryScalarRelationFilter, ProductMasterCategoryWhereInput>
  }

  export type ProductGroupOrderByWithRelationInput = {
    id?: SortOrder
    pg_name?: SortOrderInput | SortOrder
    pmc_id?: SortOrder
    productCategories?: ProductCategoryOrderByRelationAggregateInput
    ProductMasterCategories?: ProductMasterCategoryOrderByWithRelationInput
  }

  export type ProductGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductGroupWhereInput | ProductGroupWhereInput[]
    OR?: ProductGroupWhereInput[]
    NOT?: ProductGroupWhereInput | ProductGroupWhereInput[]
    pg_name?: StringNullableFilter<"ProductGroup"> | string | null
    pmc_id?: IntFilter<"ProductGroup"> | number
    productCategories?: ProductCategoryListRelationFilter
    ProductMasterCategories?: XOR<ProductMasterCategoryScalarRelationFilter, ProductMasterCategoryWhereInput>
  }, "id">

  export type ProductGroupOrderByWithAggregationInput = {
    id?: SortOrder
    pg_name?: SortOrderInput | SortOrder
    pmc_id?: SortOrder
    _count?: ProductGroupCountOrderByAggregateInput
    _avg?: ProductGroupAvgOrderByAggregateInput
    _max?: ProductGroupMaxOrderByAggregateInput
    _min?: ProductGroupMinOrderByAggregateInput
    _sum?: ProductGroupSumOrderByAggregateInput
  }

  export type ProductGroupScalarWhereWithAggregatesInput = {
    AND?: ProductGroupScalarWhereWithAggregatesInput | ProductGroupScalarWhereWithAggregatesInput[]
    OR?: ProductGroupScalarWhereWithAggregatesInput[]
    NOT?: ProductGroupScalarWhereWithAggregatesInput | ProductGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductGroup"> | number
    pg_name?: StringNullableWithAggregatesFilter<"ProductGroup"> | string | null
    pmc_id?: IntWithAggregatesFilter<"ProductGroup"> | number
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    pc_name?: StringNullableFilter<"ProductCategory"> | string | null
    pg_id?: IntFilter<"ProductCategory"> | number
    mainCategories?: MainCategoryListRelationFilter
    ProductGroups?: XOR<ProductGroupScalarRelationFilter, ProductGroupWhereInput>
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    pc_name?: SortOrderInput | SortOrder
    pg_id?: SortOrder
    mainCategories?: MainCategoryOrderByRelationAggregateInput
    ProductGroups?: ProductGroupOrderByWithRelationInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    pc_name?: StringNullableFilter<"ProductCategory"> | string | null
    pg_id?: IntFilter<"ProductCategory"> | number
    mainCategories?: MainCategoryListRelationFilter
    ProductGroups?: XOR<ProductGroupScalarRelationFilter, ProductGroupWhereInput>
  }, "id">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    pc_name?: SortOrderInput | SortOrder
    pg_id?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductCategory"> | number
    pc_name?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    pg_id?: IntWithAggregatesFilter<"ProductCategory"> | number
  }

  export type MainCategoryWhereInput = {
    AND?: MainCategoryWhereInput | MainCategoryWhereInput[]
    OR?: MainCategoryWhereInput[]
    NOT?: MainCategoryWhereInput | MainCategoryWhereInput[]
    id?: IntFilter<"MainCategory"> | number
    mc_name?: StringNullableFilter<"MainCategory"> | string | null
    pc_id?: IntFilter<"MainCategory"> | number
    itemCategories?: ItemCategoryListRelationFilter
    ProductCategories?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }

  export type MainCategoryOrderByWithRelationInput = {
    id?: SortOrder
    mc_name?: SortOrderInput | SortOrder
    pc_id?: SortOrder
    itemCategories?: ItemCategoryOrderByRelationAggregateInput
    ProductCategories?: ProductCategoryOrderByWithRelationInput
  }

  export type MainCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MainCategoryWhereInput | MainCategoryWhereInput[]
    OR?: MainCategoryWhereInput[]
    NOT?: MainCategoryWhereInput | MainCategoryWhereInput[]
    mc_name?: StringNullableFilter<"MainCategory"> | string | null
    pc_id?: IntFilter<"MainCategory"> | number
    itemCategories?: ItemCategoryListRelationFilter
    ProductCategories?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }, "id">

  export type MainCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    mc_name?: SortOrderInput | SortOrder
    pc_id?: SortOrder
    _count?: MainCategoryCountOrderByAggregateInput
    _avg?: MainCategoryAvgOrderByAggregateInput
    _max?: MainCategoryMaxOrderByAggregateInput
    _min?: MainCategoryMinOrderByAggregateInput
    _sum?: MainCategorySumOrderByAggregateInput
  }

  export type MainCategoryScalarWhereWithAggregatesInput = {
    AND?: MainCategoryScalarWhereWithAggregatesInput | MainCategoryScalarWhereWithAggregatesInput[]
    OR?: MainCategoryScalarWhereWithAggregatesInput[]
    NOT?: MainCategoryScalarWhereWithAggregatesInput | MainCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MainCategory"> | number
    mc_name?: StringNullableWithAggregatesFilter<"MainCategory"> | string | null
    pc_id?: IntWithAggregatesFilter<"MainCategory"> | number
  }

  export type ItemCategoryWhereInput = {
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    id?: IntFilter<"ItemCategory"> | number
    ic_name?: StringFilter<"ItemCategory"> | string
    mc_id?: IntFilter<"ItemCategory"> | number
    wc_category_id?: IntNullableFilter<"ItemCategory"> | number | null
    sync_status?: StringNullableFilter<"ItemCategory"> | string | null
    last_sync?: DateTimeNullableFilter<"ItemCategory"> | Date | string | null
    mainCategory?: XOR<MainCategoryScalarRelationFilter, MainCategoryWhereInput>
    items?: ItemListRelationFilter
  }

  export type ItemCategoryOrderByWithRelationInput = {
    id?: SortOrder
    ic_name?: SortOrder
    mc_id?: SortOrder
    wc_category_id?: SortOrderInput | SortOrder
    sync_status?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    mainCategory?: MainCategoryOrderByWithRelationInput
    items?: ItemOrderByRelationAggregateInput
  }

  export type ItemCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    wc_category_id?: number
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    ic_name?: StringFilter<"ItemCategory"> | string
    mc_id?: IntFilter<"ItemCategory"> | number
    sync_status?: StringNullableFilter<"ItemCategory"> | string | null
    last_sync?: DateTimeNullableFilter<"ItemCategory"> | Date | string | null
    mainCategory?: XOR<MainCategoryScalarRelationFilter, MainCategoryWhereInput>
    items?: ItemListRelationFilter
  }, "id" | "wc_category_id">

  export type ItemCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    ic_name?: SortOrder
    mc_id?: SortOrder
    wc_category_id?: SortOrderInput | SortOrder
    sync_status?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    _count?: ItemCategoryCountOrderByAggregateInput
    _avg?: ItemCategoryAvgOrderByAggregateInput
    _max?: ItemCategoryMaxOrderByAggregateInput
    _min?: ItemCategoryMinOrderByAggregateInput
    _sum?: ItemCategorySumOrderByAggregateInput
  }

  export type ItemCategoryScalarWhereWithAggregatesInput = {
    AND?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    OR?: ItemCategoryScalarWhereWithAggregatesInput[]
    NOT?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemCategory"> | number
    ic_name?: StringWithAggregatesFilter<"ItemCategory"> | string
    mc_id?: IntWithAggregatesFilter<"ItemCategory"> | number
    wc_category_id?: IntNullableWithAggregatesFilter<"ItemCategory"> | number | null
    sync_status?: StringNullableWithAggregatesFilter<"ItemCategory"> | string | null
    last_sync?: DateTimeNullableWithAggregatesFilter<"ItemCategory"> | Date | string | null
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    itcd?: IntFilter<"Item"> | number
    item?: StringNullableFilter<"Item"> | string | null
    ic_id?: IntFilter<"Item"> | number
    sku?: StringNullableFilter<"Item"> | string | null
    price?: FloatNullableFilter<"Item"> | number | null
    stock?: IntNullableFilter<"Item"> | number | null
    wc_product_id?: IntNullableFilter<"Item"> | number | null
    wc_parent_id?: IntNullableFilter<"Item"> | number | null
    sync_status?: StringNullableFilter<"Item"> | string | null
    last_sync?: DateTimeNullableFilter<"Item"> | Date | string | null
    itemCategories?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
    Transactions?: TransactionsListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    itcd?: SortOrder
    item?: SortOrderInput | SortOrder
    ic_id?: SortOrder
    sku?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    wc_product_id?: SortOrderInput | SortOrder
    wc_parent_id?: SortOrderInput | SortOrder
    sync_status?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    itemCategories?: ItemCategoryOrderByWithRelationInput
    Transactions?: TransactionsOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    itcd?: number
    sku?: string
    wc_product_id?: number
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    item?: StringNullableFilter<"Item"> | string | null
    ic_id?: IntFilter<"Item"> | number
    price?: FloatNullableFilter<"Item"> | number | null
    stock?: IntNullableFilter<"Item"> | number | null
    wc_parent_id?: IntNullableFilter<"Item"> | number | null
    sync_status?: StringNullableFilter<"Item"> | string | null
    last_sync?: DateTimeNullableFilter<"Item"> | Date | string | null
    itemCategories?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
    Transactions?: TransactionsListRelationFilter
  }, "itcd" | "itcd" | "sku" | "wc_product_id">

  export type ItemOrderByWithAggregationInput = {
    itcd?: SortOrder
    item?: SortOrderInput | SortOrder
    ic_id?: SortOrder
    sku?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    wc_product_id?: SortOrderInput | SortOrder
    wc_parent_id?: SortOrderInput | SortOrder
    sync_status?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    itcd?: IntWithAggregatesFilter<"Item"> | number
    item?: StringNullableWithAggregatesFilter<"Item"> | string | null
    ic_id?: IntWithAggregatesFilter<"Item"> | number
    sku?: StringNullableWithAggregatesFilter<"Item"> | string | null
    price?: FloatNullableWithAggregatesFilter<"Item"> | number | null
    stock?: IntNullableWithAggregatesFilter<"Item"> | number | null
    wc_product_id?: IntNullableWithAggregatesFilter<"Item"> | number | null
    wc_parent_id?: IntNullableWithAggregatesFilter<"Item"> | number | null
    sync_status?: StringNullableWithAggregatesFilter<"Item"> | string | null
    last_sync?: DateTimeNullableWithAggregatesFilter<"Item"> | Date | string | null
  }

  export type DesignationWhereInput = {
    AND?: DesignationWhereInput | DesignationWhereInput[]
    OR?: DesignationWhereInput[]
    NOT?: DesignationWhereInput | DesignationWhereInput[]
    id?: IntFilter<"Designation"> | number
    desg_name?: StringNullableFilter<"Designation"> | string | null
    company_id?: IntFilter<"Designation"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DesignationOrderByWithRelationInput = {
    id?: SortOrder
    desg_name?: SortOrderInput | SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type DesignationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DesignationWhereInput | DesignationWhereInput[]
    OR?: DesignationWhereInput[]
    NOT?: DesignationWhereInput | DesignationWhereInput[]
    desg_name?: StringNullableFilter<"Designation"> | string | null
    company_id?: IntFilter<"Designation"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DesignationOrderByWithAggregationInput = {
    id?: SortOrder
    desg_name?: SortOrderInput | SortOrder
    company_id?: SortOrder
    _count?: DesignationCountOrderByAggregateInput
    _avg?: DesignationAvgOrderByAggregateInput
    _max?: DesignationMaxOrderByAggregateInput
    _min?: DesignationMinOrderByAggregateInput
    _sum?: DesignationSumOrderByAggregateInput
  }

  export type DesignationScalarWhereWithAggregatesInput = {
    AND?: DesignationScalarWhereWithAggregatesInput | DesignationScalarWhereWithAggregatesInput[]
    OR?: DesignationScalarWhereWithAggregatesInput[]
    NOT?: DesignationScalarWhereWithAggregatesInput | DesignationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Designation"> | number
    desg_name?: StringNullableWithAggregatesFilter<"Designation"> | string | null
    company_id?: IntWithAggregatesFilter<"Designation"> | number
  }

  export type GodownWhereInput = {
    AND?: GodownWhereInput | GodownWhereInput[]
    OR?: GodownWhereInput[]
    NOT?: GodownWhereInput | GodownWhereInput[]
    id?: IntFilter<"Godown"> | number
    godown?: StringFilter<"Godown"> | string
    company_id?: IntFilter<"Godown"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    TransactionsMaster?: TransactionsMasterListRelationFilter
    Transaction?: TransactionsListRelationFilter
  }

  export type GodownOrderByWithRelationInput = {
    id?: SortOrder
    godown?: SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
    TransactionsMaster?: TransactionsMasterOrderByRelationAggregateInput
    Transaction?: TransactionsOrderByRelationAggregateInput
  }

  export type GodownWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GodownWhereInput | GodownWhereInput[]
    OR?: GodownWhereInput[]
    NOT?: GodownWhereInput | GodownWhereInput[]
    godown?: StringFilter<"Godown"> | string
    company_id?: IntFilter<"Godown"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    TransactionsMaster?: TransactionsMasterListRelationFilter
    Transaction?: TransactionsListRelationFilter
  }, "id">

  export type GodownOrderByWithAggregationInput = {
    id?: SortOrder
    godown?: SortOrder
    company_id?: SortOrder
    _count?: GodownCountOrderByAggregateInput
    _avg?: GodownAvgOrderByAggregateInput
    _max?: GodownMaxOrderByAggregateInput
    _min?: GodownMinOrderByAggregateInput
    _sum?: GodownSumOrderByAggregateInput
  }

  export type GodownScalarWhereWithAggregatesInput = {
    AND?: GodownScalarWhereWithAggregatesInput | GodownScalarWhereWithAggregatesInput[]
    OR?: GodownScalarWhereWithAggregatesInput[]
    NOT?: GodownScalarWhereWithAggregatesInput | GodownScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Godown"> | number
    godown?: StringWithAggregatesFilter<"Godown"> | string
    company_id?: IntWithAggregatesFilter<"Godown"> | number
  }

  export type FinancialYearWhereInput = {
    AND?: FinancialYearWhereInput | FinancialYearWhereInput[]
    OR?: FinancialYearWhereInput[]
    NOT?: FinancialYearWhereInput | FinancialYearWhereInput[]
    id?: IntFilter<"FinancialYear"> | number
    date_from?: DateTimeFilter<"FinancialYear"> | Date | string
    date_to?: DateTimeFilter<"FinancialYear"> | Date | string
    status?: StringFilter<"FinancialYear"> | string
    company_id?: IntFilter<"FinancialYear"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type FinancialYearOrderByWithRelationInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type FinancialYearWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FinancialYearWhereInput | FinancialYearWhereInput[]
    OR?: FinancialYearWhereInput[]
    NOT?: FinancialYearWhereInput | FinancialYearWhereInput[]
    date_from?: DateTimeFilter<"FinancialYear"> | Date | string
    date_to?: DateTimeFilter<"FinancialYear"> | Date | string
    status?: StringFilter<"FinancialYear"> | string
    company_id?: IntFilter<"FinancialYear"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type FinancialYearOrderByWithAggregationInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
    _count?: FinancialYearCountOrderByAggregateInput
    _avg?: FinancialYearAvgOrderByAggregateInput
    _max?: FinancialYearMaxOrderByAggregateInput
    _min?: FinancialYearMinOrderByAggregateInput
    _sum?: FinancialYearSumOrderByAggregateInput
  }

  export type FinancialYearScalarWhereWithAggregatesInput = {
    AND?: FinancialYearScalarWhereWithAggregatesInput | FinancialYearScalarWhereWithAggregatesInput[]
    OR?: FinancialYearScalarWhereWithAggregatesInput[]
    NOT?: FinancialYearScalarWhereWithAggregatesInput | FinancialYearScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinancialYear"> | number
    date_from?: DateTimeWithAggregatesFilter<"FinancialYear"> | Date | string
    date_to?: DateTimeWithAggregatesFilter<"FinancialYear"> | Date | string
    status?: StringWithAggregatesFilter<"FinancialYear"> | string
    company_id?: IntWithAggregatesFilter<"FinancialYear"> | number
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: IntFilter<"Season"> | number
    date_from?: DateTimeFilter<"Season"> | Date | string
    date_to?: DateTimeFilter<"Season"> | Date | string
    status?: StringFilter<"Season"> | string
    company_id?: IntFilter<"Season"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    date_from?: DateTimeFilter<"Season"> | Date | string
    date_to?: DateTimeFilter<"Season"> | Date | string
    status?: StringFilter<"Season"> | string
    company_id?: IntFilter<"Season"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _avg?: SeasonAvgOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
    _sum?: SeasonSumOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Season"> | number
    date_from?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    date_to?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    status?: StringWithAggregatesFilter<"Season"> | string
    company_id?: IntWithAggregatesFilter<"Season"> | number
  }

  export type PoPrdCatWhereInput = {
    AND?: PoPrdCatWhereInput | PoPrdCatWhereInput[]
    OR?: PoPrdCatWhereInput[]
    NOT?: PoPrdCatWhereInput | PoPrdCatWhereInput[]
    id?: IntFilter<"PoPrdCat"> | number
    category_name?: StringFilter<"PoPrdCat"> | string
    company_id?: IntFilter<"PoPrdCat"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type PoPrdCatOrderByWithRelationInput = {
    id?: SortOrder
    category_name?: SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type PoPrdCatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PoPrdCatWhereInput | PoPrdCatWhereInput[]
    OR?: PoPrdCatWhereInput[]
    NOT?: PoPrdCatWhereInput | PoPrdCatWhereInput[]
    category_name?: StringFilter<"PoPrdCat"> | string
    company_id?: IntFilter<"PoPrdCat"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type PoPrdCatOrderByWithAggregationInput = {
    id?: SortOrder
    category_name?: SortOrder
    company_id?: SortOrder
    _count?: PoPrdCatCountOrderByAggregateInput
    _avg?: PoPrdCatAvgOrderByAggregateInput
    _max?: PoPrdCatMaxOrderByAggregateInput
    _min?: PoPrdCatMinOrderByAggregateInput
    _sum?: PoPrdCatSumOrderByAggregateInput
  }

  export type PoPrdCatScalarWhereWithAggregatesInput = {
    AND?: PoPrdCatScalarWhereWithAggregatesInput | PoPrdCatScalarWhereWithAggregatesInput[]
    OR?: PoPrdCatScalarWhereWithAggregatesInput[]
    NOT?: PoPrdCatScalarWhereWithAggregatesInput | PoPrdCatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PoPrdCat"> | number
    category_name?: StringWithAggregatesFilter<"PoPrdCat"> | string
    company_id?: IntWithAggregatesFilter<"PoPrdCat"> | number
  }

  export type DeliveryModeWhereInput = {
    AND?: DeliveryModeWhereInput | DeliveryModeWhereInput[]
    OR?: DeliveryModeWhereInput[]
    NOT?: DeliveryModeWhereInput | DeliveryModeWhereInput[]
    id?: IntFilter<"DeliveryMode"> | number
    delivery_mode?: StringFilter<"DeliveryMode"> | string
    rate_kg?: IntFilter<"DeliveryMode"> | number
    company_id?: IntFilter<"DeliveryMode"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DeliveryModeOrderByWithRelationInput = {
    id?: SortOrder
    delivery_mode?: SortOrder
    rate_kg?: SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type DeliveryModeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeliveryModeWhereInput | DeliveryModeWhereInput[]
    OR?: DeliveryModeWhereInput[]
    NOT?: DeliveryModeWhereInput | DeliveryModeWhereInput[]
    delivery_mode?: StringFilter<"DeliveryMode"> | string
    rate_kg?: IntFilter<"DeliveryMode"> | number
    company_id?: IntFilter<"DeliveryMode"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DeliveryModeOrderByWithAggregationInput = {
    id?: SortOrder
    delivery_mode?: SortOrder
    rate_kg?: SortOrder
    company_id?: SortOrder
    _count?: DeliveryModeCountOrderByAggregateInput
    _avg?: DeliveryModeAvgOrderByAggregateInput
    _max?: DeliveryModeMaxOrderByAggregateInput
    _min?: DeliveryModeMinOrderByAggregateInput
    _sum?: DeliveryModeSumOrderByAggregateInput
  }

  export type DeliveryModeScalarWhereWithAggregatesInput = {
    AND?: DeliveryModeScalarWhereWithAggregatesInput | DeliveryModeScalarWhereWithAggregatesInput[]
    OR?: DeliveryModeScalarWhereWithAggregatesInput[]
    NOT?: DeliveryModeScalarWhereWithAggregatesInput | DeliveryModeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeliveryMode"> | number
    delivery_mode?: StringWithAggregatesFilter<"DeliveryMode"> | string
    rate_kg?: IntWithAggregatesFilter<"DeliveryMode"> | number
    company_id?: IntWithAggregatesFilter<"DeliveryMode"> | number
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    user_id?: StringFilter<"Users"> | string
    user_name?: StringNullableFilter<"Users"> | string | null
    company_id?: IntFilter<"Users"> | number
    transactionsMaster?: TransactionsMasterListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type UsersOrderByWithRelationInput = {
    user_id?: SortOrder
    user_name?: SortOrderInput | SortOrder
    company_id?: SortOrder
    transactionsMaster?: TransactionsMasterOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    user_name?: StringNullableFilter<"Users"> | string | null
    company_id?: IntFilter<"Users"> | number
    transactionsMaster?: TransactionsMasterListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "user_id" | "user_id">

  export type UsersOrderByWithAggregationInput = {
    user_id?: SortOrder
    user_name?: SortOrderInput | SortOrder
    company_id?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"Users"> | string
    user_name?: StringNullableWithAggregatesFilter<"Users"> | string | null
    company_id?: IntWithAggregatesFilter<"Users"> | number
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: IntFilter<"Currency"> | number
    currency?: StringFilter<"Currency"> | string
    transactions?: TransactionsListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    currency?: SortOrder
    transactions?: TransactionsOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    currency?: string
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    transactions?: TransactionsListRelationFilter
  }, "id" | "id" | "currency">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    currency?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Currency"> | number
    currency?: StringWithAggregatesFilter<"Currency"> | string
  }

  export type TransactionsMasterWhereInput = {
    AND?: TransactionsMasterWhereInput | TransactionsMasterWhereInput[]
    OR?: TransactionsMasterWhereInput[]
    NOT?: TransactionsMasterWhereInput | TransactionsMasterWhereInput[]
    tran_id?: IntFilter<"TransactionsMaster"> | number
    company_id?: IntNullableFilter<"TransactionsMaster"> | number | null
    dateD?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    time?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    tran_code?: IntNullableFilter<"TransactionsMaster"> | number | null
    vr_no?: IntNullableFilter<"TransactionsMaster"> | number | null
    pycd?: StringNullableFilter<"TransactionsMaster"> | string | null
    check_no?: StringNullableFilter<"TransactionsMaster"> | string | null
    check_date?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    rmk?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk1?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk2?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk3?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk4?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk5?: StringNullableFilter<"TransactionsMaster"> | string | null
    userId?: StringNullableFilter<"TransactionsMaster"> | string | null
    invoice_no?: StringNullableFilter<"TransactionsMaster"> | string | null
    godown?: IntNullableFilter<"TransactionsMaster"> | number | null
    wc_order_id?: IntNullableFilter<"TransactionsMaster"> | number | null
    sync_status?: StringNullableFilter<"TransactionsMaster"> | string | null
    last_sync?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    user?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    godownDetails?: XOR<GodownNullableScalarRelationFilter, GodownWhereInput> | null
    acno?: XOR<ACNONullableScalarRelationFilter, ACNOWhereInput> | null
    transactions?: TransactionsListRelationFilter
  }

  export type TransactionsMasterOrderByWithRelationInput = {
    tran_id?: SortOrder
    company_id?: SortOrderInput | SortOrder
    dateD?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    tran_code?: SortOrderInput | SortOrder
    vr_no?: SortOrderInput | SortOrder
    pycd?: SortOrderInput | SortOrder
    check_no?: SortOrderInput | SortOrder
    check_date?: SortOrderInput | SortOrder
    rmk?: SortOrderInput | SortOrder
    rmk1?: SortOrderInput | SortOrder
    rmk2?: SortOrderInput | SortOrder
    rmk3?: SortOrderInput | SortOrder
    rmk4?: SortOrderInput | SortOrder
    rmk5?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    invoice_no?: SortOrderInput | SortOrder
    godown?: SortOrderInput | SortOrder
    wc_order_id?: SortOrderInput | SortOrder
    sync_status?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    user?: UsersOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    godownDetails?: GodownOrderByWithRelationInput
    acno?: ACNOOrderByWithRelationInput
    transactions?: TransactionsOrderByRelationAggregateInput
  }

  export type TransactionsMasterWhereUniqueInput = Prisma.AtLeast<{
    tran_id?: number
    wc_order_id?: number
    tran_code_vr_no?: TransactionsMasterTran_codeVr_noCompoundUniqueInput
    AND?: TransactionsMasterWhereInput | TransactionsMasterWhereInput[]
    OR?: TransactionsMasterWhereInput[]
    NOT?: TransactionsMasterWhereInput | TransactionsMasterWhereInput[]
    company_id?: IntNullableFilter<"TransactionsMaster"> | number | null
    dateD?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    time?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    tran_code?: IntNullableFilter<"TransactionsMaster"> | number | null
    vr_no?: IntNullableFilter<"TransactionsMaster"> | number | null
    pycd?: StringNullableFilter<"TransactionsMaster"> | string | null
    check_no?: StringNullableFilter<"TransactionsMaster"> | string | null
    check_date?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    rmk?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk1?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk2?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk3?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk4?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk5?: StringNullableFilter<"TransactionsMaster"> | string | null
    userId?: StringNullableFilter<"TransactionsMaster"> | string | null
    invoice_no?: StringNullableFilter<"TransactionsMaster"> | string | null
    godown?: IntNullableFilter<"TransactionsMaster"> | number | null
    sync_status?: StringNullableFilter<"TransactionsMaster"> | string | null
    last_sync?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    user?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    godownDetails?: XOR<GodownNullableScalarRelationFilter, GodownWhereInput> | null
    acno?: XOR<ACNONullableScalarRelationFilter, ACNOWhereInput> | null
    transactions?: TransactionsListRelationFilter
  }, "tran_id" | "wc_order_id" | "tran_code_vr_no">

  export type TransactionsMasterOrderByWithAggregationInput = {
    tran_id?: SortOrder
    company_id?: SortOrderInput | SortOrder
    dateD?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    tran_code?: SortOrderInput | SortOrder
    vr_no?: SortOrderInput | SortOrder
    pycd?: SortOrderInput | SortOrder
    check_no?: SortOrderInput | SortOrder
    check_date?: SortOrderInput | SortOrder
    rmk?: SortOrderInput | SortOrder
    rmk1?: SortOrderInput | SortOrder
    rmk2?: SortOrderInput | SortOrder
    rmk3?: SortOrderInput | SortOrder
    rmk4?: SortOrderInput | SortOrder
    rmk5?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    invoice_no?: SortOrderInput | SortOrder
    godown?: SortOrderInput | SortOrder
    wc_order_id?: SortOrderInput | SortOrder
    sync_status?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    _count?: TransactionsMasterCountOrderByAggregateInput
    _avg?: TransactionsMasterAvgOrderByAggregateInput
    _max?: TransactionsMasterMaxOrderByAggregateInput
    _min?: TransactionsMasterMinOrderByAggregateInput
    _sum?: TransactionsMasterSumOrderByAggregateInput
  }

  export type TransactionsMasterScalarWhereWithAggregatesInput = {
    AND?: TransactionsMasterScalarWhereWithAggregatesInput | TransactionsMasterScalarWhereWithAggregatesInput[]
    OR?: TransactionsMasterScalarWhereWithAggregatesInput[]
    NOT?: TransactionsMasterScalarWhereWithAggregatesInput | TransactionsMasterScalarWhereWithAggregatesInput[]
    tran_id?: IntWithAggregatesFilter<"TransactionsMaster"> | number
    company_id?: IntNullableWithAggregatesFilter<"TransactionsMaster"> | number | null
    dateD?: DateTimeNullableWithAggregatesFilter<"TransactionsMaster"> | Date | string | null
    time?: DateTimeNullableWithAggregatesFilter<"TransactionsMaster"> | Date | string | null
    tran_code?: IntNullableWithAggregatesFilter<"TransactionsMaster"> | number | null
    vr_no?: IntNullableWithAggregatesFilter<"TransactionsMaster"> | number | null
    pycd?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    check_no?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    check_date?: DateTimeNullableWithAggregatesFilter<"TransactionsMaster"> | Date | string | null
    rmk?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    rmk1?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    rmk2?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    rmk3?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    rmk4?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    rmk5?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    userId?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    invoice_no?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    godown?: IntNullableWithAggregatesFilter<"TransactionsMaster"> | number | null
    wc_order_id?: IntNullableWithAggregatesFilter<"TransactionsMaster"> | number | null
    sync_status?: StringNullableWithAggregatesFilter<"TransactionsMaster"> | string | null
    last_sync?: DateTimeNullableWithAggregatesFilter<"TransactionsMaster"> | Date | string | null
  }

  export type TransactionsWhereInput = {
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    id?: IntFilter<"Transactions"> | number
    tran_id?: IntFilter<"Transactions"> | number
    acno?: StringNullableFilter<"Transactions"> | string | null
    itcd?: IntNullableFilter<"Transactions"> | number | null
    ccno?: IntNullableFilter<"Transactions"> | number | null
    narration1?: StringNullableFilter<"Transactions"> | string | null
    narration2?: StringNullableFilter<"Transactions"> | string | null
    narration3?: StringNullableFilter<"Transactions"> | string | null
    narration4?: StringNullableFilter<"Transactions"> | string | null
    narration5?: StringNullableFilter<"Transactions"> | string | null
    chno?: StringNullableFilter<"Transactions"> | string | null
    check_date?: DateTimeNullableFilter<"Transactions"> | Date | string | null
    party_name?: StringNullableFilter<"Transactions"> | string | null
    damt?: FloatNullableFilter<"Transactions"> | number | null
    camt?: FloatNullableFilter<"Transactions"> | number | null
    qty?: FloatNullableFilter<"Transactions"> | number | null
    rate?: FloatNullableFilter<"Transactions"> | number | null
    wht_rate?: FloatNullableFilter<"Transactions"> | number | null
    st_rate?: FloatNullableFilter<"Transactions"> | number | null
    godown?: IntNullableFilter<"Transactions"> | number | null
    invoice_no?: StringNullableFilter<"Transactions"> | string | null
    sub_tran_id?: IntNullableFilter<"Transactions"> | number | null
    currency?: IntNullableFilter<"Transactions"> | number | null
    gross_amount?: FloatNullableFilter<"Transactions"> | number | null
    fc_amount?: FloatNullableFilter<"Transactions"> | number | null
    no_of_pack?: FloatNullableFilter<"Transactions"> | number | null
    qty_per_pack?: FloatNullableFilter<"Transactions"> | number | null
    st_amount?: FloatNullableFilter<"Transactions"> | number | null
    additional_tax?: FloatNullableFilter<"Transactions"> | number | null
    acnoDetails?: XOR<ACNONullableScalarRelationFilter, ACNOWhereInput> | null
    costCenter?: XOR<CostCenterNullableScalarRelationFilter, CostCenterWhereInput> | null
    currencyDetails?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    godownDetails?: XOR<GodownNullableScalarRelationFilter, GodownWhereInput> | null
    itemDetails?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    transactionsMaster?: XOR<TransactionsMasterScalarRelationFilter, TransactionsMasterWhereInput>
  }

  export type TransactionsOrderByWithRelationInput = {
    id?: SortOrder
    tran_id?: SortOrder
    acno?: SortOrderInput | SortOrder
    itcd?: SortOrderInput | SortOrder
    ccno?: SortOrderInput | SortOrder
    narration1?: SortOrderInput | SortOrder
    narration2?: SortOrderInput | SortOrder
    narration3?: SortOrderInput | SortOrder
    narration4?: SortOrderInput | SortOrder
    narration5?: SortOrderInput | SortOrder
    chno?: SortOrderInput | SortOrder
    check_date?: SortOrderInput | SortOrder
    party_name?: SortOrderInput | SortOrder
    damt?: SortOrderInput | SortOrder
    camt?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    wht_rate?: SortOrderInput | SortOrder
    st_rate?: SortOrderInput | SortOrder
    godown?: SortOrderInput | SortOrder
    invoice_no?: SortOrderInput | SortOrder
    sub_tran_id?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    gross_amount?: SortOrderInput | SortOrder
    fc_amount?: SortOrderInput | SortOrder
    no_of_pack?: SortOrderInput | SortOrder
    qty_per_pack?: SortOrderInput | SortOrder
    st_amount?: SortOrderInput | SortOrder
    additional_tax?: SortOrderInput | SortOrder
    acnoDetails?: ACNOOrderByWithRelationInput
    costCenter?: CostCenterOrderByWithRelationInput
    currencyDetails?: CurrencyOrderByWithRelationInput
    godownDetails?: GodownOrderByWithRelationInput
    itemDetails?: ItemOrderByWithRelationInput
    transactionsMaster?: TransactionsMasterOrderByWithRelationInput
  }

  export type TransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    tran_id?: IntFilter<"Transactions"> | number
    acno?: StringNullableFilter<"Transactions"> | string | null
    itcd?: IntNullableFilter<"Transactions"> | number | null
    ccno?: IntNullableFilter<"Transactions"> | number | null
    narration1?: StringNullableFilter<"Transactions"> | string | null
    narration2?: StringNullableFilter<"Transactions"> | string | null
    narration3?: StringNullableFilter<"Transactions"> | string | null
    narration4?: StringNullableFilter<"Transactions"> | string | null
    narration5?: StringNullableFilter<"Transactions"> | string | null
    chno?: StringNullableFilter<"Transactions"> | string | null
    check_date?: DateTimeNullableFilter<"Transactions"> | Date | string | null
    party_name?: StringNullableFilter<"Transactions"> | string | null
    damt?: FloatNullableFilter<"Transactions"> | number | null
    camt?: FloatNullableFilter<"Transactions"> | number | null
    qty?: FloatNullableFilter<"Transactions"> | number | null
    rate?: FloatNullableFilter<"Transactions"> | number | null
    wht_rate?: FloatNullableFilter<"Transactions"> | number | null
    st_rate?: FloatNullableFilter<"Transactions"> | number | null
    godown?: IntNullableFilter<"Transactions"> | number | null
    invoice_no?: StringNullableFilter<"Transactions"> | string | null
    sub_tran_id?: IntNullableFilter<"Transactions"> | number | null
    currency?: IntNullableFilter<"Transactions"> | number | null
    gross_amount?: FloatNullableFilter<"Transactions"> | number | null
    fc_amount?: FloatNullableFilter<"Transactions"> | number | null
    no_of_pack?: FloatNullableFilter<"Transactions"> | number | null
    qty_per_pack?: FloatNullableFilter<"Transactions"> | number | null
    st_amount?: FloatNullableFilter<"Transactions"> | number | null
    additional_tax?: FloatNullableFilter<"Transactions"> | number | null
    acnoDetails?: XOR<ACNONullableScalarRelationFilter, ACNOWhereInput> | null
    costCenter?: XOR<CostCenterNullableScalarRelationFilter, CostCenterWhereInput> | null
    currencyDetails?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    godownDetails?: XOR<GodownNullableScalarRelationFilter, GodownWhereInput> | null
    itemDetails?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    transactionsMaster?: XOR<TransactionsMasterScalarRelationFilter, TransactionsMasterWhereInput>
  }, "id">

  export type TransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    tran_id?: SortOrder
    acno?: SortOrderInput | SortOrder
    itcd?: SortOrderInput | SortOrder
    ccno?: SortOrderInput | SortOrder
    narration1?: SortOrderInput | SortOrder
    narration2?: SortOrderInput | SortOrder
    narration3?: SortOrderInput | SortOrder
    narration4?: SortOrderInput | SortOrder
    narration5?: SortOrderInput | SortOrder
    chno?: SortOrderInput | SortOrder
    check_date?: SortOrderInput | SortOrder
    party_name?: SortOrderInput | SortOrder
    damt?: SortOrderInput | SortOrder
    camt?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    wht_rate?: SortOrderInput | SortOrder
    st_rate?: SortOrderInput | SortOrder
    godown?: SortOrderInput | SortOrder
    invoice_no?: SortOrderInput | SortOrder
    sub_tran_id?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    gross_amount?: SortOrderInput | SortOrder
    fc_amount?: SortOrderInput | SortOrder
    no_of_pack?: SortOrderInput | SortOrder
    qty_per_pack?: SortOrderInput | SortOrder
    st_amount?: SortOrderInput | SortOrder
    additional_tax?: SortOrderInput | SortOrder
    _count?: TransactionsCountOrderByAggregateInput
    _avg?: TransactionsAvgOrderByAggregateInput
    _max?: TransactionsMaxOrderByAggregateInput
    _min?: TransactionsMinOrderByAggregateInput
    _sum?: TransactionsSumOrderByAggregateInput
  }

  export type TransactionsScalarWhereWithAggregatesInput = {
    AND?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    OR?: TransactionsScalarWhereWithAggregatesInput[]
    NOT?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transactions"> | number
    tran_id?: IntWithAggregatesFilter<"Transactions"> | number
    acno?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    itcd?: IntNullableWithAggregatesFilter<"Transactions"> | number | null
    ccno?: IntNullableWithAggregatesFilter<"Transactions"> | number | null
    narration1?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    narration2?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    narration3?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    narration4?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    narration5?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    chno?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    check_date?: DateTimeNullableWithAggregatesFilter<"Transactions"> | Date | string | null
    party_name?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    damt?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    camt?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    qty?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    rate?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    wht_rate?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    st_rate?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    godown?: IntNullableWithAggregatesFilter<"Transactions"> | number | null
    invoice_no?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    sub_tran_id?: IntNullableWithAggregatesFilter<"Transactions"> | number | null
    currency?: IntNullableWithAggregatesFilter<"Transactions"> | number | null
    gross_amount?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    fc_amount?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    no_of_pack?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    qty_per_pack?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    st_amount?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
    additional_tax?: FloatNullableWithAggregatesFilter<"Transactions"> | number | null
  }

  export type DeliveryTermWhereInput = {
    AND?: DeliveryTermWhereInput | DeliveryTermWhereInput[]
    OR?: DeliveryTermWhereInput[]
    NOT?: DeliveryTermWhereInput | DeliveryTermWhereInput[]
    id?: IntFilter<"DeliveryTerm"> | number
    delivery_term?: StringFilter<"DeliveryTerm"> | string
    company_id?: IntFilter<"DeliveryTerm"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DeliveryTermOrderByWithRelationInput = {
    id?: SortOrder
    delivery_term?: SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type DeliveryTermWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeliveryTermWhereInput | DeliveryTermWhereInput[]
    OR?: DeliveryTermWhereInput[]
    NOT?: DeliveryTermWhereInput | DeliveryTermWhereInput[]
    delivery_term?: StringFilter<"DeliveryTerm"> | string
    company_id?: IntFilter<"DeliveryTerm"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DeliveryTermOrderByWithAggregationInput = {
    id?: SortOrder
    delivery_term?: SortOrder
    company_id?: SortOrder
    _count?: DeliveryTermCountOrderByAggregateInput
    _avg?: DeliveryTermAvgOrderByAggregateInput
    _max?: DeliveryTermMaxOrderByAggregateInput
    _min?: DeliveryTermMinOrderByAggregateInput
    _sum?: DeliveryTermSumOrderByAggregateInput
  }

  export type DeliveryTermScalarWhereWithAggregatesInput = {
    AND?: DeliveryTermScalarWhereWithAggregatesInput | DeliveryTermScalarWhereWithAggregatesInput[]
    OR?: DeliveryTermScalarWhereWithAggregatesInput[]
    NOT?: DeliveryTermScalarWhereWithAggregatesInput | DeliveryTermScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeliveryTerm"> | number
    delivery_term?: StringWithAggregatesFilter<"DeliveryTerm"> | string
    company_id?: IntWithAggregatesFilter<"DeliveryTerm"> | number
  }

  export type CommissionTermWhereInput = {
    AND?: CommissionTermWhereInput | CommissionTermWhereInput[]
    OR?: CommissionTermWhereInput[]
    NOT?: CommissionTermWhereInput | CommissionTermWhereInput[]
    id?: IntFilter<"CommissionTerm"> | number
    commission_term?: StringFilter<"CommissionTerm"> | string
    company_id?: IntFilter<"CommissionTerm"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type CommissionTermOrderByWithRelationInput = {
    id?: SortOrder
    commission_term?: SortOrder
    company_id?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CommissionTermWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommissionTermWhereInput | CommissionTermWhereInput[]
    OR?: CommissionTermWhereInput[]
    NOT?: CommissionTermWhereInput | CommissionTermWhereInput[]
    commission_term?: StringFilter<"CommissionTerm"> | string
    company_id?: IntFilter<"CommissionTerm"> | number
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type CommissionTermOrderByWithAggregationInput = {
    id?: SortOrder
    commission_term?: SortOrder
    company_id?: SortOrder
    _count?: CommissionTermCountOrderByAggregateInput
    _avg?: CommissionTermAvgOrderByAggregateInput
    _max?: CommissionTermMaxOrderByAggregateInput
    _min?: CommissionTermMinOrderByAggregateInput
    _sum?: CommissionTermSumOrderByAggregateInput
  }

  export type CommissionTermScalarWhereWithAggregatesInput = {
    AND?: CommissionTermScalarWhereWithAggregatesInput | CommissionTermScalarWhereWithAggregatesInput[]
    OR?: CommissionTermScalarWhereWithAggregatesInput[]
    NOT?: CommissionTermScalarWhereWithAggregatesInput | CommissionTermScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommissionTerm"> | number
    commission_term?: StringWithAggregatesFilter<"CommissionTerm"> | string
    company_id?: IntWithAggregatesFilter<"CommissionTerm"> | number
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    first_name?: StringFilter<"Employee"> | string
    middle_name?: StringNullableFilter<"Employee"> | string | null
    surname?: StringFilter<"Employee"> | string
    dob?: DateTimeFilter<"Employee"> | Date | string
    gender?: EnumGenderNullableFilter<"Employee"> | $Enums.Gender | null
    phone_number?: StringFilter<"Employee"> | string
    npf_number?: StringFilter<"Employee"> | string
    email_address?: StringFilter<"Employee"> | string
    village?: StringFilter<"Employee"> | string
    status?: EnumStatusNullableFilter<"Employee"> | $Enums.Status | null
    hire_date?: DateTimeFilter<"Employee"> | Date | string
    job_title?: StringFilter<"Employee"> | string
    department?: StringFilter<"Employee"> | string
    work_location?: StringFilter<"Employee"> | string
    manager_id?: StringNullableFilter<"Employee"> | string | null
    client_id?: StringFilter<"Employee"> | string
    employee_id?: StringFilter<"Employee"> | string
    payment_method?: EnumPaymentMethodNullableFilter<"Employee"> | $Enums.PaymentMethod | null
    bank_name?: StringNullableFilter<"Employee"> | string | null
    account_name?: StringNullableFilter<"Employee"> | string | null
    account_number?: StringNullableFilter<"Employee"> | string | null
    pay_type?: EnumPayTypeNullableFilter<"Employee"> | $Enums.PayType | null
    rate_per_hour?: FloatFilter<"Employee"> | number
    pay_frequency?: EnumPayFrequencyNullableFilter<"Employee"> | $Enums.PayFrequency | null
    employee_type?: StringFilter<"Employee"> | string
    cost_center?: StringFilter<"Employee"> | string
    allownces?: JsonFilter<"Employee">
    allownce_eligible?: BoolFilter<"Employee"> | boolean
    deductions?: JsonFilter<"Employee">
    profile_image?: StringNullableFilter<"Employee"> | string | null
    created_on?: DateTimeFilter<"Employee"> | Date | string
    updated_on?: DateTimeFilter<"Employee"> | Date | string
    company_id?: IntFilter<"Employee"> | number
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    employer?: XOR<EmployerScalarRelationFilter, EmployerWhereInput>
    leaves?: LeaveListRelationFilter
    documents?: DocumentListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    middle_name?: SortOrderInput | SortOrder
    surname?: SortOrder
    dob?: SortOrder
    gender?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    npf_number?: SortOrder
    email_address?: SortOrder
    village?: SortOrder
    status?: SortOrderInput | SortOrder
    hire_date?: SortOrder
    job_title?: SortOrder
    department?: SortOrder
    work_location?: SortOrder
    manager_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    employee_id?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    bank_name?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    pay_type?: SortOrderInput | SortOrder
    rate_per_hour?: SortOrder
    pay_frequency?: SortOrderInput | SortOrder
    employee_type?: SortOrder
    cost_center?: SortOrder
    allownces?: SortOrder
    allownce_eligible?: SortOrder
    deductions?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    company_id?: SortOrder
    manager?: ManagerOrderByWithRelationInput
    employer?: EmployerOrderByWithRelationInput
    leaves?: LeaveOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employee_id?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    first_name?: StringFilter<"Employee"> | string
    middle_name?: StringNullableFilter<"Employee"> | string | null
    surname?: StringFilter<"Employee"> | string
    dob?: DateTimeFilter<"Employee"> | Date | string
    gender?: EnumGenderNullableFilter<"Employee"> | $Enums.Gender | null
    phone_number?: StringFilter<"Employee"> | string
    npf_number?: StringFilter<"Employee"> | string
    email_address?: StringFilter<"Employee"> | string
    village?: StringFilter<"Employee"> | string
    status?: EnumStatusNullableFilter<"Employee"> | $Enums.Status | null
    hire_date?: DateTimeFilter<"Employee"> | Date | string
    job_title?: StringFilter<"Employee"> | string
    department?: StringFilter<"Employee"> | string
    work_location?: StringFilter<"Employee"> | string
    manager_id?: StringNullableFilter<"Employee"> | string | null
    client_id?: StringFilter<"Employee"> | string
    payment_method?: EnumPaymentMethodNullableFilter<"Employee"> | $Enums.PaymentMethod | null
    bank_name?: StringNullableFilter<"Employee"> | string | null
    account_name?: StringNullableFilter<"Employee"> | string | null
    account_number?: StringNullableFilter<"Employee"> | string | null
    pay_type?: EnumPayTypeNullableFilter<"Employee"> | $Enums.PayType | null
    rate_per_hour?: FloatFilter<"Employee"> | number
    pay_frequency?: EnumPayFrequencyNullableFilter<"Employee"> | $Enums.PayFrequency | null
    employee_type?: StringFilter<"Employee"> | string
    cost_center?: StringFilter<"Employee"> | string
    allownces?: JsonFilter<"Employee">
    allownce_eligible?: BoolFilter<"Employee"> | boolean
    deductions?: JsonFilter<"Employee">
    profile_image?: StringNullableFilter<"Employee"> | string | null
    created_on?: DateTimeFilter<"Employee"> | Date | string
    updated_on?: DateTimeFilter<"Employee"> | Date | string
    company_id?: IntFilter<"Employee"> | number
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    employer?: XOR<EmployerScalarRelationFilter, EmployerWhereInput>
    leaves?: LeaveListRelationFilter
    documents?: DocumentListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "employee_id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    middle_name?: SortOrderInput | SortOrder
    surname?: SortOrder
    dob?: SortOrder
    gender?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    npf_number?: SortOrder
    email_address?: SortOrder
    village?: SortOrder
    status?: SortOrderInput | SortOrder
    hire_date?: SortOrder
    job_title?: SortOrder
    department?: SortOrder
    work_location?: SortOrder
    manager_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    employee_id?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    bank_name?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    pay_type?: SortOrderInput | SortOrder
    rate_per_hour?: SortOrder
    pay_frequency?: SortOrderInput | SortOrder
    employee_type?: SortOrder
    cost_center?: SortOrder
    allownces?: SortOrder
    allownce_eligible?: SortOrder
    deductions?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    company_id?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    first_name?: StringWithAggregatesFilter<"Employee"> | string
    middle_name?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    surname?: StringWithAggregatesFilter<"Employee"> | string
    dob?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    gender?: EnumGenderNullableWithAggregatesFilter<"Employee"> | $Enums.Gender | null
    phone_number?: StringWithAggregatesFilter<"Employee"> | string
    npf_number?: StringWithAggregatesFilter<"Employee"> | string
    email_address?: StringWithAggregatesFilter<"Employee"> | string
    village?: StringWithAggregatesFilter<"Employee"> | string
    status?: EnumStatusNullableWithAggregatesFilter<"Employee"> | $Enums.Status | null
    hire_date?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    job_title?: StringWithAggregatesFilter<"Employee"> | string
    department?: StringWithAggregatesFilter<"Employee"> | string
    work_location?: StringWithAggregatesFilter<"Employee"> | string
    manager_id?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    client_id?: StringWithAggregatesFilter<"Employee"> | string
    employee_id?: StringWithAggregatesFilter<"Employee"> | string
    payment_method?: EnumPaymentMethodNullableWithAggregatesFilter<"Employee"> | $Enums.PaymentMethod | null
    bank_name?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    account_name?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    account_number?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    pay_type?: EnumPayTypeNullableWithAggregatesFilter<"Employee"> | $Enums.PayType | null
    rate_per_hour?: FloatWithAggregatesFilter<"Employee"> | number
    pay_frequency?: EnumPayFrequencyNullableWithAggregatesFilter<"Employee"> | $Enums.PayFrequency | null
    employee_type?: StringWithAggregatesFilter<"Employee"> | string
    cost_center?: StringWithAggregatesFilter<"Employee"> | string
    allownces?: JsonWithAggregatesFilter<"Employee">
    allownce_eligible?: BoolWithAggregatesFilter<"Employee"> | boolean
    deductions?: JsonWithAggregatesFilter<"Employee">
    profile_image?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    created_on?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updated_on?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    company_id?: IntWithAggregatesFilter<"Employee"> | number
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: StringFilter<"Leave"> | string
    leave_id?: StringFilter<"Leave"> | string
    available?: FloatFilter<"Leave"> | number
    employee_id?: StringFilter<"Leave"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    leave_id?: SortOrder
    available?: SortOrder
    employee_id?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    leave_id?: StringFilter<"Leave"> | string
    available?: FloatFilter<"Leave"> | number
    employee_id?: StringFilter<"Leave"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    leave_id?: SortOrder
    available?: SortOrder
    employee_id?: SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _avg?: LeaveAvgOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
    _sum?: LeaveSumOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Leave"> | string
    leave_id?: StringWithAggregatesFilter<"Leave"> | string
    available?: FloatWithAggregatesFilter<"Leave"> | number
    employee_id?: StringWithAggregatesFilter<"Leave"> | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    employee_id?: StringFilter<"Document"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    employee_id?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    url?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    employee_id?: StringFilter<"Document"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    employee_id?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    employee_id?: StringWithAggregatesFilter<"Document"> | string
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    id?: StringFilter<"Manager"> | string
    employees?: EmployeeListRelationFilter
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type ManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    employees?: EmployeeListRelationFilter
  }, "id">

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Manager"> | string
  }

  export type EmployerWhereInput = {
    AND?: EmployerWhereInput | EmployerWhereInput[]
    OR?: EmployerWhereInput[]
    NOT?: EmployerWhereInput | EmployerWhereInput[]
    employer_id?: StringFilter<"Employer"> | string
    employees?: EmployeeListRelationFilter
  }

  export type EmployerOrderByWithRelationInput = {
    employer_id?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type EmployerWhereUniqueInput = Prisma.AtLeast<{
    employer_id?: string
    AND?: EmployerWhereInput | EmployerWhereInput[]
    OR?: EmployerWhereInput[]
    NOT?: EmployerWhereInput | EmployerWhereInput[]
    employees?: EmployeeListRelationFilter
  }, "employer_id">

  export type EmployerOrderByWithAggregationInput = {
    employer_id?: SortOrder
    _count?: EmployerCountOrderByAggregateInput
    _max?: EmployerMaxOrderByAggregateInput
    _min?: EmployerMinOrderByAggregateInput
  }

  export type EmployerScalarWhereWithAggregatesInput = {
    AND?: EmployerScalarWhereWithAggregatesInput | EmployerScalarWhereWithAggregatesInput[]
    OR?: EmployerScalarWhereWithAggregatesInput[]
    NOT?: EmployerScalarWhereWithAggregatesInput | EmployerScalarWhereWithAggregatesInput[]
    employer_id?: StringWithAggregatesFilter<"Employer"> | string
  }

  export type MBSCDCreateInput = {
    bscd: string
    bscdDetail: string
    bscdItems?: BSCDCreateNestedManyWithoutMainBscdInput
  }

  export type MBSCDUncheckedCreateInput = {
    bscd: string
    bscdDetail: string
    bscdItems?: BSCDUncheckedCreateNestedManyWithoutMainBscdInput
  }

  export type MBSCDUpdateInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
    bscdItems?: BSCDUpdateManyWithoutMainBscdNestedInput
  }

  export type MBSCDUncheckedUpdateInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
    bscdItems?: BSCDUncheckedUpdateManyWithoutMainBscdNestedInput
  }

  export type MBSCDCreateManyInput = {
    bscd: string
    bscdDetail: string
  }

  export type MBSCDUpdateManyMutationInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
  }

  export type MBSCDUncheckedUpdateManyInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
  }

  export type BSCDCreateInput = {
    bscd: string
    bscdDetail: string
    mainBscd: MBSCDCreateNestedOneWithoutBscdItemsInput
    macnoItems?: MACNOCreateNestedManyWithoutBscdRefInput
  }

  export type BSCDUncheckedCreateInput = {
    bscd: string
    mbscd: string
    bscdDetail: string
    macnoItems?: MACNOUncheckedCreateNestedManyWithoutBscdRefInput
  }

  export type BSCDUpdateInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
    mainBscd?: MBSCDUpdateOneRequiredWithoutBscdItemsNestedInput
    macnoItems?: MACNOUpdateManyWithoutBscdRefNestedInput
  }

  export type BSCDUncheckedUpdateInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    mbscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
    macnoItems?: MACNOUncheckedUpdateManyWithoutBscdRefNestedInput
  }

  export type BSCDCreateManyInput = {
    bscd: string
    mbscd: string
    bscdDetail: string
  }

  export type BSCDUpdateManyMutationInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
  }

  export type BSCDUncheckedUpdateManyInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    mbscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
  }

  export type MACNOCreateInput = {
    macno: string
    macname: string
    bscdRef: BSCDCreateNestedOneWithoutMacnoItemsInput
    accounts?: ACNOCreateNestedManyWithoutMainAccountInput
  }

  export type MACNOUncheckedCreateInput = {
    macno: string
    bscd: string
    macname: string
    accounts?: ACNOUncheckedCreateNestedManyWithoutMainAccountInput
  }

  export type MACNOUpdateInput = {
    macno?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
    bscdRef?: BSCDUpdateOneRequiredWithoutMacnoItemsNestedInput
    accounts?: ACNOUpdateManyWithoutMainAccountNestedInput
  }

  export type MACNOUncheckedUpdateInput = {
    macno?: StringFieldUpdateOperationsInput | string
    bscd?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
    accounts?: ACNOUncheckedUpdateManyWithoutMainAccountNestedInput
  }

  export type MACNOCreateManyInput = {
    macno: string
    bscd: string
    macname: string
  }

  export type MACNOUpdateManyMutationInput = {
    macno?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
  }

  export type MACNOUncheckedUpdateManyInput = {
    macno?: StringFieldUpdateOperationsInput | string
    bscd?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
  }

  export type ACNOCreateInput = {
    acno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
    transactionsMaster?: TransactionsMasterCreateNestedManyWithoutAcnoInput
    transactions?: TransactionsCreateNestedManyWithoutAcnoDetailsInput
    mainAccount: MACNOCreateNestedOneWithoutAccountsInput
  }

  export type ACNOUncheckedCreateInput = {
    acno: string
    macno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
    transactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutAcnoInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAcnoDetailsInput
  }

  export type ACNOUpdateInput = {
    acno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUpdateManyWithoutAcnoNestedInput
    transactions?: TransactionsUpdateManyWithoutAcnoDetailsNestedInput
    mainAccount?: MACNOUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type ACNOUncheckedUpdateInput = {
    acno?: StringFieldUpdateOperationsInput | string
    macno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutAcnoNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAcnoDetailsNestedInput
  }

  export type ACNOCreateManyInput = {
    acno: string
    macno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
  }

  export type ACNOUpdateManyMutationInput = {
    acno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ACNOUncheckedUpdateManyInput = {
    acno?: StringFieldUpdateOperationsInput | string
    macno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
  }

  export type CompanyUpdateManyMutationInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostCenterCreateInput = {
    ccname?: string | null
    company: CompanyCreateNestedOneWithoutCostCentersInput
    Transaction?: TransactionsCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterUncheckedCreateInput = {
    ccno?: number
    company_id: number
    ccname?: string | null
    Transaction?: TransactionsUncheckedCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterUpdateInput = {
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutCostCentersNestedInput
    Transaction?: TransactionsUpdateManyWithoutCostCenterNestedInput
  }

  export type CostCenterUncheckedUpdateInput = {
    ccno?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
    Transaction?: TransactionsUncheckedUpdateManyWithoutCostCenterNestedInput
  }

  export type CostCenterCreateManyInput = {
    ccno?: number
    company_id: number
    ccname?: string | null
  }

  export type CostCenterUpdateManyMutationInput = {
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostCenterUncheckedUpdateManyInput = {
    ccno?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentCreateInput = {
    dept_name?: string | null
    company: CompanyCreateNestedOneWithoutDepartmentsInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    dept_name?: string | null
    company_id: number
  }

  export type DepartmentUpdateInput = {
    dept_name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dept_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentCreateManyInput = {
    id?: number
    dept_name?: string | null
    company_id: number
  }

  export type DepartmentUpdateManyMutationInput = {
    dept_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dept_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductMasterCategoryCreateInput = {
    pmc_name?: string | null
    productGroups?: ProductGroupCreateNestedManyWithoutProductMasterCategoriesInput
  }

  export type ProductMasterCategoryUncheckedCreateInput = {
    id?: number
    pmc_name?: string | null
    productGroups?: ProductGroupUncheckedCreateNestedManyWithoutProductMasterCategoriesInput
  }

  export type ProductMasterCategoryUpdateInput = {
    pmc_name?: NullableStringFieldUpdateOperationsInput | string | null
    productGroups?: ProductGroupUpdateManyWithoutProductMasterCategoriesNestedInput
  }

  export type ProductMasterCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pmc_name?: NullableStringFieldUpdateOperationsInput | string | null
    productGroups?: ProductGroupUncheckedUpdateManyWithoutProductMasterCategoriesNestedInput
  }

  export type ProductMasterCategoryCreateManyInput = {
    id?: number
    pmc_name?: string | null
  }

  export type ProductMasterCategoryUpdateManyMutationInput = {
    pmc_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductMasterCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pmc_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductGroupCreateInput = {
    pg_name?: string | null
    productCategories?: ProductCategoryCreateNestedManyWithoutProductGroupsInput
    ProductMasterCategories: ProductMasterCategoryCreateNestedOneWithoutProductGroupsInput
  }

  export type ProductGroupUncheckedCreateInput = {
    id?: number
    pg_name?: string | null
    pmc_id: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutProductGroupsInput
  }

  export type ProductGroupUpdateInput = {
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
    productCategories?: ProductCategoryUpdateManyWithoutProductGroupsNestedInput
    ProductMasterCategories?: ProductMasterCategoryUpdateOneRequiredWithoutProductGroupsNestedInput
  }

  export type ProductGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
    pmc_id?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutProductGroupsNestedInput
  }

  export type ProductGroupCreateManyInput = {
    id?: number
    pg_name?: string | null
    pmc_id: number
  }

  export type ProductGroupUpdateManyMutationInput = {
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
    pmc_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCategoryCreateInput = {
    pc_name?: string | null
    mainCategories?: MainCategoryCreateNestedManyWithoutProductCategoriesInput
    ProductGroups: ProductGroupCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    pc_name?: string | null
    pg_id: number
    mainCategories?: MainCategoryUncheckedCreateNestedManyWithoutProductCategoriesInput
  }

  export type ProductCategoryUpdateInput = {
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
    mainCategories?: MainCategoryUpdateManyWithoutProductCategoriesNestedInput
    ProductGroups?: ProductGroupUpdateOneRequiredWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pg_id?: IntFieldUpdateOperationsInput | number
    mainCategories?: MainCategoryUncheckedUpdateManyWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    pc_name?: string | null
    pg_id: number
  }

  export type ProductCategoryUpdateManyMutationInput = {
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pg_id?: IntFieldUpdateOperationsInput | number
  }

  export type MainCategoryCreateInput = {
    mc_name?: string | null
    itemCategories?: ItemCategoryCreateNestedManyWithoutMainCategoryInput
    ProductCategories: ProductCategoryCreateNestedOneWithoutMainCategoriesInput
  }

  export type MainCategoryUncheckedCreateInput = {
    id?: number
    mc_name?: string | null
    pc_id: number
    itemCategories?: ItemCategoryUncheckedCreateNestedManyWithoutMainCategoryInput
  }

  export type MainCategoryUpdateInput = {
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategories?: ItemCategoryUpdateManyWithoutMainCategoryNestedInput
    ProductCategories?: ProductCategoryUpdateOneRequiredWithoutMainCategoriesNestedInput
  }

  export type MainCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pc_id?: IntFieldUpdateOperationsInput | number
    itemCategories?: ItemCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput
  }

  export type MainCategoryCreateManyInput = {
    id?: number
    mc_name?: string | null
    pc_id: number
  }

  export type MainCategoryUpdateManyMutationInput = {
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MainCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pc_id?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCategoryCreateInput = {
    ic_name: string
    wc_category_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    mainCategory: MainCategoryCreateNestedOneWithoutItemCategoriesInput
    items?: ItemCreateNestedManyWithoutItemCategoriesInput
  }

  export type ItemCategoryUncheckedCreateInput = {
    id?: number
    ic_name: string
    mc_id: number
    wc_category_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    items?: ItemUncheckedCreateNestedManyWithoutItemCategoriesInput
  }

  export type ItemCategoryUpdateInput = {
    ic_name?: StringFieldUpdateOperationsInput | string
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mainCategory?: MainCategoryUpdateOneRequiredWithoutItemCategoriesNestedInput
    items?: ItemUpdateManyWithoutItemCategoriesNestedInput
  }

  export type ItemCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ic_name?: StringFieldUpdateOperationsInput | string
    mc_id?: IntFieldUpdateOperationsInput | number
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUncheckedUpdateManyWithoutItemCategoriesNestedInput
  }

  export type ItemCategoryCreateManyInput = {
    id?: number
    ic_name: string
    mc_id: number
    wc_category_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type ItemCategoryUpdateManyMutationInput = {
    ic_name?: StringFieldUpdateOperationsInput | string
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ic_name?: StringFieldUpdateOperationsInput | string
    mc_id?: IntFieldUpdateOperationsInput | number
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCreateInput = {
    item?: string | null
    sku?: string | null
    price?: number | null
    stock?: number | null
    wc_product_id?: number | null
    wc_parent_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    itemCategories: ItemCategoryCreateNestedOneWithoutItemsInput
    Transactions?: TransactionsCreateNestedManyWithoutItemDetailsInput
  }

  export type ItemUncheckedCreateInput = {
    itcd?: number
    item?: string | null
    ic_id: number
    sku?: string | null
    price?: number | null
    stock?: number | null
    wc_product_id?: number | null
    wc_parent_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    Transactions?: TransactionsUncheckedCreateNestedManyWithoutItemDetailsInput
  }

  export type ItemUpdateInput = {
    item?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemCategories?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
    Transactions?: TransactionsUpdateManyWithoutItemDetailsNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    itcd?: IntFieldUpdateOperationsInput | number
    item?: NullableStringFieldUpdateOperationsInput | string | null
    ic_id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Transactions?: TransactionsUncheckedUpdateManyWithoutItemDetailsNestedInput
  }

  export type ItemCreateManyInput = {
    itcd?: number
    item?: string | null
    ic_id: number
    sku?: string | null
    price?: number | null
    stock?: number | null
    wc_product_id?: number | null
    wc_parent_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type ItemUpdateManyMutationInput = {
    item?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemUncheckedUpdateManyInput = {
    itcd?: IntFieldUpdateOperationsInput | number
    item?: NullableStringFieldUpdateOperationsInput | string | null
    ic_id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignationCreateInput = {
    desg_name?: string | null
    company: CompanyCreateNestedOneWithoutDesignationsInput
  }

  export type DesignationUncheckedCreateInput = {
    id?: number
    desg_name?: string | null
    company_id: number
  }

  export type DesignationUpdateInput = {
    desg_name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutDesignationsNestedInput
  }

  export type DesignationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    desg_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type DesignationCreateManyInput = {
    id?: number
    desg_name?: string | null
    company_id: number
  }

  export type DesignationUpdateManyMutationInput = {
    desg_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DesignationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    desg_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type GodownCreateInput = {
    godown: string
    company: CompanyCreateNestedOneWithoutGodownsInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutGodownDetailsInput
    Transaction?: TransactionsCreateNestedManyWithoutGodownDetailsInput
  }

  export type GodownUncheckedCreateInput = {
    id?: number
    godown: string
    company_id: number
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutGodownDetailsInput
    Transaction?: TransactionsUncheckedCreateNestedManyWithoutGodownDetailsInput
  }

  export type GodownUpdateInput = {
    godown?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutGodownsNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutGodownDetailsNestedInput
    Transaction?: TransactionsUpdateManyWithoutGodownDetailsNestedInput
  }

  export type GodownUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    godown?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutGodownDetailsNestedInput
    Transaction?: TransactionsUncheckedUpdateManyWithoutGodownDetailsNestedInput
  }

  export type GodownCreateManyInput = {
    id?: number
    godown: string
    company_id: number
  }

  export type GodownUpdateManyMutationInput = {
    godown?: StringFieldUpdateOperationsInput | string
  }

  export type GodownUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    godown?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type FinancialYearCreateInput = {
    date_from: Date | string
    date_to: Date | string
    status: string
    company: CompanyCreateNestedOneWithoutFinancialYearsInput
  }

  export type FinancialYearUncheckedCreateInput = {
    id?: number
    date_from: Date | string
    date_to: Date | string
    status: string
    company_id: number
  }

  export type FinancialYearUpdateInput = {
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutFinancialYearsNestedInput
  }

  export type FinancialYearUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type FinancialYearCreateManyInput = {
    id?: number
    date_from: Date | string
    date_to: Date | string
    status: string
    company_id: number
  }

  export type FinancialYearUpdateManyMutationInput = {
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialYearUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type SeasonCreateInput = {
    date_from: Date | string
    date_to: Date | string
    status: string
    company: CompanyCreateNestedOneWithoutSeasonsInput
  }

  export type SeasonUncheckedCreateInput = {
    id?: number
    date_from: Date | string
    date_to: Date | string
    status: string
    company_id: number
  }

  export type SeasonUpdateInput = {
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutSeasonsNestedInput
  }

  export type SeasonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type SeasonCreateManyInput = {
    id?: number
    date_from: Date | string
    date_to: Date | string
    status: string
    company_id: number
  }

  export type SeasonUpdateManyMutationInput = {
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SeasonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type PoPrdCatCreateInput = {
    category_name: string
    company: CompanyCreateNestedOneWithoutPoPrdCatsInput
  }

  export type PoPrdCatUncheckedCreateInput = {
    id?: number
    category_name: string
    company_id: number
  }

  export type PoPrdCatUpdateInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutPoPrdCatsNestedInput
  }

  export type PoPrdCatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type PoPrdCatCreateManyInput = {
    id?: number
    category_name: string
    company_id: number
  }

  export type PoPrdCatUpdateManyMutationInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type PoPrdCatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryModeCreateInput = {
    delivery_mode: string
    rate_kg: number
    company: CompanyCreateNestedOneWithoutDeliveryModesInput
  }

  export type DeliveryModeUncheckedCreateInput = {
    id?: number
    delivery_mode: string
    rate_kg: number
    company_id: number
  }

  export type DeliveryModeUpdateInput = {
    delivery_mode?: StringFieldUpdateOperationsInput | string
    rate_kg?: IntFieldUpdateOperationsInput | number
    company?: CompanyUpdateOneRequiredWithoutDeliveryModesNestedInput
  }

  export type DeliveryModeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_mode?: StringFieldUpdateOperationsInput | string
    rate_kg?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryModeCreateManyInput = {
    id?: number
    delivery_mode: string
    rate_kg: number
    company_id: number
  }

  export type DeliveryModeUpdateManyMutationInput = {
    delivery_mode?: StringFieldUpdateOperationsInput | string
    rate_kg?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryModeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_mode?: StringFieldUpdateOperationsInput | string
    rate_kg?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type UsersCreateInput = {
    user_id: string
    user_name?: string | null
    transactionsMaster?: TransactionsMasterCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    user_id: string
    user_name?: string | null
    company_id: number
    transactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: IntFieldUpdateOperationsInput | number
    transactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateManyInput = {
    user_id: string
    user_name?: string | null
    company_id: number
  }

  export type UsersUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type CurrencyCreateInput = {
    currency: string
    transactions?: TransactionsCreateNestedManyWithoutCurrencyDetailsInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: number
    currency: string
    transactions?: TransactionsUncheckedCreateNestedManyWithoutCurrencyDetailsInput
  }

  export type CurrencyUpdateInput = {
    currency?: StringFieldUpdateOperationsInput | string
    transactions?: TransactionsUpdateManyWithoutCurrencyDetailsNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transactions?: TransactionsUncheckedUpdateManyWithoutCurrencyDetailsNestedInput
  }

  export type CurrencyCreateManyInput = {
    id?: number
    currency: string
  }

  export type CurrencyUpdateManyMutationInput = {
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionsMasterCreateInput = {
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    invoice_no?: string | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    user?: UsersCreateNestedOneWithoutTransactionsMasterInput
    company?: CompanyCreateNestedOneWithoutTransactionsMasterInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionsMasterInput
    acno?: ACNOCreateNestedOneWithoutTransactionsMasterInput
    transactions?: TransactionsCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterUncheckedCreateInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    transactions?: TransactionsUncheckedCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterUpdateInput = {
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UsersUpdateOneWithoutTransactionsMasterNestedInput
    company?: CompanyUpdateOneWithoutTransactionsMasterNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionsMasterNestedInput
    acno?: ACNOUpdateOneWithoutTransactionsMasterNestedInput
    transactions?: TransactionsUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionsUncheckedUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterCreateManyInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type TransactionsMasterUpdateManyMutationInput = {
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsMasterUncheckedUpdateManyInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsCreateInput = {
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
    acnoDetails?: ACNOCreateNestedOneWithoutTransactionsInput
    costCenter?: CostCenterCreateNestedOneWithoutTransactionInput
    currencyDetails?: CurrencyCreateNestedOneWithoutTransactionsInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionInput
    itemDetails?: ItemCreateNestedOneWithoutTransactionsInput
    transactionsMaster: TransactionsMasterCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateInput = {
    id?: number
    tran_id: number
    acno?: string | null
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsUpdateInput = {
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    acnoDetails?: ACNOUpdateOneWithoutTransactionsNestedInput
    costCenter?: CostCenterUpdateOneWithoutTransactionNestedInput
    currencyDetails?: CurrencyUpdateOneWithoutTransactionsNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionNestedInput
    itemDetails?: ItemUpdateOneWithoutTransactionsNestedInput
    transactionsMaster?: TransactionsMasterUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsCreateManyInput = {
    id?: number
    tran_id: number
    acno?: string | null
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsUpdateManyMutationInput = {
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DeliveryTermCreateInput = {
    delivery_term: string
    company: CompanyCreateNestedOneWithoutDeliveryTermsInput
  }

  export type DeliveryTermUncheckedCreateInput = {
    id?: number
    delivery_term: string
    company_id: number
  }

  export type DeliveryTermUpdateInput = {
    delivery_term?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutDeliveryTermsNestedInput
  }

  export type DeliveryTermUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_term?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryTermCreateManyInput = {
    id?: number
    delivery_term: string
    company_id: number
  }

  export type DeliveryTermUpdateManyMutationInput = {
    delivery_term?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryTermUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_term?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type CommissionTermCreateInput = {
    commission_term: string
    company: CompanyCreateNestedOneWithoutCommissionTermsInput
  }

  export type CommissionTermUncheckedCreateInput = {
    id?: number
    commission_term: string
    company_id: number
  }

  export type CommissionTermUpdateInput = {
    commission_term?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutCommissionTermsNestedInput
  }

  export type CommissionTermUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commission_term?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type CommissionTermCreateManyInput = {
    id?: number
    commission_term: string
    company_id: number
  }

  export type CommissionTermUpdateManyMutationInput = {
    commission_term?: StringFieldUpdateOperationsInput | string
  }

  export type CommissionTermUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commission_term?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeCreateInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    manager?: ManagerCreateNestedOneWithoutEmployeesInput
    employer: EmployerCreateNestedOneWithoutEmployeesInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    company: CompanyCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    manager_id?: string | null
    client_id: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    company_id: number
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneWithoutEmployeesNestedInput
    employer?: EmployerUpdateOneRequiredWithoutEmployeesNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: IntFieldUpdateOperationsInput | number
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    manager_id?: string | null
    client_id: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    company_id: number
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type LeaveCreateInput = {
    id?: string
    leave_id: string
    available: number
    employee: EmployeeCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: string
    leave_id: string
    available: number
    employee_id: string
  }

  export type LeaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leave_id?: StringFieldUpdateOperationsInput | string
    available?: FloatFieldUpdateOperationsInput | number
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leave_id?: StringFieldUpdateOperationsInput | string
    available?: FloatFieldUpdateOperationsInput | number
    employee_id?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveCreateManyInput = {
    id?: string
    leave_id: string
    available: number
    employee_id: string
  }

  export type LeaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    leave_id?: StringFieldUpdateOperationsInput | string
    available?: FloatFieldUpdateOperationsInput | number
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leave_id?: StringFieldUpdateOperationsInput | string
    available?: FloatFieldUpdateOperationsInput | number
    employee_id?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateInput = {
    id?: string
    url: string
    name: string
    description?: string | null
    employee: EmployeeCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    url: string
    name: string
    description?: string | null
    employee_id: string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    employee_id?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    url: string
    name: string
    description?: string | null
    employee_id: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    employee_id?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerCreateInput = {
    id?: string
    employees?: EmployeeCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    id?: string
  }

  export type ManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployerCreateInput = {
    employer_id: string
    employees?: EmployeeCreateNestedManyWithoutEmployerInput
  }

  export type EmployerUncheckedCreateInput = {
    employer_id: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEmployerInput
  }

  export type EmployerUpdateInput = {
    employer_id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutEmployerNestedInput
  }

  export type EmployerUncheckedUpdateInput = {
    employer_id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutEmployerNestedInput
  }

  export type EmployerCreateManyInput = {
    employer_id: string
  }

  export type EmployerUpdateManyMutationInput = {
    employer_id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployerUncheckedUpdateManyInput = {
    employer_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BSCDListRelationFilter = {
    every?: BSCDWhereInput
    some?: BSCDWhereInput
    none?: BSCDWhereInput
  }

  export type BSCDOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MBSCDCountOrderByAggregateInput = {
    bscd?: SortOrder
    bscdDetail?: SortOrder
  }

  export type MBSCDMaxOrderByAggregateInput = {
    bscd?: SortOrder
    bscdDetail?: SortOrder
  }

  export type MBSCDMinOrderByAggregateInput = {
    bscd?: SortOrder
    bscdDetail?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type MBSCDScalarRelationFilter = {
    is?: MBSCDWhereInput
    isNot?: MBSCDWhereInput
  }

  export type MACNOListRelationFilter = {
    every?: MACNOWhereInput
    some?: MACNOWhereInput
    none?: MACNOWhereInput
  }

  export type MACNOOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BSCDMbscdBscdCompoundUniqueInput = {
    mbscd: string
    bscd: string
  }

  export type BSCDCountOrderByAggregateInput = {
    bscd?: SortOrder
    mbscd?: SortOrder
    bscdDetail?: SortOrder
  }

  export type BSCDMaxOrderByAggregateInput = {
    bscd?: SortOrder
    mbscd?: SortOrder
    bscdDetail?: SortOrder
  }

  export type BSCDMinOrderByAggregateInput = {
    bscd?: SortOrder
    mbscd?: SortOrder
    bscdDetail?: SortOrder
  }

  export type BSCDScalarRelationFilter = {
    is?: BSCDWhereInput
    isNot?: BSCDWhereInput
  }

  export type ACNOListRelationFilter = {
    every?: ACNOWhereInput
    some?: ACNOWhereInput
    none?: ACNOWhereInput
  }

  export type ACNOOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MACNOBscdMacnoCompoundUniqueInput = {
    bscd: string
    macno: string
  }

  export type MACNOCountOrderByAggregateInput = {
    macno?: SortOrder
    bscd?: SortOrder
    macname?: SortOrder
  }

  export type MACNOMaxOrderByAggregateInput = {
    macno?: SortOrder
    bscd?: SortOrder
    macname?: SortOrder
  }

  export type MACNOMinOrderByAggregateInput = {
    macno?: SortOrder
    bscd?: SortOrder
    macname?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type TransactionsMasterListRelationFilter = {
    every?: TransactionsMasterWhereInput
    some?: TransactionsMasterWhereInput
    none?: TransactionsMasterWhereInput
  }

  export type TransactionsListRelationFilter = {
    every?: TransactionsWhereInput
    some?: TransactionsWhereInput
    none?: TransactionsWhereInput
  }

  export type MACNOScalarRelationFilter = {
    is?: MACNOWhereInput
    isNot?: MACNOWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TransactionsMasterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ACNOMacnoAcnoCompoundUniqueInput = {
    macno: string
    acno: string
  }

  export type ACNOCountOrderByAggregateInput = {
    acno?: SortOrder
    macno?: SortOrder
    acname?: SortOrder
    bankAccountNo?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phoneFax?: SortOrder
    email?: SortOrder
    website?: SortOrder
    crDays?: SortOrder
    stRate?: SortOrder
    area?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    country?: SortOrder
    customerBank?: SortOrder
    customerBankAddr?: SortOrder
    stRegNo?: SortOrder
    ntnNo?: SortOrder
    contactPerson?: SortOrder
    crLimit?: SortOrder
    salesArea?: SortOrder
  }

  export type ACNOAvgOrderByAggregateInput = {
    crDays?: SortOrder
    stRate?: SortOrder
    crLimit?: SortOrder
  }

  export type ACNOMaxOrderByAggregateInput = {
    acno?: SortOrder
    macno?: SortOrder
    acname?: SortOrder
    bankAccountNo?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phoneFax?: SortOrder
    email?: SortOrder
    website?: SortOrder
    crDays?: SortOrder
    stRate?: SortOrder
    area?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    country?: SortOrder
    customerBank?: SortOrder
    customerBankAddr?: SortOrder
    stRegNo?: SortOrder
    ntnNo?: SortOrder
    contactPerson?: SortOrder
    crLimit?: SortOrder
    salesArea?: SortOrder
  }

  export type ACNOMinOrderByAggregateInput = {
    acno?: SortOrder
    macno?: SortOrder
    acname?: SortOrder
    bankAccountNo?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phoneFax?: SortOrder
    email?: SortOrder
    website?: SortOrder
    crDays?: SortOrder
    stRate?: SortOrder
    area?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    country?: SortOrder
    customerBank?: SortOrder
    customerBankAddr?: SortOrder
    stRegNo?: SortOrder
    ntnNo?: SortOrder
    contactPerson?: SortOrder
    crLimit?: SortOrder
    salesArea?: SortOrder
  }

  export type ACNOSumOrderByAggregateInput = {
    crDays?: SortOrder
    stRate?: SortOrder
    crLimit?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CostCenterListRelationFilter = {
    every?: CostCenterWhereInput
    some?: CostCenterWhereInput
    none?: CostCenterWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type DesignationListRelationFilter = {
    every?: DesignationWhereInput
    some?: DesignationWhereInput
    none?: DesignationWhereInput
  }

  export type GodownListRelationFilter = {
    every?: GodownWhereInput
    some?: GodownWhereInput
    none?: GodownWhereInput
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type FinancialYearListRelationFilter = {
    every?: FinancialYearWhereInput
    some?: FinancialYearWhereInput
    none?: FinancialYearWhereInput
  }

  export type SeasonListRelationFilter = {
    every?: SeasonWhereInput
    some?: SeasonWhereInput
    none?: SeasonWhereInput
  }

  export type PoPrdCatListRelationFilter = {
    every?: PoPrdCatWhereInput
    some?: PoPrdCatWhereInput
    none?: PoPrdCatWhereInput
  }

  export type DeliveryModeListRelationFilter = {
    every?: DeliveryModeWhereInput
    some?: DeliveryModeWhereInput
    none?: DeliveryModeWhereInput
  }

  export type DeliveryTermListRelationFilter = {
    every?: DeliveryTermWhereInput
    some?: DeliveryTermWhereInput
    none?: DeliveryTermWhereInput
  }

  export type CommissionTermListRelationFilter = {
    every?: CommissionTermWhereInput
    some?: CommissionTermWhereInput
    none?: CommissionTermWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type CostCenterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesignationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GodownOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PoPrdCatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryModeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryTermOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommissionTermOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    addr1?: SortOrder
    addr2?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    email?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    addr1?: SortOrder
    addr2?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    email?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    addr1?: SortOrder
    addr2?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    email?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CostCenterCountOrderByAggregateInput = {
    ccno?: SortOrder
    company_id?: SortOrder
    ccname?: SortOrder
  }

  export type CostCenterAvgOrderByAggregateInput = {
    ccno?: SortOrder
    company_id?: SortOrder
  }

  export type CostCenterMaxOrderByAggregateInput = {
    ccno?: SortOrder
    company_id?: SortOrder
    ccname?: SortOrder
  }

  export type CostCenterMinOrderByAggregateInput = {
    ccno?: SortOrder
    company_id?: SortOrder
    ccname?: SortOrder
  }

  export type CostCenterSumOrderByAggregateInput = {
    ccno?: SortOrder
    company_id?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    dept_name?: SortOrder
    company_id?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    dept_name?: SortOrder
    company_id?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    dept_name?: SortOrder
    company_id?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type ProductGroupListRelationFilter = {
    every?: ProductGroupWhereInput
    some?: ProductGroupWhereInput
    none?: ProductGroupWhereInput
  }

  export type ProductGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductMasterCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    pmc_name?: SortOrder
  }

  export type ProductMasterCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductMasterCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    pmc_name?: SortOrder
  }

  export type ProductMasterCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    pmc_name?: SortOrder
  }

  export type ProductMasterCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type ProductMasterCategoryScalarRelationFilter = {
    is?: ProductMasterCategoryWhereInput
    isNot?: ProductMasterCategoryWhereInput
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductGroupCountOrderByAggregateInput = {
    id?: SortOrder
    pg_name?: SortOrder
    pmc_id?: SortOrder
  }

  export type ProductGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    pmc_id?: SortOrder
  }

  export type ProductGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    pg_name?: SortOrder
    pmc_id?: SortOrder
  }

  export type ProductGroupMinOrderByAggregateInput = {
    id?: SortOrder
    pg_name?: SortOrder
    pmc_id?: SortOrder
  }

  export type ProductGroupSumOrderByAggregateInput = {
    id?: SortOrder
    pmc_id?: SortOrder
  }

  export type MainCategoryListRelationFilter = {
    every?: MainCategoryWhereInput
    some?: MainCategoryWhereInput
    none?: MainCategoryWhereInput
  }

  export type ProductGroupScalarRelationFilter = {
    is?: ProductGroupWhereInput
    isNot?: ProductGroupWhereInput
  }

  export type MainCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    pc_name?: SortOrder
    pg_id?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    pg_id?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    pc_name?: SortOrder
    pg_id?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    pc_name?: SortOrder
    pg_id?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
    pg_id?: SortOrder
  }

  export type ItemCategoryListRelationFilter = {
    every?: ItemCategoryWhereInput
    some?: ItemCategoryWhereInput
    none?: ItemCategoryWhereInput
  }

  export type ProductCategoryScalarRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type ItemCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MainCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    mc_name?: SortOrder
    pc_id?: SortOrder
  }

  export type MainCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    pc_id?: SortOrder
  }

  export type MainCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    mc_name?: SortOrder
    pc_id?: SortOrder
  }

  export type MainCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    mc_name?: SortOrder
    pc_id?: SortOrder
  }

  export type MainCategorySumOrderByAggregateInput = {
    id?: SortOrder
    pc_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MainCategoryScalarRelationFilter = {
    is?: MainCategoryWhereInput
    isNot?: MainCategoryWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    ic_name?: SortOrder
    mc_id?: SortOrder
    wc_category_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type ItemCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    mc_id?: SortOrder
    wc_category_id?: SortOrder
  }

  export type ItemCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    ic_name?: SortOrder
    mc_id?: SortOrder
    wc_category_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type ItemCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    ic_name?: SortOrder
    mc_id?: SortOrder
    wc_category_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type ItemCategorySumOrderByAggregateInput = {
    id?: SortOrder
    mc_id?: SortOrder
    wc_category_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ItemCategoryScalarRelationFilter = {
    is?: ItemCategoryWhereInput
    isNot?: ItemCategoryWhereInput
  }

  export type ItemCountOrderByAggregateInput = {
    itcd?: SortOrder
    item?: SortOrder
    ic_id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    wc_product_id?: SortOrder
    wc_parent_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    itcd?: SortOrder
    ic_id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    wc_product_id?: SortOrder
    wc_parent_id?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    itcd?: SortOrder
    item?: SortOrder
    ic_id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    wc_product_id?: SortOrder
    wc_parent_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    itcd?: SortOrder
    item?: SortOrder
    ic_id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    wc_product_id?: SortOrder
    wc_parent_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    itcd?: SortOrder
    ic_id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    wc_product_id?: SortOrder
    wc_parent_id?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DesignationCountOrderByAggregateInput = {
    id?: SortOrder
    desg_name?: SortOrder
    company_id?: SortOrder
  }

  export type DesignationAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type DesignationMaxOrderByAggregateInput = {
    id?: SortOrder
    desg_name?: SortOrder
    company_id?: SortOrder
  }

  export type DesignationMinOrderByAggregateInput = {
    id?: SortOrder
    desg_name?: SortOrder
    company_id?: SortOrder
  }

  export type DesignationSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type GodownCountOrderByAggregateInput = {
    id?: SortOrder
    godown?: SortOrder
    company_id?: SortOrder
  }

  export type GodownAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type GodownMaxOrderByAggregateInput = {
    id?: SortOrder
    godown?: SortOrder
    company_id?: SortOrder
  }

  export type GodownMinOrderByAggregateInput = {
    id?: SortOrder
    godown?: SortOrder
    company_id?: SortOrder
  }

  export type GodownSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FinancialYearCountOrderByAggregateInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
  }

  export type FinancialYearAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type FinancialYearMaxOrderByAggregateInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
  }

  export type FinancialYearMinOrderByAggregateInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
  }

  export type FinancialYearSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
  }

  export type SeasonAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    date_from?: SortOrder
    date_to?: SortOrder
    status?: SortOrder
    company_id?: SortOrder
  }

  export type SeasonSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type PoPrdCatCountOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    company_id?: SortOrder
  }

  export type PoPrdCatAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type PoPrdCatMaxOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    company_id?: SortOrder
  }

  export type PoPrdCatMinOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    company_id?: SortOrder
  }

  export type PoPrdCatSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryModeCountOrderByAggregateInput = {
    id?: SortOrder
    delivery_mode?: SortOrder
    rate_kg?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryModeAvgOrderByAggregateInput = {
    id?: SortOrder
    rate_kg?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryModeMaxOrderByAggregateInput = {
    id?: SortOrder
    delivery_mode?: SortOrder
    rate_kg?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryModeMinOrderByAggregateInput = {
    id?: SortOrder
    delivery_mode?: SortOrder
    rate_kg?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryModeSumOrderByAggregateInput = {
    id?: SortOrder
    rate_kg?: SortOrder
    company_id?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    user_id?: SortOrder
    user_name?: SortOrder
    company_id?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    company_id?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    user_name?: SortOrder
    company_id?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    user_id?: SortOrder
    user_name?: SortOrder
    company_id?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    company_id?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type GodownNullableScalarRelationFilter = {
    is?: GodownWhereInput | null
    isNot?: GodownWhereInput | null
  }

  export type ACNONullableScalarRelationFilter = {
    is?: ACNOWhereInput | null
    isNot?: ACNOWhereInput | null
  }

  export type TransactionsMasterTran_codeVr_noCompoundUniqueInput = {
    tran_code: number
    vr_no: number
  }

  export type TransactionsMasterCountOrderByAggregateInput = {
    tran_id?: SortOrder
    company_id?: SortOrder
    dateD?: SortOrder
    time?: SortOrder
    tran_code?: SortOrder
    vr_no?: SortOrder
    pycd?: SortOrder
    check_no?: SortOrder
    check_date?: SortOrder
    rmk?: SortOrder
    rmk1?: SortOrder
    rmk2?: SortOrder
    rmk3?: SortOrder
    rmk4?: SortOrder
    rmk5?: SortOrder
    userId?: SortOrder
    invoice_no?: SortOrder
    godown?: SortOrder
    wc_order_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type TransactionsMasterAvgOrderByAggregateInput = {
    tran_id?: SortOrder
    company_id?: SortOrder
    tran_code?: SortOrder
    vr_no?: SortOrder
    godown?: SortOrder
    wc_order_id?: SortOrder
  }

  export type TransactionsMasterMaxOrderByAggregateInput = {
    tran_id?: SortOrder
    company_id?: SortOrder
    dateD?: SortOrder
    time?: SortOrder
    tran_code?: SortOrder
    vr_no?: SortOrder
    pycd?: SortOrder
    check_no?: SortOrder
    check_date?: SortOrder
    rmk?: SortOrder
    rmk1?: SortOrder
    rmk2?: SortOrder
    rmk3?: SortOrder
    rmk4?: SortOrder
    rmk5?: SortOrder
    userId?: SortOrder
    invoice_no?: SortOrder
    godown?: SortOrder
    wc_order_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type TransactionsMasterMinOrderByAggregateInput = {
    tran_id?: SortOrder
    company_id?: SortOrder
    dateD?: SortOrder
    time?: SortOrder
    tran_code?: SortOrder
    vr_no?: SortOrder
    pycd?: SortOrder
    check_no?: SortOrder
    check_date?: SortOrder
    rmk?: SortOrder
    rmk1?: SortOrder
    rmk2?: SortOrder
    rmk3?: SortOrder
    rmk4?: SortOrder
    rmk5?: SortOrder
    userId?: SortOrder
    invoice_no?: SortOrder
    godown?: SortOrder
    wc_order_id?: SortOrder
    sync_status?: SortOrder
    last_sync?: SortOrder
  }

  export type TransactionsMasterSumOrderByAggregateInput = {
    tran_id?: SortOrder
    company_id?: SortOrder
    tran_code?: SortOrder
    vr_no?: SortOrder
    godown?: SortOrder
    wc_order_id?: SortOrder
  }

  export type CostCenterNullableScalarRelationFilter = {
    is?: CostCenterWhereInput | null
    isNot?: CostCenterWhereInput | null
  }

  export type CurrencyNullableScalarRelationFilter = {
    is?: CurrencyWhereInput | null
    isNot?: CurrencyWhereInput | null
  }

  export type ItemNullableScalarRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type TransactionsMasterScalarRelationFilter = {
    is?: TransactionsMasterWhereInput
    isNot?: TransactionsMasterWhereInput
  }

  export type TransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    tran_id?: SortOrder
    acno?: SortOrder
    itcd?: SortOrder
    ccno?: SortOrder
    narration1?: SortOrder
    narration2?: SortOrder
    narration3?: SortOrder
    narration4?: SortOrder
    narration5?: SortOrder
    chno?: SortOrder
    check_date?: SortOrder
    party_name?: SortOrder
    damt?: SortOrder
    camt?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    wht_rate?: SortOrder
    st_rate?: SortOrder
    godown?: SortOrder
    invoice_no?: SortOrder
    sub_tran_id?: SortOrder
    currency?: SortOrder
    gross_amount?: SortOrder
    fc_amount?: SortOrder
    no_of_pack?: SortOrder
    qty_per_pack?: SortOrder
    st_amount?: SortOrder
    additional_tax?: SortOrder
  }

  export type TransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    tran_id?: SortOrder
    itcd?: SortOrder
    ccno?: SortOrder
    damt?: SortOrder
    camt?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    wht_rate?: SortOrder
    st_rate?: SortOrder
    godown?: SortOrder
    sub_tran_id?: SortOrder
    currency?: SortOrder
    gross_amount?: SortOrder
    fc_amount?: SortOrder
    no_of_pack?: SortOrder
    qty_per_pack?: SortOrder
    st_amount?: SortOrder
    additional_tax?: SortOrder
  }

  export type TransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    tran_id?: SortOrder
    acno?: SortOrder
    itcd?: SortOrder
    ccno?: SortOrder
    narration1?: SortOrder
    narration2?: SortOrder
    narration3?: SortOrder
    narration4?: SortOrder
    narration5?: SortOrder
    chno?: SortOrder
    check_date?: SortOrder
    party_name?: SortOrder
    damt?: SortOrder
    camt?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    wht_rate?: SortOrder
    st_rate?: SortOrder
    godown?: SortOrder
    invoice_no?: SortOrder
    sub_tran_id?: SortOrder
    currency?: SortOrder
    gross_amount?: SortOrder
    fc_amount?: SortOrder
    no_of_pack?: SortOrder
    qty_per_pack?: SortOrder
    st_amount?: SortOrder
    additional_tax?: SortOrder
  }

  export type TransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    tran_id?: SortOrder
    acno?: SortOrder
    itcd?: SortOrder
    ccno?: SortOrder
    narration1?: SortOrder
    narration2?: SortOrder
    narration3?: SortOrder
    narration4?: SortOrder
    narration5?: SortOrder
    chno?: SortOrder
    check_date?: SortOrder
    party_name?: SortOrder
    damt?: SortOrder
    camt?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    wht_rate?: SortOrder
    st_rate?: SortOrder
    godown?: SortOrder
    invoice_no?: SortOrder
    sub_tran_id?: SortOrder
    currency?: SortOrder
    gross_amount?: SortOrder
    fc_amount?: SortOrder
    no_of_pack?: SortOrder
    qty_per_pack?: SortOrder
    st_amount?: SortOrder
    additional_tax?: SortOrder
  }

  export type TransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    tran_id?: SortOrder
    itcd?: SortOrder
    ccno?: SortOrder
    damt?: SortOrder
    camt?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    wht_rate?: SortOrder
    st_rate?: SortOrder
    godown?: SortOrder
    sub_tran_id?: SortOrder
    currency?: SortOrder
    gross_amount?: SortOrder
    fc_amount?: SortOrder
    no_of_pack?: SortOrder
    qty_per_pack?: SortOrder
    st_amount?: SortOrder
    additional_tax?: SortOrder
  }

  export type DeliveryTermCountOrderByAggregateInput = {
    id?: SortOrder
    delivery_term?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryTermAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryTermMaxOrderByAggregateInput = {
    id?: SortOrder
    delivery_term?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryTermMinOrderByAggregateInput = {
    id?: SortOrder
    delivery_term?: SortOrder
    company_id?: SortOrder
  }

  export type DeliveryTermSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type CommissionTermCountOrderByAggregateInput = {
    id?: SortOrder
    commission_term?: SortOrder
    company_id?: SortOrder
  }

  export type CommissionTermAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type CommissionTermMaxOrderByAggregateInput = {
    id?: SortOrder
    commission_term?: SortOrder
    company_id?: SortOrder
  }

  export type CommissionTermMinOrderByAggregateInput = {
    id?: SortOrder
    commission_term?: SortOrder
    company_id?: SortOrder
  }

  export type CommissionTermSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableFilter<$PrismaModel> | $Enums.Status | null
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type EnumPayTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PayType | EnumPayTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PayType[] | ListEnumPayTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PayType[] | ListEnumPayTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPayTypeNullableFilter<$PrismaModel> | $Enums.PayType | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPayFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PayFrequency | EnumPayFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.PayFrequency[] | ListEnumPayFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PayFrequency[] | ListEnumPayFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPayFrequencyNullableFilter<$PrismaModel> | $Enums.PayFrequency | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ManagerNullableScalarRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type EmployerScalarRelationFilter = {
    is?: EmployerWhereInput
    isNot?: EmployerWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    middle_name?: SortOrder
    surname?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phone_number?: SortOrder
    npf_number?: SortOrder
    email_address?: SortOrder
    village?: SortOrder
    status?: SortOrder
    hire_date?: SortOrder
    job_title?: SortOrder
    department?: SortOrder
    work_location?: SortOrder
    manager_id?: SortOrder
    client_id?: SortOrder
    employee_id?: SortOrder
    payment_method?: SortOrder
    bank_name?: SortOrder
    account_name?: SortOrder
    account_number?: SortOrder
    pay_type?: SortOrder
    rate_per_hour?: SortOrder
    pay_frequency?: SortOrder
    employee_type?: SortOrder
    cost_center?: SortOrder
    allownces?: SortOrder
    allownce_eligible?: SortOrder
    deductions?: SortOrder
    profile_image?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    company_id?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    rate_per_hour?: SortOrder
    company_id?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    middle_name?: SortOrder
    surname?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phone_number?: SortOrder
    npf_number?: SortOrder
    email_address?: SortOrder
    village?: SortOrder
    status?: SortOrder
    hire_date?: SortOrder
    job_title?: SortOrder
    department?: SortOrder
    work_location?: SortOrder
    manager_id?: SortOrder
    client_id?: SortOrder
    employee_id?: SortOrder
    payment_method?: SortOrder
    bank_name?: SortOrder
    account_name?: SortOrder
    account_number?: SortOrder
    pay_type?: SortOrder
    rate_per_hour?: SortOrder
    pay_frequency?: SortOrder
    employee_type?: SortOrder
    cost_center?: SortOrder
    allownce_eligible?: SortOrder
    profile_image?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    company_id?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    middle_name?: SortOrder
    surname?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phone_number?: SortOrder
    npf_number?: SortOrder
    email_address?: SortOrder
    village?: SortOrder
    status?: SortOrder
    hire_date?: SortOrder
    job_title?: SortOrder
    department?: SortOrder
    work_location?: SortOrder
    manager_id?: SortOrder
    client_id?: SortOrder
    employee_id?: SortOrder
    payment_method?: SortOrder
    bank_name?: SortOrder
    account_name?: SortOrder
    account_number?: SortOrder
    pay_type?: SortOrder
    rate_per_hour?: SortOrder
    pay_frequency?: SortOrder
    employee_type?: SortOrder
    cost_center?: SortOrder
    allownce_eligible?: SortOrder
    profile_image?: SortOrder
    created_on?: SortOrder
    updated_on?: SortOrder
    company_id?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    rate_per_hour?: SortOrder
    company_id?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStatusNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumPayTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayType | EnumPayTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PayType[] | ListEnumPayTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PayType[] | ListEnumPayTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPayTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PayType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPayTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPayTypeNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPayFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayFrequency | EnumPayFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.PayFrequency[] | ListEnumPayFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PayFrequency[] | ListEnumPayFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPayFrequencyNullableWithAggregatesFilter<$PrismaModel> | $Enums.PayFrequency | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPayFrequencyNullableFilter<$PrismaModel>
    _max?: NestedEnumPayFrequencyNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    leave_id?: SortOrder
    available?: SortOrder
    employee_id?: SortOrder
  }

  export type LeaveAvgOrderByAggregateInput = {
    available?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    leave_id?: SortOrder
    available?: SortOrder
    employee_id?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    leave_id?: SortOrder
    available?: SortOrder
    employee_id?: SortOrder
  }

  export type LeaveSumOrderByAggregateInput = {
    available?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    employee_id?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    employee_id?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    name?: SortOrder
    description?: SortOrder
    employee_id?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployerCountOrderByAggregateInput = {
    employer_id?: SortOrder
  }

  export type EmployerMaxOrderByAggregateInput = {
    employer_id?: SortOrder
  }

  export type EmployerMinOrderByAggregateInput = {
    employer_id?: SortOrder
  }

  export type BSCDCreateNestedManyWithoutMainBscdInput = {
    create?: XOR<BSCDCreateWithoutMainBscdInput, BSCDUncheckedCreateWithoutMainBscdInput> | BSCDCreateWithoutMainBscdInput[] | BSCDUncheckedCreateWithoutMainBscdInput[]
    connectOrCreate?: BSCDCreateOrConnectWithoutMainBscdInput | BSCDCreateOrConnectWithoutMainBscdInput[]
    createMany?: BSCDCreateManyMainBscdInputEnvelope
    connect?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
  }

  export type BSCDUncheckedCreateNestedManyWithoutMainBscdInput = {
    create?: XOR<BSCDCreateWithoutMainBscdInput, BSCDUncheckedCreateWithoutMainBscdInput> | BSCDCreateWithoutMainBscdInput[] | BSCDUncheckedCreateWithoutMainBscdInput[]
    connectOrCreate?: BSCDCreateOrConnectWithoutMainBscdInput | BSCDCreateOrConnectWithoutMainBscdInput[]
    createMany?: BSCDCreateManyMainBscdInputEnvelope
    connect?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BSCDUpdateManyWithoutMainBscdNestedInput = {
    create?: XOR<BSCDCreateWithoutMainBscdInput, BSCDUncheckedCreateWithoutMainBscdInput> | BSCDCreateWithoutMainBscdInput[] | BSCDUncheckedCreateWithoutMainBscdInput[]
    connectOrCreate?: BSCDCreateOrConnectWithoutMainBscdInput | BSCDCreateOrConnectWithoutMainBscdInput[]
    upsert?: BSCDUpsertWithWhereUniqueWithoutMainBscdInput | BSCDUpsertWithWhereUniqueWithoutMainBscdInput[]
    createMany?: BSCDCreateManyMainBscdInputEnvelope
    set?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
    disconnect?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
    delete?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
    connect?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
    update?: BSCDUpdateWithWhereUniqueWithoutMainBscdInput | BSCDUpdateWithWhereUniqueWithoutMainBscdInput[]
    updateMany?: BSCDUpdateManyWithWhereWithoutMainBscdInput | BSCDUpdateManyWithWhereWithoutMainBscdInput[]
    deleteMany?: BSCDScalarWhereInput | BSCDScalarWhereInput[]
  }

  export type BSCDUncheckedUpdateManyWithoutMainBscdNestedInput = {
    create?: XOR<BSCDCreateWithoutMainBscdInput, BSCDUncheckedCreateWithoutMainBscdInput> | BSCDCreateWithoutMainBscdInput[] | BSCDUncheckedCreateWithoutMainBscdInput[]
    connectOrCreate?: BSCDCreateOrConnectWithoutMainBscdInput | BSCDCreateOrConnectWithoutMainBscdInput[]
    upsert?: BSCDUpsertWithWhereUniqueWithoutMainBscdInput | BSCDUpsertWithWhereUniqueWithoutMainBscdInput[]
    createMany?: BSCDCreateManyMainBscdInputEnvelope
    set?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
    disconnect?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
    delete?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
    connect?: BSCDWhereUniqueInput | BSCDWhereUniqueInput[]
    update?: BSCDUpdateWithWhereUniqueWithoutMainBscdInput | BSCDUpdateWithWhereUniqueWithoutMainBscdInput[]
    updateMany?: BSCDUpdateManyWithWhereWithoutMainBscdInput | BSCDUpdateManyWithWhereWithoutMainBscdInput[]
    deleteMany?: BSCDScalarWhereInput | BSCDScalarWhereInput[]
  }

  export type MBSCDCreateNestedOneWithoutBscdItemsInput = {
    create?: XOR<MBSCDCreateWithoutBscdItemsInput, MBSCDUncheckedCreateWithoutBscdItemsInput>
    connectOrCreate?: MBSCDCreateOrConnectWithoutBscdItemsInput
    connect?: MBSCDWhereUniqueInput
  }

  export type MACNOCreateNestedManyWithoutBscdRefInput = {
    create?: XOR<MACNOCreateWithoutBscdRefInput, MACNOUncheckedCreateWithoutBscdRefInput> | MACNOCreateWithoutBscdRefInput[] | MACNOUncheckedCreateWithoutBscdRefInput[]
    connectOrCreate?: MACNOCreateOrConnectWithoutBscdRefInput | MACNOCreateOrConnectWithoutBscdRefInput[]
    createMany?: MACNOCreateManyBscdRefInputEnvelope
    connect?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
  }

  export type MACNOUncheckedCreateNestedManyWithoutBscdRefInput = {
    create?: XOR<MACNOCreateWithoutBscdRefInput, MACNOUncheckedCreateWithoutBscdRefInput> | MACNOCreateWithoutBscdRefInput[] | MACNOUncheckedCreateWithoutBscdRefInput[]
    connectOrCreate?: MACNOCreateOrConnectWithoutBscdRefInput | MACNOCreateOrConnectWithoutBscdRefInput[]
    createMany?: MACNOCreateManyBscdRefInputEnvelope
    connect?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
  }

  export type MBSCDUpdateOneRequiredWithoutBscdItemsNestedInput = {
    create?: XOR<MBSCDCreateWithoutBscdItemsInput, MBSCDUncheckedCreateWithoutBscdItemsInput>
    connectOrCreate?: MBSCDCreateOrConnectWithoutBscdItemsInput
    upsert?: MBSCDUpsertWithoutBscdItemsInput
    connect?: MBSCDWhereUniqueInput
    update?: XOR<XOR<MBSCDUpdateToOneWithWhereWithoutBscdItemsInput, MBSCDUpdateWithoutBscdItemsInput>, MBSCDUncheckedUpdateWithoutBscdItemsInput>
  }

  export type MACNOUpdateManyWithoutBscdRefNestedInput = {
    create?: XOR<MACNOCreateWithoutBscdRefInput, MACNOUncheckedCreateWithoutBscdRefInput> | MACNOCreateWithoutBscdRefInput[] | MACNOUncheckedCreateWithoutBscdRefInput[]
    connectOrCreate?: MACNOCreateOrConnectWithoutBscdRefInput | MACNOCreateOrConnectWithoutBscdRefInput[]
    upsert?: MACNOUpsertWithWhereUniqueWithoutBscdRefInput | MACNOUpsertWithWhereUniqueWithoutBscdRefInput[]
    createMany?: MACNOCreateManyBscdRefInputEnvelope
    set?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
    disconnect?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
    delete?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
    connect?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
    update?: MACNOUpdateWithWhereUniqueWithoutBscdRefInput | MACNOUpdateWithWhereUniqueWithoutBscdRefInput[]
    updateMany?: MACNOUpdateManyWithWhereWithoutBscdRefInput | MACNOUpdateManyWithWhereWithoutBscdRefInput[]
    deleteMany?: MACNOScalarWhereInput | MACNOScalarWhereInput[]
  }

  export type MACNOUncheckedUpdateManyWithoutBscdRefNestedInput = {
    create?: XOR<MACNOCreateWithoutBscdRefInput, MACNOUncheckedCreateWithoutBscdRefInput> | MACNOCreateWithoutBscdRefInput[] | MACNOUncheckedCreateWithoutBscdRefInput[]
    connectOrCreate?: MACNOCreateOrConnectWithoutBscdRefInput | MACNOCreateOrConnectWithoutBscdRefInput[]
    upsert?: MACNOUpsertWithWhereUniqueWithoutBscdRefInput | MACNOUpsertWithWhereUniqueWithoutBscdRefInput[]
    createMany?: MACNOCreateManyBscdRefInputEnvelope
    set?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
    disconnect?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
    delete?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
    connect?: MACNOWhereUniqueInput | MACNOWhereUniqueInput[]
    update?: MACNOUpdateWithWhereUniqueWithoutBscdRefInput | MACNOUpdateWithWhereUniqueWithoutBscdRefInput[]
    updateMany?: MACNOUpdateManyWithWhereWithoutBscdRefInput | MACNOUpdateManyWithWhereWithoutBscdRefInput[]
    deleteMany?: MACNOScalarWhereInput | MACNOScalarWhereInput[]
  }

  export type BSCDCreateNestedOneWithoutMacnoItemsInput = {
    create?: XOR<BSCDCreateWithoutMacnoItemsInput, BSCDUncheckedCreateWithoutMacnoItemsInput>
    connectOrCreate?: BSCDCreateOrConnectWithoutMacnoItemsInput
    connect?: BSCDWhereUniqueInput
  }

  export type ACNOCreateNestedManyWithoutMainAccountInput = {
    create?: XOR<ACNOCreateWithoutMainAccountInput, ACNOUncheckedCreateWithoutMainAccountInput> | ACNOCreateWithoutMainAccountInput[] | ACNOUncheckedCreateWithoutMainAccountInput[]
    connectOrCreate?: ACNOCreateOrConnectWithoutMainAccountInput | ACNOCreateOrConnectWithoutMainAccountInput[]
    createMany?: ACNOCreateManyMainAccountInputEnvelope
    connect?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
  }

  export type ACNOUncheckedCreateNestedManyWithoutMainAccountInput = {
    create?: XOR<ACNOCreateWithoutMainAccountInput, ACNOUncheckedCreateWithoutMainAccountInput> | ACNOCreateWithoutMainAccountInput[] | ACNOUncheckedCreateWithoutMainAccountInput[]
    connectOrCreate?: ACNOCreateOrConnectWithoutMainAccountInput | ACNOCreateOrConnectWithoutMainAccountInput[]
    createMany?: ACNOCreateManyMainAccountInputEnvelope
    connect?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
  }

  export type BSCDUpdateOneRequiredWithoutMacnoItemsNestedInput = {
    create?: XOR<BSCDCreateWithoutMacnoItemsInput, BSCDUncheckedCreateWithoutMacnoItemsInput>
    connectOrCreate?: BSCDCreateOrConnectWithoutMacnoItemsInput
    upsert?: BSCDUpsertWithoutMacnoItemsInput
    connect?: BSCDWhereUniqueInput
    update?: XOR<XOR<BSCDUpdateToOneWithWhereWithoutMacnoItemsInput, BSCDUpdateWithoutMacnoItemsInput>, BSCDUncheckedUpdateWithoutMacnoItemsInput>
  }

  export type ACNOUpdateManyWithoutMainAccountNestedInput = {
    create?: XOR<ACNOCreateWithoutMainAccountInput, ACNOUncheckedCreateWithoutMainAccountInput> | ACNOCreateWithoutMainAccountInput[] | ACNOUncheckedCreateWithoutMainAccountInput[]
    connectOrCreate?: ACNOCreateOrConnectWithoutMainAccountInput | ACNOCreateOrConnectWithoutMainAccountInput[]
    upsert?: ACNOUpsertWithWhereUniqueWithoutMainAccountInput | ACNOUpsertWithWhereUniqueWithoutMainAccountInput[]
    createMany?: ACNOCreateManyMainAccountInputEnvelope
    set?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
    disconnect?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
    delete?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
    connect?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
    update?: ACNOUpdateWithWhereUniqueWithoutMainAccountInput | ACNOUpdateWithWhereUniqueWithoutMainAccountInput[]
    updateMany?: ACNOUpdateManyWithWhereWithoutMainAccountInput | ACNOUpdateManyWithWhereWithoutMainAccountInput[]
    deleteMany?: ACNOScalarWhereInput | ACNOScalarWhereInput[]
  }

  export type ACNOUncheckedUpdateManyWithoutMainAccountNestedInput = {
    create?: XOR<ACNOCreateWithoutMainAccountInput, ACNOUncheckedCreateWithoutMainAccountInput> | ACNOCreateWithoutMainAccountInput[] | ACNOUncheckedCreateWithoutMainAccountInput[]
    connectOrCreate?: ACNOCreateOrConnectWithoutMainAccountInput | ACNOCreateOrConnectWithoutMainAccountInput[]
    upsert?: ACNOUpsertWithWhereUniqueWithoutMainAccountInput | ACNOUpsertWithWhereUniqueWithoutMainAccountInput[]
    createMany?: ACNOCreateManyMainAccountInputEnvelope
    set?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
    disconnect?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
    delete?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
    connect?: ACNOWhereUniqueInput | ACNOWhereUniqueInput[]
    update?: ACNOUpdateWithWhereUniqueWithoutMainAccountInput | ACNOUpdateWithWhereUniqueWithoutMainAccountInput[]
    updateMany?: ACNOUpdateManyWithWhereWithoutMainAccountInput | ACNOUpdateManyWithWhereWithoutMainAccountInput[]
    deleteMany?: ACNOScalarWhereInput | ACNOScalarWhereInput[]
  }

  export type TransactionsMasterCreateNestedManyWithoutAcnoInput = {
    create?: XOR<TransactionsMasterCreateWithoutAcnoInput, TransactionsMasterUncheckedCreateWithoutAcnoInput> | TransactionsMasterCreateWithoutAcnoInput[] | TransactionsMasterUncheckedCreateWithoutAcnoInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutAcnoInput | TransactionsMasterCreateOrConnectWithoutAcnoInput[]
    createMany?: TransactionsMasterCreateManyAcnoInputEnvelope
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
  }

  export type TransactionsCreateNestedManyWithoutAcnoDetailsInput = {
    create?: XOR<TransactionsCreateWithoutAcnoDetailsInput, TransactionsUncheckedCreateWithoutAcnoDetailsInput> | TransactionsCreateWithoutAcnoDetailsInput[] | TransactionsUncheckedCreateWithoutAcnoDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutAcnoDetailsInput | TransactionsCreateOrConnectWithoutAcnoDetailsInput[]
    createMany?: TransactionsCreateManyAcnoDetailsInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type MACNOCreateNestedOneWithoutAccountsInput = {
    create?: XOR<MACNOCreateWithoutAccountsInput, MACNOUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: MACNOCreateOrConnectWithoutAccountsInput
    connect?: MACNOWhereUniqueInput
  }

  export type TransactionsMasterUncheckedCreateNestedManyWithoutAcnoInput = {
    create?: XOR<TransactionsMasterCreateWithoutAcnoInput, TransactionsMasterUncheckedCreateWithoutAcnoInput> | TransactionsMasterCreateWithoutAcnoInput[] | TransactionsMasterUncheckedCreateWithoutAcnoInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutAcnoInput | TransactionsMasterCreateOrConnectWithoutAcnoInput[]
    createMany?: TransactionsMasterCreateManyAcnoInputEnvelope
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutAcnoDetailsInput = {
    create?: XOR<TransactionsCreateWithoutAcnoDetailsInput, TransactionsUncheckedCreateWithoutAcnoDetailsInput> | TransactionsCreateWithoutAcnoDetailsInput[] | TransactionsUncheckedCreateWithoutAcnoDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutAcnoDetailsInput | TransactionsCreateOrConnectWithoutAcnoDetailsInput[]
    createMany?: TransactionsCreateManyAcnoDetailsInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TransactionsMasterUpdateManyWithoutAcnoNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutAcnoInput, TransactionsMasterUncheckedCreateWithoutAcnoInput> | TransactionsMasterCreateWithoutAcnoInput[] | TransactionsMasterUncheckedCreateWithoutAcnoInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutAcnoInput | TransactionsMasterCreateOrConnectWithoutAcnoInput[]
    upsert?: TransactionsMasterUpsertWithWhereUniqueWithoutAcnoInput | TransactionsMasterUpsertWithWhereUniqueWithoutAcnoInput[]
    createMany?: TransactionsMasterCreateManyAcnoInputEnvelope
    set?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    disconnect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    delete?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    update?: TransactionsMasterUpdateWithWhereUniqueWithoutAcnoInput | TransactionsMasterUpdateWithWhereUniqueWithoutAcnoInput[]
    updateMany?: TransactionsMasterUpdateManyWithWhereWithoutAcnoInput | TransactionsMasterUpdateManyWithWhereWithoutAcnoInput[]
    deleteMany?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
  }

  export type TransactionsUpdateManyWithoutAcnoDetailsNestedInput = {
    create?: XOR<TransactionsCreateWithoutAcnoDetailsInput, TransactionsUncheckedCreateWithoutAcnoDetailsInput> | TransactionsCreateWithoutAcnoDetailsInput[] | TransactionsUncheckedCreateWithoutAcnoDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutAcnoDetailsInput | TransactionsCreateOrConnectWithoutAcnoDetailsInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutAcnoDetailsInput | TransactionsUpsertWithWhereUniqueWithoutAcnoDetailsInput[]
    createMany?: TransactionsCreateManyAcnoDetailsInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutAcnoDetailsInput | TransactionsUpdateWithWhereUniqueWithoutAcnoDetailsInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutAcnoDetailsInput | TransactionsUpdateManyWithWhereWithoutAcnoDetailsInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type MACNOUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<MACNOCreateWithoutAccountsInput, MACNOUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: MACNOCreateOrConnectWithoutAccountsInput
    upsert?: MACNOUpsertWithoutAccountsInput
    connect?: MACNOWhereUniqueInput
    update?: XOR<XOR<MACNOUpdateToOneWithWhereWithoutAccountsInput, MACNOUpdateWithoutAccountsInput>, MACNOUncheckedUpdateWithoutAccountsInput>
  }

  export type TransactionsMasterUncheckedUpdateManyWithoutAcnoNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutAcnoInput, TransactionsMasterUncheckedCreateWithoutAcnoInput> | TransactionsMasterCreateWithoutAcnoInput[] | TransactionsMasterUncheckedCreateWithoutAcnoInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutAcnoInput | TransactionsMasterCreateOrConnectWithoutAcnoInput[]
    upsert?: TransactionsMasterUpsertWithWhereUniqueWithoutAcnoInput | TransactionsMasterUpsertWithWhereUniqueWithoutAcnoInput[]
    createMany?: TransactionsMasterCreateManyAcnoInputEnvelope
    set?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    disconnect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    delete?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    update?: TransactionsMasterUpdateWithWhereUniqueWithoutAcnoInput | TransactionsMasterUpdateWithWhereUniqueWithoutAcnoInput[]
    updateMany?: TransactionsMasterUpdateManyWithWhereWithoutAcnoInput | TransactionsMasterUpdateManyWithWhereWithoutAcnoInput[]
    deleteMany?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutAcnoDetailsNestedInput = {
    create?: XOR<TransactionsCreateWithoutAcnoDetailsInput, TransactionsUncheckedCreateWithoutAcnoDetailsInput> | TransactionsCreateWithoutAcnoDetailsInput[] | TransactionsUncheckedCreateWithoutAcnoDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutAcnoDetailsInput | TransactionsCreateOrConnectWithoutAcnoDetailsInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutAcnoDetailsInput | TransactionsUpsertWithWhereUniqueWithoutAcnoDetailsInput[]
    createMany?: TransactionsCreateManyAcnoDetailsInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutAcnoDetailsInput | TransactionsUpdateWithWhereUniqueWithoutAcnoDetailsInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutAcnoDetailsInput | TransactionsUpdateManyWithWhereWithoutAcnoDetailsInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type CostCenterCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput> | CostCenterCreateWithoutCompanyInput[] | CostCenterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CostCenterCreateOrConnectWithoutCompanyInput | CostCenterCreateOrConnectWithoutCompanyInput[]
    createMany?: CostCenterCreateManyCompanyInputEnvelope
    connect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DesignationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DesignationCreateWithoutCompanyInput, DesignationUncheckedCreateWithoutCompanyInput> | DesignationCreateWithoutCompanyInput[] | DesignationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DesignationCreateOrConnectWithoutCompanyInput | DesignationCreateOrConnectWithoutCompanyInput[]
    createMany?: DesignationCreateManyCompanyInputEnvelope
    connect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
  }

  export type GodownCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GodownCreateWithoutCompanyInput, GodownUncheckedCreateWithoutCompanyInput> | GodownCreateWithoutCompanyInput[] | GodownUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GodownCreateOrConnectWithoutCompanyInput | GodownCreateOrConnectWithoutCompanyInput[]
    createMany?: GodownCreateManyCompanyInputEnvelope
    connect?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
  }

  export type TransactionsMasterCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransactionsMasterCreateWithoutCompanyInput, TransactionsMasterUncheckedCreateWithoutCompanyInput> | TransactionsMasterCreateWithoutCompanyInput[] | TransactionsMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutCompanyInput | TransactionsMasterCreateOrConnectWithoutCompanyInput[]
    createMany?: TransactionsMasterCreateManyCompanyInputEnvelope
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
  }

  export type UsersCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UsersCreateWithoutCompanyInput, UsersUncheckedCreateWithoutCompanyInput> | UsersCreateWithoutCompanyInput[] | UsersUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutCompanyInput | UsersCreateOrConnectWithoutCompanyInput[]
    createMany?: UsersCreateManyCompanyInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type FinancialYearCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FinancialYearCreateWithoutCompanyInput, FinancialYearUncheckedCreateWithoutCompanyInput> | FinancialYearCreateWithoutCompanyInput[] | FinancialYearUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialYearCreateOrConnectWithoutCompanyInput | FinancialYearCreateOrConnectWithoutCompanyInput[]
    createMany?: FinancialYearCreateManyCompanyInputEnvelope
    connect?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
  }

  export type SeasonCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SeasonCreateWithoutCompanyInput, SeasonUncheckedCreateWithoutCompanyInput> | SeasonCreateWithoutCompanyInput[] | SeasonUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutCompanyInput | SeasonCreateOrConnectWithoutCompanyInput[]
    createMany?: SeasonCreateManyCompanyInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type PoPrdCatCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PoPrdCatCreateWithoutCompanyInput, PoPrdCatUncheckedCreateWithoutCompanyInput> | PoPrdCatCreateWithoutCompanyInput[] | PoPrdCatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PoPrdCatCreateOrConnectWithoutCompanyInput | PoPrdCatCreateOrConnectWithoutCompanyInput[]
    createMany?: PoPrdCatCreateManyCompanyInputEnvelope
    connect?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
  }

  export type DeliveryModeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DeliveryModeCreateWithoutCompanyInput, DeliveryModeUncheckedCreateWithoutCompanyInput> | DeliveryModeCreateWithoutCompanyInput[] | DeliveryModeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeliveryModeCreateOrConnectWithoutCompanyInput | DeliveryModeCreateOrConnectWithoutCompanyInput[]
    createMany?: DeliveryModeCreateManyCompanyInputEnvelope
    connect?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
  }

  export type DeliveryTermCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DeliveryTermCreateWithoutCompanyInput, DeliveryTermUncheckedCreateWithoutCompanyInput> | DeliveryTermCreateWithoutCompanyInput[] | DeliveryTermUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeliveryTermCreateOrConnectWithoutCompanyInput | DeliveryTermCreateOrConnectWithoutCompanyInput[]
    createMany?: DeliveryTermCreateManyCompanyInputEnvelope
    connect?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
  }

  export type CommissionTermCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CommissionTermCreateWithoutCompanyInput, CommissionTermUncheckedCreateWithoutCompanyInput> | CommissionTermCreateWithoutCompanyInput[] | CommissionTermUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CommissionTermCreateOrConnectWithoutCompanyInput | CommissionTermCreateOrConnectWithoutCompanyInput[]
    createMany?: CommissionTermCreateManyCompanyInputEnvelope
    connect?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput> | EmployeeCreateWithoutCompanyInput[] | EmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCompanyInput | EmployeeCreateOrConnectWithoutCompanyInput[]
    createMany?: EmployeeCreateManyCompanyInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type CostCenterUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput> | CostCenterCreateWithoutCompanyInput[] | CostCenterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CostCenterCreateOrConnectWithoutCompanyInput | CostCenterCreateOrConnectWithoutCompanyInput[]
    createMany?: CostCenterCreateManyCompanyInputEnvelope
    connect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DesignationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DesignationCreateWithoutCompanyInput, DesignationUncheckedCreateWithoutCompanyInput> | DesignationCreateWithoutCompanyInput[] | DesignationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DesignationCreateOrConnectWithoutCompanyInput | DesignationCreateOrConnectWithoutCompanyInput[]
    createMany?: DesignationCreateManyCompanyInputEnvelope
    connect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
  }

  export type GodownUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GodownCreateWithoutCompanyInput, GodownUncheckedCreateWithoutCompanyInput> | GodownCreateWithoutCompanyInput[] | GodownUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GodownCreateOrConnectWithoutCompanyInput | GodownCreateOrConnectWithoutCompanyInput[]
    createMany?: GodownCreateManyCompanyInputEnvelope
    connect?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
  }

  export type TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransactionsMasterCreateWithoutCompanyInput, TransactionsMasterUncheckedCreateWithoutCompanyInput> | TransactionsMasterCreateWithoutCompanyInput[] | TransactionsMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutCompanyInput | TransactionsMasterCreateOrConnectWithoutCompanyInput[]
    createMany?: TransactionsMasterCreateManyCompanyInputEnvelope
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UsersCreateWithoutCompanyInput, UsersUncheckedCreateWithoutCompanyInput> | UsersCreateWithoutCompanyInput[] | UsersUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutCompanyInput | UsersCreateOrConnectWithoutCompanyInput[]
    createMany?: UsersCreateManyCompanyInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type FinancialYearUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FinancialYearCreateWithoutCompanyInput, FinancialYearUncheckedCreateWithoutCompanyInput> | FinancialYearCreateWithoutCompanyInput[] | FinancialYearUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialYearCreateOrConnectWithoutCompanyInput | FinancialYearCreateOrConnectWithoutCompanyInput[]
    createMany?: FinancialYearCreateManyCompanyInputEnvelope
    connect?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
  }

  export type SeasonUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SeasonCreateWithoutCompanyInput, SeasonUncheckedCreateWithoutCompanyInput> | SeasonCreateWithoutCompanyInput[] | SeasonUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutCompanyInput | SeasonCreateOrConnectWithoutCompanyInput[]
    createMany?: SeasonCreateManyCompanyInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PoPrdCatCreateWithoutCompanyInput, PoPrdCatUncheckedCreateWithoutCompanyInput> | PoPrdCatCreateWithoutCompanyInput[] | PoPrdCatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PoPrdCatCreateOrConnectWithoutCompanyInput | PoPrdCatCreateOrConnectWithoutCompanyInput[]
    createMany?: PoPrdCatCreateManyCompanyInputEnvelope
    connect?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
  }

  export type DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DeliveryModeCreateWithoutCompanyInput, DeliveryModeUncheckedCreateWithoutCompanyInput> | DeliveryModeCreateWithoutCompanyInput[] | DeliveryModeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeliveryModeCreateOrConnectWithoutCompanyInput | DeliveryModeCreateOrConnectWithoutCompanyInput[]
    createMany?: DeliveryModeCreateManyCompanyInputEnvelope
    connect?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
  }

  export type DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DeliveryTermCreateWithoutCompanyInput, DeliveryTermUncheckedCreateWithoutCompanyInput> | DeliveryTermCreateWithoutCompanyInput[] | DeliveryTermUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeliveryTermCreateOrConnectWithoutCompanyInput | DeliveryTermCreateOrConnectWithoutCompanyInput[]
    createMany?: DeliveryTermCreateManyCompanyInputEnvelope
    connect?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
  }

  export type CommissionTermUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CommissionTermCreateWithoutCompanyInput, CommissionTermUncheckedCreateWithoutCompanyInput> | CommissionTermCreateWithoutCompanyInput[] | CommissionTermUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CommissionTermCreateOrConnectWithoutCompanyInput | CommissionTermCreateOrConnectWithoutCompanyInput[]
    createMany?: CommissionTermCreateManyCompanyInputEnvelope
    connect?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput> | EmployeeCreateWithoutCompanyInput[] | EmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCompanyInput | EmployeeCreateOrConnectWithoutCompanyInput[]
    createMany?: EmployeeCreateManyCompanyInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type CostCenterUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput> | CostCenterCreateWithoutCompanyInput[] | CostCenterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CostCenterCreateOrConnectWithoutCompanyInput | CostCenterCreateOrConnectWithoutCompanyInput[]
    upsert?: CostCenterUpsertWithWhereUniqueWithoutCompanyInput | CostCenterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CostCenterCreateManyCompanyInputEnvelope
    set?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    disconnect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    delete?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    connect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    update?: CostCenterUpdateWithWhereUniqueWithoutCompanyInput | CostCenterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CostCenterUpdateManyWithWhereWithoutCompanyInput | CostCenterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CostCenterScalarWhereInput | CostCenterScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCompanyInput | DepartmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCompanyInput | DepartmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCompanyInput | DepartmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DesignationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DesignationCreateWithoutCompanyInput, DesignationUncheckedCreateWithoutCompanyInput> | DesignationCreateWithoutCompanyInput[] | DesignationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DesignationCreateOrConnectWithoutCompanyInput | DesignationCreateOrConnectWithoutCompanyInput[]
    upsert?: DesignationUpsertWithWhereUniqueWithoutCompanyInput | DesignationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DesignationCreateManyCompanyInputEnvelope
    set?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    disconnect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    delete?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    connect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    update?: DesignationUpdateWithWhereUniqueWithoutCompanyInput | DesignationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DesignationUpdateManyWithWhereWithoutCompanyInput | DesignationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DesignationScalarWhereInput | DesignationScalarWhereInput[]
  }

  export type GodownUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GodownCreateWithoutCompanyInput, GodownUncheckedCreateWithoutCompanyInput> | GodownCreateWithoutCompanyInput[] | GodownUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GodownCreateOrConnectWithoutCompanyInput | GodownCreateOrConnectWithoutCompanyInput[]
    upsert?: GodownUpsertWithWhereUniqueWithoutCompanyInput | GodownUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GodownCreateManyCompanyInputEnvelope
    set?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
    disconnect?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
    delete?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
    connect?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
    update?: GodownUpdateWithWhereUniqueWithoutCompanyInput | GodownUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GodownUpdateManyWithWhereWithoutCompanyInput | GodownUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GodownScalarWhereInput | GodownScalarWhereInput[]
  }

  export type TransactionsMasterUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutCompanyInput, TransactionsMasterUncheckedCreateWithoutCompanyInput> | TransactionsMasterCreateWithoutCompanyInput[] | TransactionsMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutCompanyInput | TransactionsMasterCreateOrConnectWithoutCompanyInput[]
    upsert?: TransactionsMasterUpsertWithWhereUniqueWithoutCompanyInput | TransactionsMasterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransactionsMasterCreateManyCompanyInputEnvelope
    set?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    disconnect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    delete?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    update?: TransactionsMasterUpdateWithWhereUniqueWithoutCompanyInput | TransactionsMasterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransactionsMasterUpdateManyWithWhereWithoutCompanyInput | TransactionsMasterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
  }

  export type UsersUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UsersCreateWithoutCompanyInput, UsersUncheckedCreateWithoutCompanyInput> | UsersCreateWithoutCompanyInput[] | UsersUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutCompanyInput | UsersCreateOrConnectWithoutCompanyInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutCompanyInput | UsersUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UsersCreateManyCompanyInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutCompanyInput | UsersUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutCompanyInput | UsersUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type FinancialYearUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FinancialYearCreateWithoutCompanyInput, FinancialYearUncheckedCreateWithoutCompanyInput> | FinancialYearCreateWithoutCompanyInput[] | FinancialYearUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialYearCreateOrConnectWithoutCompanyInput | FinancialYearCreateOrConnectWithoutCompanyInput[]
    upsert?: FinancialYearUpsertWithWhereUniqueWithoutCompanyInput | FinancialYearUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FinancialYearCreateManyCompanyInputEnvelope
    set?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
    disconnect?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
    delete?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
    connect?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
    update?: FinancialYearUpdateWithWhereUniqueWithoutCompanyInput | FinancialYearUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FinancialYearUpdateManyWithWhereWithoutCompanyInput | FinancialYearUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FinancialYearScalarWhereInput | FinancialYearScalarWhereInput[]
  }

  export type SeasonUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SeasonCreateWithoutCompanyInput, SeasonUncheckedCreateWithoutCompanyInput> | SeasonCreateWithoutCompanyInput[] | SeasonUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutCompanyInput | SeasonCreateOrConnectWithoutCompanyInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutCompanyInput | SeasonUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SeasonCreateManyCompanyInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutCompanyInput | SeasonUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutCompanyInput | SeasonUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type PoPrdCatUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PoPrdCatCreateWithoutCompanyInput, PoPrdCatUncheckedCreateWithoutCompanyInput> | PoPrdCatCreateWithoutCompanyInput[] | PoPrdCatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PoPrdCatCreateOrConnectWithoutCompanyInput | PoPrdCatCreateOrConnectWithoutCompanyInput[]
    upsert?: PoPrdCatUpsertWithWhereUniqueWithoutCompanyInput | PoPrdCatUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PoPrdCatCreateManyCompanyInputEnvelope
    set?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
    disconnect?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
    delete?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
    connect?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
    update?: PoPrdCatUpdateWithWhereUniqueWithoutCompanyInput | PoPrdCatUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PoPrdCatUpdateManyWithWhereWithoutCompanyInput | PoPrdCatUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PoPrdCatScalarWhereInput | PoPrdCatScalarWhereInput[]
  }

  export type DeliveryModeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DeliveryModeCreateWithoutCompanyInput, DeliveryModeUncheckedCreateWithoutCompanyInput> | DeliveryModeCreateWithoutCompanyInput[] | DeliveryModeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeliveryModeCreateOrConnectWithoutCompanyInput | DeliveryModeCreateOrConnectWithoutCompanyInput[]
    upsert?: DeliveryModeUpsertWithWhereUniqueWithoutCompanyInput | DeliveryModeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DeliveryModeCreateManyCompanyInputEnvelope
    set?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
    disconnect?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
    delete?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
    connect?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
    update?: DeliveryModeUpdateWithWhereUniqueWithoutCompanyInput | DeliveryModeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DeliveryModeUpdateManyWithWhereWithoutCompanyInput | DeliveryModeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DeliveryModeScalarWhereInput | DeliveryModeScalarWhereInput[]
  }

  export type DeliveryTermUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DeliveryTermCreateWithoutCompanyInput, DeliveryTermUncheckedCreateWithoutCompanyInput> | DeliveryTermCreateWithoutCompanyInput[] | DeliveryTermUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeliveryTermCreateOrConnectWithoutCompanyInput | DeliveryTermCreateOrConnectWithoutCompanyInput[]
    upsert?: DeliveryTermUpsertWithWhereUniqueWithoutCompanyInput | DeliveryTermUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DeliveryTermCreateManyCompanyInputEnvelope
    set?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
    disconnect?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
    delete?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
    connect?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
    update?: DeliveryTermUpdateWithWhereUniqueWithoutCompanyInput | DeliveryTermUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DeliveryTermUpdateManyWithWhereWithoutCompanyInput | DeliveryTermUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DeliveryTermScalarWhereInput | DeliveryTermScalarWhereInput[]
  }

  export type CommissionTermUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CommissionTermCreateWithoutCompanyInput, CommissionTermUncheckedCreateWithoutCompanyInput> | CommissionTermCreateWithoutCompanyInput[] | CommissionTermUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CommissionTermCreateOrConnectWithoutCompanyInput | CommissionTermCreateOrConnectWithoutCompanyInput[]
    upsert?: CommissionTermUpsertWithWhereUniqueWithoutCompanyInput | CommissionTermUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CommissionTermCreateManyCompanyInputEnvelope
    set?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
    disconnect?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
    delete?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
    connect?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
    update?: CommissionTermUpdateWithWhereUniqueWithoutCompanyInput | CommissionTermUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CommissionTermUpdateManyWithWhereWithoutCompanyInput | CommissionTermUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CommissionTermScalarWhereInput | CommissionTermScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput> | EmployeeCreateWithoutCompanyInput[] | EmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCompanyInput | EmployeeCreateOrConnectWithoutCompanyInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutCompanyInput | EmployeeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EmployeeCreateManyCompanyInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutCompanyInput | EmployeeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutCompanyInput | EmployeeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CostCenterUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput> | CostCenterCreateWithoutCompanyInput[] | CostCenterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CostCenterCreateOrConnectWithoutCompanyInput | CostCenterCreateOrConnectWithoutCompanyInput[]
    upsert?: CostCenterUpsertWithWhereUniqueWithoutCompanyInput | CostCenterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CostCenterCreateManyCompanyInputEnvelope
    set?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    disconnect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    delete?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    connect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    update?: CostCenterUpdateWithWhereUniqueWithoutCompanyInput | CostCenterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CostCenterUpdateManyWithWhereWithoutCompanyInput | CostCenterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CostCenterScalarWhereInput | CostCenterScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCompanyInput | DepartmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCompanyInput | DepartmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCompanyInput | DepartmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DesignationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DesignationCreateWithoutCompanyInput, DesignationUncheckedCreateWithoutCompanyInput> | DesignationCreateWithoutCompanyInput[] | DesignationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DesignationCreateOrConnectWithoutCompanyInput | DesignationCreateOrConnectWithoutCompanyInput[]
    upsert?: DesignationUpsertWithWhereUniqueWithoutCompanyInput | DesignationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DesignationCreateManyCompanyInputEnvelope
    set?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    disconnect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    delete?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    connect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    update?: DesignationUpdateWithWhereUniqueWithoutCompanyInput | DesignationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DesignationUpdateManyWithWhereWithoutCompanyInput | DesignationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DesignationScalarWhereInput | DesignationScalarWhereInput[]
  }

  export type GodownUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GodownCreateWithoutCompanyInput, GodownUncheckedCreateWithoutCompanyInput> | GodownCreateWithoutCompanyInput[] | GodownUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GodownCreateOrConnectWithoutCompanyInput | GodownCreateOrConnectWithoutCompanyInput[]
    upsert?: GodownUpsertWithWhereUniqueWithoutCompanyInput | GodownUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GodownCreateManyCompanyInputEnvelope
    set?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
    disconnect?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
    delete?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
    connect?: GodownWhereUniqueInput | GodownWhereUniqueInput[]
    update?: GodownUpdateWithWhereUniqueWithoutCompanyInput | GodownUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GodownUpdateManyWithWhereWithoutCompanyInput | GodownUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GodownScalarWhereInput | GodownScalarWhereInput[]
  }

  export type TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutCompanyInput, TransactionsMasterUncheckedCreateWithoutCompanyInput> | TransactionsMasterCreateWithoutCompanyInput[] | TransactionsMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutCompanyInput | TransactionsMasterCreateOrConnectWithoutCompanyInput[]
    upsert?: TransactionsMasterUpsertWithWhereUniqueWithoutCompanyInput | TransactionsMasterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransactionsMasterCreateManyCompanyInputEnvelope
    set?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    disconnect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    delete?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    update?: TransactionsMasterUpdateWithWhereUniqueWithoutCompanyInput | TransactionsMasterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransactionsMasterUpdateManyWithWhereWithoutCompanyInput | TransactionsMasterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UsersCreateWithoutCompanyInput, UsersUncheckedCreateWithoutCompanyInput> | UsersCreateWithoutCompanyInput[] | UsersUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutCompanyInput | UsersCreateOrConnectWithoutCompanyInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutCompanyInput | UsersUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UsersCreateManyCompanyInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutCompanyInput | UsersUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutCompanyInput | UsersUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FinancialYearCreateWithoutCompanyInput, FinancialYearUncheckedCreateWithoutCompanyInput> | FinancialYearCreateWithoutCompanyInput[] | FinancialYearUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialYearCreateOrConnectWithoutCompanyInput | FinancialYearCreateOrConnectWithoutCompanyInput[]
    upsert?: FinancialYearUpsertWithWhereUniqueWithoutCompanyInput | FinancialYearUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FinancialYearCreateManyCompanyInputEnvelope
    set?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
    disconnect?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
    delete?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
    connect?: FinancialYearWhereUniqueInput | FinancialYearWhereUniqueInput[]
    update?: FinancialYearUpdateWithWhereUniqueWithoutCompanyInput | FinancialYearUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FinancialYearUpdateManyWithWhereWithoutCompanyInput | FinancialYearUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FinancialYearScalarWhereInput | FinancialYearScalarWhereInput[]
  }

  export type SeasonUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SeasonCreateWithoutCompanyInput, SeasonUncheckedCreateWithoutCompanyInput> | SeasonCreateWithoutCompanyInput[] | SeasonUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutCompanyInput | SeasonCreateOrConnectWithoutCompanyInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutCompanyInput | SeasonUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SeasonCreateManyCompanyInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutCompanyInput | SeasonUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutCompanyInput | SeasonUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PoPrdCatCreateWithoutCompanyInput, PoPrdCatUncheckedCreateWithoutCompanyInput> | PoPrdCatCreateWithoutCompanyInput[] | PoPrdCatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PoPrdCatCreateOrConnectWithoutCompanyInput | PoPrdCatCreateOrConnectWithoutCompanyInput[]
    upsert?: PoPrdCatUpsertWithWhereUniqueWithoutCompanyInput | PoPrdCatUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PoPrdCatCreateManyCompanyInputEnvelope
    set?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
    disconnect?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
    delete?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
    connect?: PoPrdCatWhereUniqueInput | PoPrdCatWhereUniqueInput[]
    update?: PoPrdCatUpdateWithWhereUniqueWithoutCompanyInput | PoPrdCatUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PoPrdCatUpdateManyWithWhereWithoutCompanyInput | PoPrdCatUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PoPrdCatScalarWhereInput | PoPrdCatScalarWhereInput[]
  }

  export type DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DeliveryModeCreateWithoutCompanyInput, DeliveryModeUncheckedCreateWithoutCompanyInput> | DeliveryModeCreateWithoutCompanyInput[] | DeliveryModeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeliveryModeCreateOrConnectWithoutCompanyInput | DeliveryModeCreateOrConnectWithoutCompanyInput[]
    upsert?: DeliveryModeUpsertWithWhereUniqueWithoutCompanyInput | DeliveryModeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DeliveryModeCreateManyCompanyInputEnvelope
    set?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
    disconnect?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
    delete?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
    connect?: DeliveryModeWhereUniqueInput | DeliveryModeWhereUniqueInput[]
    update?: DeliveryModeUpdateWithWhereUniqueWithoutCompanyInput | DeliveryModeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DeliveryModeUpdateManyWithWhereWithoutCompanyInput | DeliveryModeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DeliveryModeScalarWhereInput | DeliveryModeScalarWhereInput[]
  }

  export type DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DeliveryTermCreateWithoutCompanyInput, DeliveryTermUncheckedCreateWithoutCompanyInput> | DeliveryTermCreateWithoutCompanyInput[] | DeliveryTermUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeliveryTermCreateOrConnectWithoutCompanyInput | DeliveryTermCreateOrConnectWithoutCompanyInput[]
    upsert?: DeliveryTermUpsertWithWhereUniqueWithoutCompanyInput | DeliveryTermUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DeliveryTermCreateManyCompanyInputEnvelope
    set?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
    disconnect?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
    delete?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
    connect?: DeliveryTermWhereUniqueInput | DeliveryTermWhereUniqueInput[]
    update?: DeliveryTermUpdateWithWhereUniqueWithoutCompanyInput | DeliveryTermUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DeliveryTermUpdateManyWithWhereWithoutCompanyInput | DeliveryTermUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DeliveryTermScalarWhereInput | DeliveryTermScalarWhereInput[]
  }

  export type CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CommissionTermCreateWithoutCompanyInput, CommissionTermUncheckedCreateWithoutCompanyInput> | CommissionTermCreateWithoutCompanyInput[] | CommissionTermUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CommissionTermCreateOrConnectWithoutCompanyInput | CommissionTermCreateOrConnectWithoutCompanyInput[]
    upsert?: CommissionTermUpsertWithWhereUniqueWithoutCompanyInput | CommissionTermUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CommissionTermCreateManyCompanyInputEnvelope
    set?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
    disconnect?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
    delete?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
    connect?: CommissionTermWhereUniqueInput | CommissionTermWhereUniqueInput[]
    update?: CommissionTermUpdateWithWhereUniqueWithoutCompanyInput | CommissionTermUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CommissionTermUpdateManyWithWhereWithoutCompanyInput | CommissionTermUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CommissionTermScalarWhereInput | CommissionTermScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput> | EmployeeCreateWithoutCompanyInput[] | EmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCompanyInput | EmployeeCreateOrConnectWithoutCompanyInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutCompanyInput | EmployeeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EmployeeCreateManyCompanyInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutCompanyInput | EmployeeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutCompanyInput | EmployeeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCostCentersInput = {
    create?: XOR<CompanyCreateWithoutCostCentersInput, CompanyUncheckedCreateWithoutCostCentersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCostCentersInput
    connect?: CompanyWhereUniqueInput
  }

  export type TransactionsCreateNestedManyWithoutCostCenterInput = {
    create?: XOR<TransactionsCreateWithoutCostCenterInput, TransactionsUncheckedCreateWithoutCostCenterInput> | TransactionsCreateWithoutCostCenterInput[] | TransactionsUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutCostCenterInput | TransactionsCreateOrConnectWithoutCostCenterInput[]
    createMany?: TransactionsCreateManyCostCenterInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutCostCenterInput = {
    create?: XOR<TransactionsCreateWithoutCostCenterInput, TransactionsUncheckedCreateWithoutCostCenterInput> | TransactionsCreateWithoutCostCenterInput[] | TransactionsUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutCostCenterInput | TransactionsCreateOrConnectWithoutCostCenterInput[]
    createMany?: TransactionsCreateManyCostCenterInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutCostCentersNestedInput = {
    create?: XOR<CompanyCreateWithoutCostCentersInput, CompanyUncheckedCreateWithoutCostCentersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCostCentersInput
    upsert?: CompanyUpsertWithoutCostCentersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCostCentersInput, CompanyUpdateWithoutCostCentersInput>, CompanyUncheckedUpdateWithoutCostCentersInput>
  }

  export type TransactionsUpdateManyWithoutCostCenterNestedInput = {
    create?: XOR<TransactionsCreateWithoutCostCenterInput, TransactionsUncheckedCreateWithoutCostCenterInput> | TransactionsCreateWithoutCostCenterInput[] | TransactionsUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutCostCenterInput | TransactionsCreateOrConnectWithoutCostCenterInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutCostCenterInput | TransactionsUpsertWithWhereUniqueWithoutCostCenterInput[]
    createMany?: TransactionsCreateManyCostCenterInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutCostCenterInput | TransactionsUpdateWithWhereUniqueWithoutCostCenterInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutCostCenterInput | TransactionsUpdateManyWithWhereWithoutCostCenterInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutCostCenterNestedInput = {
    create?: XOR<TransactionsCreateWithoutCostCenterInput, TransactionsUncheckedCreateWithoutCostCenterInput> | TransactionsCreateWithoutCostCenterInput[] | TransactionsUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutCostCenterInput | TransactionsCreateOrConnectWithoutCostCenterInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutCostCenterInput | TransactionsUpsertWithWhereUniqueWithoutCostCenterInput[]
    createMany?: TransactionsCreateManyCostCenterInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutCostCenterInput | TransactionsUpdateWithWhereUniqueWithoutCostCenterInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutCostCenterInput | TransactionsUpdateManyWithWhereWithoutCostCenterInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDepartmentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDepartmentsInput
    upsert?: CompanyUpsertWithoutDepartmentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDepartmentsInput, CompanyUpdateWithoutDepartmentsInput>, CompanyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type ProductGroupCreateNestedManyWithoutProductMasterCategoriesInput = {
    create?: XOR<ProductGroupCreateWithoutProductMasterCategoriesInput, ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput> | ProductGroupCreateWithoutProductMasterCategoriesInput[] | ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput[]
    connectOrCreate?: ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput | ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput[]
    createMany?: ProductGroupCreateManyProductMasterCategoriesInputEnvelope
    connect?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
  }

  export type ProductGroupUncheckedCreateNestedManyWithoutProductMasterCategoriesInput = {
    create?: XOR<ProductGroupCreateWithoutProductMasterCategoriesInput, ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput> | ProductGroupCreateWithoutProductMasterCategoriesInput[] | ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput[]
    connectOrCreate?: ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput | ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput[]
    createMany?: ProductGroupCreateManyProductMasterCategoriesInputEnvelope
    connect?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
  }

  export type ProductGroupUpdateManyWithoutProductMasterCategoriesNestedInput = {
    create?: XOR<ProductGroupCreateWithoutProductMasterCategoriesInput, ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput> | ProductGroupCreateWithoutProductMasterCategoriesInput[] | ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput[]
    connectOrCreate?: ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput | ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput[]
    upsert?: ProductGroupUpsertWithWhereUniqueWithoutProductMasterCategoriesInput | ProductGroupUpsertWithWhereUniqueWithoutProductMasterCategoriesInput[]
    createMany?: ProductGroupCreateManyProductMasterCategoriesInputEnvelope
    set?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
    disconnect?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
    delete?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
    connect?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
    update?: ProductGroupUpdateWithWhereUniqueWithoutProductMasterCategoriesInput | ProductGroupUpdateWithWhereUniqueWithoutProductMasterCategoriesInput[]
    updateMany?: ProductGroupUpdateManyWithWhereWithoutProductMasterCategoriesInput | ProductGroupUpdateManyWithWhereWithoutProductMasterCategoriesInput[]
    deleteMany?: ProductGroupScalarWhereInput | ProductGroupScalarWhereInput[]
  }

  export type ProductGroupUncheckedUpdateManyWithoutProductMasterCategoriesNestedInput = {
    create?: XOR<ProductGroupCreateWithoutProductMasterCategoriesInput, ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput> | ProductGroupCreateWithoutProductMasterCategoriesInput[] | ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput[]
    connectOrCreate?: ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput | ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput[]
    upsert?: ProductGroupUpsertWithWhereUniqueWithoutProductMasterCategoriesInput | ProductGroupUpsertWithWhereUniqueWithoutProductMasterCategoriesInput[]
    createMany?: ProductGroupCreateManyProductMasterCategoriesInputEnvelope
    set?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
    disconnect?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
    delete?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
    connect?: ProductGroupWhereUniqueInput | ProductGroupWhereUniqueInput[]
    update?: ProductGroupUpdateWithWhereUniqueWithoutProductMasterCategoriesInput | ProductGroupUpdateWithWhereUniqueWithoutProductMasterCategoriesInput[]
    updateMany?: ProductGroupUpdateManyWithWhereWithoutProductMasterCategoriesInput | ProductGroupUpdateManyWithWhereWithoutProductMasterCategoriesInput[]
    deleteMany?: ProductGroupScalarWhereInput | ProductGroupScalarWhereInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutProductGroupsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductGroupsInput, ProductCategoryUncheckedCreateWithoutProductGroupsInput> | ProductCategoryCreateWithoutProductGroupsInput[] | ProductCategoryUncheckedCreateWithoutProductGroupsInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductGroupsInput | ProductCategoryCreateOrConnectWithoutProductGroupsInput[]
    createMany?: ProductCategoryCreateManyProductGroupsInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductMasterCategoryCreateNestedOneWithoutProductGroupsInput = {
    create?: XOR<ProductMasterCategoryCreateWithoutProductGroupsInput, ProductMasterCategoryUncheckedCreateWithoutProductGroupsInput>
    connectOrCreate?: ProductMasterCategoryCreateOrConnectWithoutProductGroupsInput
    connect?: ProductMasterCategoryWhereUniqueInput
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutProductGroupsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductGroupsInput, ProductCategoryUncheckedCreateWithoutProductGroupsInput> | ProductCategoryCreateWithoutProductGroupsInput[] | ProductCategoryUncheckedCreateWithoutProductGroupsInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductGroupsInput | ProductCategoryCreateOrConnectWithoutProductGroupsInput[]
    createMany?: ProductCategoryCreateManyProductGroupsInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCategoryUpdateManyWithoutProductGroupsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductGroupsInput, ProductCategoryUncheckedCreateWithoutProductGroupsInput> | ProductCategoryCreateWithoutProductGroupsInput[] | ProductCategoryUncheckedCreateWithoutProductGroupsInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductGroupsInput | ProductCategoryCreateOrConnectWithoutProductGroupsInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductGroupsInput | ProductCategoryUpsertWithWhereUniqueWithoutProductGroupsInput[]
    createMany?: ProductCategoryCreateManyProductGroupsInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductGroupsInput | ProductCategoryUpdateWithWhereUniqueWithoutProductGroupsInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductGroupsInput | ProductCategoryUpdateManyWithWhereWithoutProductGroupsInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductMasterCategoryUpdateOneRequiredWithoutProductGroupsNestedInput = {
    create?: XOR<ProductMasterCategoryCreateWithoutProductGroupsInput, ProductMasterCategoryUncheckedCreateWithoutProductGroupsInput>
    connectOrCreate?: ProductMasterCategoryCreateOrConnectWithoutProductGroupsInput
    upsert?: ProductMasterCategoryUpsertWithoutProductGroupsInput
    connect?: ProductMasterCategoryWhereUniqueInput
    update?: XOR<XOR<ProductMasterCategoryUpdateToOneWithWhereWithoutProductGroupsInput, ProductMasterCategoryUpdateWithoutProductGroupsInput>, ProductMasterCategoryUncheckedUpdateWithoutProductGroupsInput>
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductGroupsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductGroupsInput, ProductCategoryUncheckedCreateWithoutProductGroupsInput> | ProductCategoryCreateWithoutProductGroupsInput[] | ProductCategoryUncheckedCreateWithoutProductGroupsInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductGroupsInput | ProductCategoryCreateOrConnectWithoutProductGroupsInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductGroupsInput | ProductCategoryUpsertWithWhereUniqueWithoutProductGroupsInput[]
    createMany?: ProductCategoryCreateManyProductGroupsInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductGroupsInput | ProductCategoryUpdateWithWhereUniqueWithoutProductGroupsInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductGroupsInput | ProductCategoryUpdateManyWithWhereWithoutProductGroupsInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type MainCategoryCreateNestedManyWithoutProductCategoriesInput = {
    create?: XOR<MainCategoryCreateWithoutProductCategoriesInput, MainCategoryUncheckedCreateWithoutProductCategoriesInput> | MainCategoryCreateWithoutProductCategoriesInput[] | MainCategoryUncheckedCreateWithoutProductCategoriesInput[]
    connectOrCreate?: MainCategoryCreateOrConnectWithoutProductCategoriesInput | MainCategoryCreateOrConnectWithoutProductCategoriesInput[]
    createMany?: MainCategoryCreateManyProductCategoriesInputEnvelope
    connect?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
  }

  export type ProductGroupCreateNestedOneWithoutProductCategoriesInput = {
    create?: XOR<ProductGroupCreateWithoutProductCategoriesInput, ProductGroupUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: ProductGroupCreateOrConnectWithoutProductCategoriesInput
    connect?: ProductGroupWhereUniqueInput
  }

  export type MainCategoryUncheckedCreateNestedManyWithoutProductCategoriesInput = {
    create?: XOR<MainCategoryCreateWithoutProductCategoriesInput, MainCategoryUncheckedCreateWithoutProductCategoriesInput> | MainCategoryCreateWithoutProductCategoriesInput[] | MainCategoryUncheckedCreateWithoutProductCategoriesInput[]
    connectOrCreate?: MainCategoryCreateOrConnectWithoutProductCategoriesInput | MainCategoryCreateOrConnectWithoutProductCategoriesInput[]
    createMany?: MainCategoryCreateManyProductCategoriesInputEnvelope
    connect?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
  }

  export type MainCategoryUpdateManyWithoutProductCategoriesNestedInput = {
    create?: XOR<MainCategoryCreateWithoutProductCategoriesInput, MainCategoryUncheckedCreateWithoutProductCategoriesInput> | MainCategoryCreateWithoutProductCategoriesInput[] | MainCategoryUncheckedCreateWithoutProductCategoriesInput[]
    connectOrCreate?: MainCategoryCreateOrConnectWithoutProductCategoriesInput | MainCategoryCreateOrConnectWithoutProductCategoriesInput[]
    upsert?: MainCategoryUpsertWithWhereUniqueWithoutProductCategoriesInput | MainCategoryUpsertWithWhereUniqueWithoutProductCategoriesInput[]
    createMany?: MainCategoryCreateManyProductCategoriesInputEnvelope
    set?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
    disconnect?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
    delete?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
    connect?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
    update?: MainCategoryUpdateWithWhereUniqueWithoutProductCategoriesInput | MainCategoryUpdateWithWhereUniqueWithoutProductCategoriesInput[]
    updateMany?: MainCategoryUpdateManyWithWhereWithoutProductCategoriesInput | MainCategoryUpdateManyWithWhereWithoutProductCategoriesInput[]
    deleteMany?: MainCategoryScalarWhereInput | MainCategoryScalarWhereInput[]
  }

  export type ProductGroupUpdateOneRequiredWithoutProductCategoriesNestedInput = {
    create?: XOR<ProductGroupCreateWithoutProductCategoriesInput, ProductGroupUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: ProductGroupCreateOrConnectWithoutProductCategoriesInput
    upsert?: ProductGroupUpsertWithoutProductCategoriesInput
    connect?: ProductGroupWhereUniqueInput
    update?: XOR<XOR<ProductGroupUpdateToOneWithWhereWithoutProductCategoriesInput, ProductGroupUpdateWithoutProductCategoriesInput>, ProductGroupUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type MainCategoryUncheckedUpdateManyWithoutProductCategoriesNestedInput = {
    create?: XOR<MainCategoryCreateWithoutProductCategoriesInput, MainCategoryUncheckedCreateWithoutProductCategoriesInput> | MainCategoryCreateWithoutProductCategoriesInput[] | MainCategoryUncheckedCreateWithoutProductCategoriesInput[]
    connectOrCreate?: MainCategoryCreateOrConnectWithoutProductCategoriesInput | MainCategoryCreateOrConnectWithoutProductCategoriesInput[]
    upsert?: MainCategoryUpsertWithWhereUniqueWithoutProductCategoriesInput | MainCategoryUpsertWithWhereUniqueWithoutProductCategoriesInput[]
    createMany?: MainCategoryCreateManyProductCategoriesInputEnvelope
    set?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
    disconnect?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
    delete?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
    connect?: MainCategoryWhereUniqueInput | MainCategoryWhereUniqueInput[]
    update?: MainCategoryUpdateWithWhereUniqueWithoutProductCategoriesInput | MainCategoryUpdateWithWhereUniqueWithoutProductCategoriesInput[]
    updateMany?: MainCategoryUpdateManyWithWhereWithoutProductCategoriesInput | MainCategoryUpdateManyWithWhereWithoutProductCategoriesInput[]
    deleteMany?: MainCategoryScalarWhereInput | MainCategoryScalarWhereInput[]
  }

  export type ItemCategoryCreateNestedManyWithoutMainCategoryInput = {
    create?: XOR<ItemCategoryCreateWithoutMainCategoryInput, ItemCategoryUncheckedCreateWithoutMainCategoryInput> | ItemCategoryCreateWithoutMainCategoryInput[] | ItemCategoryUncheckedCreateWithoutMainCategoryInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutMainCategoryInput | ItemCategoryCreateOrConnectWithoutMainCategoryInput[]
    createMany?: ItemCategoryCreateManyMainCategoryInputEnvelope
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedOneWithoutMainCategoriesInput = {
    create?: XOR<ProductCategoryCreateWithoutMainCategoriesInput, ProductCategoryUncheckedCreateWithoutMainCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutMainCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ItemCategoryUncheckedCreateNestedManyWithoutMainCategoryInput = {
    create?: XOR<ItemCategoryCreateWithoutMainCategoryInput, ItemCategoryUncheckedCreateWithoutMainCategoryInput> | ItemCategoryCreateWithoutMainCategoryInput[] | ItemCategoryUncheckedCreateWithoutMainCategoryInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutMainCategoryInput | ItemCategoryCreateOrConnectWithoutMainCategoryInput[]
    createMany?: ItemCategoryCreateManyMainCategoryInputEnvelope
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
  }

  export type ItemCategoryUpdateManyWithoutMainCategoryNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutMainCategoryInput, ItemCategoryUncheckedCreateWithoutMainCategoryInput> | ItemCategoryCreateWithoutMainCategoryInput[] | ItemCategoryUncheckedCreateWithoutMainCategoryInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutMainCategoryInput | ItemCategoryCreateOrConnectWithoutMainCategoryInput[]
    upsert?: ItemCategoryUpsertWithWhereUniqueWithoutMainCategoryInput | ItemCategoryUpsertWithWhereUniqueWithoutMainCategoryInput[]
    createMany?: ItemCategoryCreateManyMainCategoryInputEnvelope
    set?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    disconnect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    delete?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    update?: ItemCategoryUpdateWithWhereUniqueWithoutMainCategoryInput | ItemCategoryUpdateWithWhereUniqueWithoutMainCategoryInput[]
    updateMany?: ItemCategoryUpdateManyWithWhereWithoutMainCategoryInput | ItemCategoryUpdateManyWithWhereWithoutMainCategoryInput[]
    deleteMany?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
  }

  export type ProductCategoryUpdateOneRequiredWithoutMainCategoriesNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutMainCategoriesInput, ProductCategoryUncheckedCreateWithoutMainCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutMainCategoriesInput
    upsert?: ProductCategoryUpsertWithoutMainCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutMainCategoriesInput, ProductCategoryUpdateWithoutMainCategoriesInput>, ProductCategoryUncheckedUpdateWithoutMainCategoriesInput>
  }

  export type ItemCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutMainCategoryInput, ItemCategoryUncheckedCreateWithoutMainCategoryInput> | ItemCategoryCreateWithoutMainCategoryInput[] | ItemCategoryUncheckedCreateWithoutMainCategoryInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutMainCategoryInput | ItemCategoryCreateOrConnectWithoutMainCategoryInput[]
    upsert?: ItemCategoryUpsertWithWhereUniqueWithoutMainCategoryInput | ItemCategoryUpsertWithWhereUniqueWithoutMainCategoryInput[]
    createMany?: ItemCategoryCreateManyMainCategoryInputEnvelope
    set?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    disconnect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    delete?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    update?: ItemCategoryUpdateWithWhereUniqueWithoutMainCategoryInput | ItemCategoryUpdateWithWhereUniqueWithoutMainCategoryInput[]
    updateMany?: ItemCategoryUpdateManyWithWhereWithoutMainCategoryInput | ItemCategoryUpdateManyWithWhereWithoutMainCategoryInput[]
    deleteMany?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
  }

  export type MainCategoryCreateNestedOneWithoutItemCategoriesInput = {
    create?: XOR<MainCategoryCreateWithoutItemCategoriesInput, MainCategoryUncheckedCreateWithoutItemCategoriesInput>
    connectOrCreate?: MainCategoryCreateOrConnectWithoutItemCategoriesInput
    connect?: MainCategoryWhereUniqueInput
  }

  export type ItemCreateNestedManyWithoutItemCategoriesInput = {
    create?: XOR<ItemCreateWithoutItemCategoriesInput, ItemUncheckedCreateWithoutItemCategoriesInput> | ItemCreateWithoutItemCategoriesInput[] | ItemUncheckedCreateWithoutItemCategoriesInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemCategoriesInput | ItemCreateOrConnectWithoutItemCategoriesInput[]
    createMany?: ItemCreateManyItemCategoriesInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutItemCategoriesInput = {
    create?: XOR<ItemCreateWithoutItemCategoriesInput, ItemUncheckedCreateWithoutItemCategoriesInput> | ItemCreateWithoutItemCategoriesInput[] | ItemUncheckedCreateWithoutItemCategoriesInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemCategoriesInput | ItemCreateOrConnectWithoutItemCategoriesInput[]
    createMany?: ItemCreateManyItemCategoriesInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MainCategoryUpdateOneRequiredWithoutItemCategoriesNestedInput = {
    create?: XOR<MainCategoryCreateWithoutItemCategoriesInput, MainCategoryUncheckedCreateWithoutItemCategoriesInput>
    connectOrCreate?: MainCategoryCreateOrConnectWithoutItemCategoriesInput
    upsert?: MainCategoryUpsertWithoutItemCategoriesInput
    connect?: MainCategoryWhereUniqueInput
    update?: XOR<XOR<MainCategoryUpdateToOneWithWhereWithoutItemCategoriesInput, MainCategoryUpdateWithoutItemCategoriesInput>, MainCategoryUncheckedUpdateWithoutItemCategoriesInput>
  }

  export type ItemUpdateManyWithoutItemCategoriesNestedInput = {
    create?: XOR<ItemCreateWithoutItemCategoriesInput, ItemUncheckedCreateWithoutItemCategoriesInput> | ItemCreateWithoutItemCategoriesInput[] | ItemUncheckedCreateWithoutItemCategoriesInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemCategoriesInput | ItemCreateOrConnectWithoutItemCategoriesInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItemCategoriesInput | ItemUpsertWithWhereUniqueWithoutItemCategoriesInput[]
    createMany?: ItemCreateManyItemCategoriesInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItemCategoriesInput | ItemUpdateWithWhereUniqueWithoutItemCategoriesInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItemCategoriesInput | ItemUpdateManyWithWhereWithoutItemCategoriesInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutItemCategoriesNestedInput = {
    create?: XOR<ItemCreateWithoutItemCategoriesInput, ItemUncheckedCreateWithoutItemCategoriesInput> | ItemCreateWithoutItemCategoriesInput[] | ItemUncheckedCreateWithoutItemCategoriesInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemCategoriesInput | ItemCreateOrConnectWithoutItemCategoriesInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItemCategoriesInput | ItemUpsertWithWhereUniqueWithoutItemCategoriesInput[]
    createMany?: ItemCreateManyItemCategoriesInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItemCategoriesInput | ItemUpdateWithWhereUniqueWithoutItemCategoriesInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItemCategoriesInput | ItemUpdateManyWithWhereWithoutItemCategoriesInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemCategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type TransactionsCreateNestedManyWithoutItemDetailsInput = {
    create?: XOR<TransactionsCreateWithoutItemDetailsInput, TransactionsUncheckedCreateWithoutItemDetailsInput> | TransactionsCreateWithoutItemDetailsInput[] | TransactionsUncheckedCreateWithoutItemDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutItemDetailsInput | TransactionsCreateOrConnectWithoutItemDetailsInput[]
    createMany?: TransactionsCreateManyItemDetailsInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutItemDetailsInput = {
    create?: XOR<TransactionsCreateWithoutItemDetailsInput, TransactionsUncheckedCreateWithoutItemDetailsInput> | TransactionsCreateWithoutItemDetailsInput[] | TransactionsUncheckedCreateWithoutItemDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutItemDetailsInput | TransactionsCreateOrConnectWithoutItemDetailsInput[]
    createMany?: TransactionsCreateManyItemDetailsInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ItemCategoryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    upsert?: ItemCategoryUpsertWithoutItemsInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutItemsInput, ItemCategoryUpdateWithoutItemsInput>, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type TransactionsUpdateManyWithoutItemDetailsNestedInput = {
    create?: XOR<TransactionsCreateWithoutItemDetailsInput, TransactionsUncheckedCreateWithoutItemDetailsInput> | TransactionsCreateWithoutItemDetailsInput[] | TransactionsUncheckedCreateWithoutItemDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutItemDetailsInput | TransactionsCreateOrConnectWithoutItemDetailsInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutItemDetailsInput | TransactionsUpsertWithWhereUniqueWithoutItemDetailsInput[]
    createMany?: TransactionsCreateManyItemDetailsInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutItemDetailsInput | TransactionsUpdateWithWhereUniqueWithoutItemDetailsInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutItemDetailsInput | TransactionsUpdateManyWithWhereWithoutItemDetailsInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutItemDetailsNestedInput = {
    create?: XOR<TransactionsCreateWithoutItemDetailsInput, TransactionsUncheckedCreateWithoutItemDetailsInput> | TransactionsCreateWithoutItemDetailsInput[] | TransactionsUncheckedCreateWithoutItemDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutItemDetailsInput | TransactionsCreateOrConnectWithoutItemDetailsInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutItemDetailsInput | TransactionsUpsertWithWhereUniqueWithoutItemDetailsInput[]
    createMany?: TransactionsCreateManyItemDetailsInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutItemDetailsInput | TransactionsUpdateWithWhereUniqueWithoutItemDetailsInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutItemDetailsInput | TransactionsUpdateManyWithWhereWithoutItemDetailsInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutDesignationsInput = {
    create?: XOR<CompanyCreateWithoutDesignationsInput, CompanyUncheckedCreateWithoutDesignationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDesignationsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutDesignationsNestedInput = {
    create?: XOR<CompanyCreateWithoutDesignationsInput, CompanyUncheckedCreateWithoutDesignationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDesignationsInput
    upsert?: CompanyUpsertWithoutDesignationsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDesignationsInput, CompanyUpdateWithoutDesignationsInput>, CompanyUncheckedUpdateWithoutDesignationsInput>
  }

  export type CompanyCreateNestedOneWithoutGodownsInput = {
    create?: XOR<CompanyCreateWithoutGodownsInput, CompanyUncheckedCreateWithoutGodownsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGodownsInput
    connect?: CompanyWhereUniqueInput
  }

  export type TransactionsMasterCreateNestedManyWithoutGodownDetailsInput = {
    create?: XOR<TransactionsMasterCreateWithoutGodownDetailsInput, TransactionsMasterUncheckedCreateWithoutGodownDetailsInput> | TransactionsMasterCreateWithoutGodownDetailsInput[] | TransactionsMasterUncheckedCreateWithoutGodownDetailsInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutGodownDetailsInput | TransactionsMasterCreateOrConnectWithoutGodownDetailsInput[]
    createMany?: TransactionsMasterCreateManyGodownDetailsInputEnvelope
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
  }

  export type TransactionsCreateNestedManyWithoutGodownDetailsInput = {
    create?: XOR<TransactionsCreateWithoutGodownDetailsInput, TransactionsUncheckedCreateWithoutGodownDetailsInput> | TransactionsCreateWithoutGodownDetailsInput[] | TransactionsUncheckedCreateWithoutGodownDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutGodownDetailsInput | TransactionsCreateOrConnectWithoutGodownDetailsInput[]
    createMany?: TransactionsCreateManyGodownDetailsInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type TransactionsMasterUncheckedCreateNestedManyWithoutGodownDetailsInput = {
    create?: XOR<TransactionsMasterCreateWithoutGodownDetailsInput, TransactionsMasterUncheckedCreateWithoutGodownDetailsInput> | TransactionsMasterCreateWithoutGodownDetailsInput[] | TransactionsMasterUncheckedCreateWithoutGodownDetailsInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutGodownDetailsInput | TransactionsMasterCreateOrConnectWithoutGodownDetailsInput[]
    createMany?: TransactionsMasterCreateManyGodownDetailsInputEnvelope
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutGodownDetailsInput = {
    create?: XOR<TransactionsCreateWithoutGodownDetailsInput, TransactionsUncheckedCreateWithoutGodownDetailsInput> | TransactionsCreateWithoutGodownDetailsInput[] | TransactionsUncheckedCreateWithoutGodownDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutGodownDetailsInput | TransactionsCreateOrConnectWithoutGodownDetailsInput[]
    createMany?: TransactionsCreateManyGodownDetailsInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutGodownsNestedInput = {
    create?: XOR<CompanyCreateWithoutGodownsInput, CompanyUncheckedCreateWithoutGodownsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGodownsInput
    upsert?: CompanyUpsertWithoutGodownsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutGodownsInput, CompanyUpdateWithoutGodownsInput>, CompanyUncheckedUpdateWithoutGodownsInput>
  }

  export type TransactionsMasterUpdateManyWithoutGodownDetailsNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutGodownDetailsInput, TransactionsMasterUncheckedCreateWithoutGodownDetailsInput> | TransactionsMasterCreateWithoutGodownDetailsInput[] | TransactionsMasterUncheckedCreateWithoutGodownDetailsInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutGodownDetailsInput | TransactionsMasterCreateOrConnectWithoutGodownDetailsInput[]
    upsert?: TransactionsMasterUpsertWithWhereUniqueWithoutGodownDetailsInput | TransactionsMasterUpsertWithWhereUniqueWithoutGodownDetailsInput[]
    createMany?: TransactionsMasterCreateManyGodownDetailsInputEnvelope
    set?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    disconnect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    delete?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    update?: TransactionsMasterUpdateWithWhereUniqueWithoutGodownDetailsInput | TransactionsMasterUpdateWithWhereUniqueWithoutGodownDetailsInput[]
    updateMany?: TransactionsMasterUpdateManyWithWhereWithoutGodownDetailsInput | TransactionsMasterUpdateManyWithWhereWithoutGodownDetailsInput[]
    deleteMany?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
  }

  export type TransactionsUpdateManyWithoutGodownDetailsNestedInput = {
    create?: XOR<TransactionsCreateWithoutGodownDetailsInput, TransactionsUncheckedCreateWithoutGodownDetailsInput> | TransactionsCreateWithoutGodownDetailsInput[] | TransactionsUncheckedCreateWithoutGodownDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutGodownDetailsInput | TransactionsCreateOrConnectWithoutGodownDetailsInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutGodownDetailsInput | TransactionsUpsertWithWhereUniqueWithoutGodownDetailsInput[]
    createMany?: TransactionsCreateManyGodownDetailsInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutGodownDetailsInput | TransactionsUpdateWithWhereUniqueWithoutGodownDetailsInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutGodownDetailsInput | TransactionsUpdateManyWithWhereWithoutGodownDetailsInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type TransactionsMasterUncheckedUpdateManyWithoutGodownDetailsNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutGodownDetailsInput, TransactionsMasterUncheckedCreateWithoutGodownDetailsInput> | TransactionsMasterCreateWithoutGodownDetailsInput[] | TransactionsMasterUncheckedCreateWithoutGodownDetailsInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutGodownDetailsInput | TransactionsMasterCreateOrConnectWithoutGodownDetailsInput[]
    upsert?: TransactionsMasterUpsertWithWhereUniqueWithoutGodownDetailsInput | TransactionsMasterUpsertWithWhereUniqueWithoutGodownDetailsInput[]
    createMany?: TransactionsMasterCreateManyGodownDetailsInputEnvelope
    set?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    disconnect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    delete?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    update?: TransactionsMasterUpdateWithWhereUniqueWithoutGodownDetailsInput | TransactionsMasterUpdateWithWhereUniqueWithoutGodownDetailsInput[]
    updateMany?: TransactionsMasterUpdateManyWithWhereWithoutGodownDetailsInput | TransactionsMasterUpdateManyWithWhereWithoutGodownDetailsInput[]
    deleteMany?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutGodownDetailsNestedInput = {
    create?: XOR<TransactionsCreateWithoutGodownDetailsInput, TransactionsUncheckedCreateWithoutGodownDetailsInput> | TransactionsCreateWithoutGodownDetailsInput[] | TransactionsUncheckedCreateWithoutGodownDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutGodownDetailsInput | TransactionsCreateOrConnectWithoutGodownDetailsInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutGodownDetailsInput | TransactionsUpsertWithWhereUniqueWithoutGodownDetailsInput[]
    createMany?: TransactionsCreateManyGodownDetailsInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutGodownDetailsInput | TransactionsUpdateWithWhereUniqueWithoutGodownDetailsInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutGodownDetailsInput | TransactionsUpdateManyWithWhereWithoutGodownDetailsInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutFinancialYearsInput = {
    create?: XOR<CompanyCreateWithoutFinancialYearsInput, CompanyUncheckedCreateWithoutFinancialYearsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialYearsInput
    connect?: CompanyWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompanyUpdateOneRequiredWithoutFinancialYearsNestedInput = {
    create?: XOR<CompanyCreateWithoutFinancialYearsInput, CompanyUncheckedCreateWithoutFinancialYearsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialYearsInput
    upsert?: CompanyUpsertWithoutFinancialYearsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFinancialYearsInput, CompanyUpdateWithoutFinancialYearsInput>, CompanyUncheckedUpdateWithoutFinancialYearsInput>
  }

  export type CompanyCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<CompanyCreateWithoutSeasonsInput, CompanyUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSeasonsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<CompanyCreateWithoutSeasonsInput, CompanyUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSeasonsInput
    upsert?: CompanyUpsertWithoutSeasonsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSeasonsInput, CompanyUpdateWithoutSeasonsInput>, CompanyUncheckedUpdateWithoutSeasonsInput>
  }

  export type CompanyCreateNestedOneWithoutPoPrdCatsInput = {
    create?: XOR<CompanyCreateWithoutPoPrdCatsInput, CompanyUncheckedCreateWithoutPoPrdCatsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPoPrdCatsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutPoPrdCatsNestedInput = {
    create?: XOR<CompanyCreateWithoutPoPrdCatsInput, CompanyUncheckedCreateWithoutPoPrdCatsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPoPrdCatsInput
    upsert?: CompanyUpsertWithoutPoPrdCatsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPoPrdCatsInput, CompanyUpdateWithoutPoPrdCatsInput>, CompanyUncheckedUpdateWithoutPoPrdCatsInput>
  }

  export type CompanyCreateNestedOneWithoutDeliveryModesInput = {
    create?: XOR<CompanyCreateWithoutDeliveryModesInput, CompanyUncheckedCreateWithoutDeliveryModesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDeliveryModesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutDeliveryModesNestedInput = {
    create?: XOR<CompanyCreateWithoutDeliveryModesInput, CompanyUncheckedCreateWithoutDeliveryModesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDeliveryModesInput
    upsert?: CompanyUpsertWithoutDeliveryModesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDeliveryModesInput, CompanyUpdateWithoutDeliveryModesInput>, CompanyUncheckedUpdateWithoutDeliveryModesInput>
  }

  export type TransactionsMasterCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionsMasterCreateWithoutUserInput, TransactionsMasterUncheckedCreateWithoutUserInput> | TransactionsMasterCreateWithoutUserInput[] | TransactionsMasterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutUserInput | TransactionsMasterCreateOrConnectWithoutUserInput[]
    createMany?: TransactionsMasterCreateManyUserInputEnvelope
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type TransactionsMasterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionsMasterCreateWithoutUserInput, TransactionsMasterUncheckedCreateWithoutUserInput> | TransactionsMasterCreateWithoutUserInput[] | TransactionsMasterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutUserInput | TransactionsMasterCreateOrConnectWithoutUserInput[]
    createMany?: TransactionsMasterCreateManyUserInputEnvelope
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
  }

  export type TransactionsMasterUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutUserInput, TransactionsMasterUncheckedCreateWithoutUserInput> | TransactionsMasterCreateWithoutUserInput[] | TransactionsMasterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutUserInput | TransactionsMasterCreateOrConnectWithoutUserInput[]
    upsert?: TransactionsMasterUpsertWithWhereUniqueWithoutUserInput | TransactionsMasterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionsMasterCreateManyUserInputEnvelope
    set?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    disconnect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    delete?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    update?: TransactionsMasterUpdateWithWhereUniqueWithoutUserInput | TransactionsMasterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionsMasterUpdateManyWithWhereWithoutUserInput | TransactionsMasterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type TransactionsMasterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutUserInput, TransactionsMasterUncheckedCreateWithoutUserInput> | TransactionsMasterCreateWithoutUserInput[] | TransactionsMasterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutUserInput | TransactionsMasterCreateOrConnectWithoutUserInput[]
    upsert?: TransactionsMasterUpsertWithWhereUniqueWithoutUserInput | TransactionsMasterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionsMasterCreateManyUserInputEnvelope
    set?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    disconnect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    delete?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    connect?: TransactionsMasterWhereUniqueInput | TransactionsMasterWhereUniqueInput[]
    update?: TransactionsMasterUpdateWithWhereUniqueWithoutUserInput | TransactionsMasterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionsMasterUpdateManyWithWhereWithoutUserInput | TransactionsMasterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
  }

  export type TransactionsCreateNestedManyWithoutCurrencyDetailsInput = {
    create?: XOR<TransactionsCreateWithoutCurrencyDetailsInput, TransactionsUncheckedCreateWithoutCurrencyDetailsInput> | TransactionsCreateWithoutCurrencyDetailsInput[] | TransactionsUncheckedCreateWithoutCurrencyDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutCurrencyDetailsInput | TransactionsCreateOrConnectWithoutCurrencyDetailsInput[]
    createMany?: TransactionsCreateManyCurrencyDetailsInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutCurrencyDetailsInput = {
    create?: XOR<TransactionsCreateWithoutCurrencyDetailsInput, TransactionsUncheckedCreateWithoutCurrencyDetailsInput> | TransactionsCreateWithoutCurrencyDetailsInput[] | TransactionsUncheckedCreateWithoutCurrencyDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutCurrencyDetailsInput | TransactionsCreateOrConnectWithoutCurrencyDetailsInput[]
    createMany?: TransactionsCreateManyCurrencyDetailsInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type TransactionsUpdateManyWithoutCurrencyDetailsNestedInput = {
    create?: XOR<TransactionsCreateWithoutCurrencyDetailsInput, TransactionsUncheckedCreateWithoutCurrencyDetailsInput> | TransactionsCreateWithoutCurrencyDetailsInput[] | TransactionsUncheckedCreateWithoutCurrencyDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutCurrencyDetailsInput | TransactionsCreateOrConnectWithoutCurrencyDetailsInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutCurrencyDetailsInput | TransactionsUpsertWithWhereUniqueWithoutCurrencyDetailsInput[]
    createMany?: TransactionsCreateManyCurrencyDetailsInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutCurrencyDetailsInput | TransactionsUpdateWithWhereUniqueWithoutCurrencyDetailsInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutCurrencyDetailsInput | TransactionsUpdateManyWithWhereWithoutCurrencyDetailsInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutCurrencyDetailsNestedInput = {
    create?: XOR<TransactionsCreateWithoutCurrencyDetailsInput, TransactionsUncheckedCreateWithoutCurrencyDetailsInput> | TransactionsCreateWithoutCurrencyDetailsInput[] | TransactionsUncheckedCreateWithoutCurrencyDetailsInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutCurrencyDetailsInput | TransactionsCreateOrConnectWithoutCurrencyDetailsInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutCurrencyDetailsInput | TransactionsUpsertWithWhereUniqueWithoutCurrencyDetailsInput[]
    createMany?: TransactionsCreateManyCurrencyDetailsInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutCurrencyDetailsInput | TransactionsUpdateWithWhereUniqueWithoutCurrencyDetailsInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutCurrencyDetailsInput | TransactionsUpdateManyWithWhereWithoutCurrencyDetailsInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutTransactionsMasterInput = {
    create?: XOR<UsersCreateWithoutTransactionsMasterInput, UsersUncheckedCreateWithoutTransactionsMasterInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTransactionsMasterInput
    connect?: UsersWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTransactionsMasterInput = {
    create?: XOR<CompanyCreateWithoutTransactionsMasterInput, CompanyUncheckedCreateWithoutTransactionsMasterInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransactionsMasterInput
    connect?: CompanyWhereUniqueInput
  }

  export type GodownCreateNestedOneWithoutTransactionsMasterInput = {
    create?: XOR<GodownCreateWithoutTransactionsMasterInput, GodownUncheckedCreateWithoutTransactionsMasterInput>
    connectOrCreate?: GodownCreateOrConnectWithoutTransactionsMasterInput
    connect?: GodownWhereUniqueInput
  }

  export type ACNOCreateNestedOneWithoutTransactionsMasterInput = {
    create?: XOR<ACNOCreateWithoutTransactionsMasterInput, ACNOUncheckedCreateWithoutTransactionsMasterInput>
    connectOrCreate?: ACNOCreateOrConnectWithoutTransactionsMasterInput
    connect?: ACNOWhereUniqueInput
  }

  export type TransactionsCreateNestedManyWithoutTransactionsMasterInput = {
    create?: XOR<TransactionsCreateWithoutTransactionsMasterInput, TransactionsUncheckedCreateWithoutTransactionsMasterInput> | TransactionsCreateWithoutTransactionsMasterInput[] | TransactionsUncheckedCreateWithoutTransactionsMasterInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutTransactionsMasterInput | TransactionsCreateOrConnectWithoutTransactionsMasterInput[]
    createMany?: TransactionsCreateManyTransactionsMasterInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutTransactionsMasterInput = {
    create?: XOR<TransactionsCreateWithoutTransactionsMasterInput, TransactionsUncheckedCreateWithoutTransactionsMasterInput> | TransactionsCreateWithoutTransactionsMasterInput[] | TransactionsUncheckedCreateWithoutTransactionsMasterInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutTransactionsMasterInput | TransactionsCreateOrConnectWithoutTransactionsMasterInput[]
    createMany?: TransactionsCreateManyTransactionsMasterInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type UsersUpdateOneWithoutTransactionsMasterNestedInput = {
    create?: XOR<UsersCreateWithoutTransactionsMasterInput, UsersUncheckedCreateWithoutTransactionsMasterInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTransactionsMasterInput
    upsert?: UsersUpsertWithoutTransactionsMasterInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutTransactionsMasterInput, UsersUpdateWithoutTransactionsMasterInput>, UsersUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type CompanyUpdateOneWithoutTransactionsMasterNestedInput = {
    create?: XOR<CompanyCreateWithoutTransactionsMasterInput, CompanyUncheckedCreateWithoutTransactionsMasterInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransactionsMasterInput
    upsert?: CompanyUpsertWithoutTransactionsMasterInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTransactionsMasterInput, CompanyUpdateWithoutTransactionsMasterInput>, CompanyUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type GodownUpdateOneWithoutTransactionsMasterNestedInput = {
    create?: XOR<GodownCreateWithoutTransactionsMasterInput, GodownUncheckedCreateWithoutTransactionsMasterInput>
    connectOrCreate?: GodownCreateOrConnectWithoutTransactionsMasterInput
    upsert?: GodownUpsertWithoutTransactionsMasterInput
    disconnect?: GodownWhereInput | boolean
    delete?: GodownWhereInput | boolean
    connect?: GodownWhereUniqueInput
    update?: XOR<XOR<GodownUpdateToOneWithWhereWithoutTransactionsMasterInput, GodownUpdateWithoutTransactionsMasterInput>, GodownUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type ACNOUpdateOneWithoutTransactionsMasterNestedInput = {
    create?: XOR<ACNOCreateWithoutTransactionsMasterInput, ACNOUncheckedCreateWithoutTransactionsMasterInput>
    connectOrCreate?: ACNOCreateOrConnectWithoutTransactionsMasterInput
    upsert?: ACNOUpsertWithoutTransactionsMasterInput
    disconnect?: ACNOWhereInput | boolean
    delete?: ACNOWhereInput | boolean
    connect?: ACNOWhereUniqueInput
    update?: XOR<XOR<ACNOUpdateToOneWithWhereWithoutTransactionsMasterInput, ACNOUpdateWithoutTransactionsMasterInput>, ACNOUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type TransactionsUpdateManyWithoutTransactionsMasterNestedInput = {
    create?: XOR<TransactionsCreateWithoutTransactionsMasterInput, TransactionsUncheckedCreateWithoutTransactionsMasterInput> | TransactionsCreateWithoutTransactionsMasterInput[] | TransactionsUncheckedCreateWithoutTransactionsMasterInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutTransactionsMasterInput | TransactionsCreateOrConnectWithoutTransactionsMasterInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutTransactionsMasterInput | TransactionsUpsertWithWhereUniqueWithoutTransactionsMasterInput[]
    createMany?: TransactionsCreateManyTransactionsMasterInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutTransactionsMasterInput | TransactionsUpdateWithWhereUniqueWithoutTransactionsMasterInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutTransactionsMasterInput | TransactionsUpdateManyWithWhereWithoutTransactionsMasterInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutTransactionsMasterNestedInput = {
    create?: XOR<TransactionsCreateWithoutTransactionsMasterInput, TransactionsUncheckedCreateWithoutTransactionsMasterInput> | TransactionsCreateWithoutTransactionsMasterInput[] | TransactionsUncheckedCreateWithoutTransactionsMasterInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutTransactionsMasterInput | TransactionsCreateOrConnectWithoutTransactionsMasterInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutTransactionsMasterInput | TransactionsUpsertWithWhereUniqueWithoutTransactionsMasterInput[]
    createMany?: TransactionsCreateManyTransactionsMasterInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutTransactionsMasterInput | TransactionsUpdateWithWhereUniqueWithoutTransactionsMasterInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutTransactionsMasterInput | TransactionsUpdateManyWithWhereWithoutTransactionsMasterInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type ACNOCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ACNOCreateWithoutTransactionsInput, ACNOUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ACNOCreateOrConnectWithoutTransactionsInput
    connect?: ACNOWhereUniqueInput
  }

  export type CostCenterCreateNestedOneWithoutTransactionInput = {
    create?: XOR<CostCenterCreateWithoutTransactionInput, CostCenterUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CostCenterCreateOrConnectWithoutTransactionInput
    connect?: CostCenterWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CurrencyCreateWithoutTransactionsInput, CurrencyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutTransactionsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type GodownCreateNestedOneWithoutTransactionInput = {
    create?: XOR<GodownCreateWithoutTransactionInput, GodownUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: GodownCreateOrConnectWithoutTransactionInput
    connect?: GodownWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ItemCreateWithoutTransactionsInput, ItemUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutTransactionsInput
    connect?: ItemWhereUniqueInput
  }

  export type TransactionsMasterCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TransactionsMasterCreateWithoutTransactionsInput, TransactionsMasterUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutTransactionsInput
    connect?: TransactionsMasterWhereUniqueInput
  }

  export type ACNOUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ACNOCreateWithoutTransactionsInput, ACNOUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ACNOCreateOrConnectWithoutTransactionsInput
    upsert?: ACNOUpsertWithoutTransactionsInput
    disconnect?: ACNOWhereInput | boolean
    delete?: ACNOWhereInput | boolean
    connect?: ACNOWhereUniqueInput
    update?: XOR<XOR<ACNOUpdateToOneWithWhereWithoutTransactionsInput, ACNOUpdateWithoutTransactionsInput>, ACNOUncheckedUpdateWithoutTransactionsInput>
  }

  export type CostCenterUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<CostCenterCreateWithoutTransactionInput, CostCenterUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CostCenterCreateOrConnectWithoutTransactionInput
    upsert?: CostCenterUpsertWithoutTransactionInput
    disconnect?: CostCenterWhereInput | boolean
    delete?: CostCenterWhereInput | boolean
    connect?: CostCenterWhereUniqueInput
    update?: XOR<XOR<CostCenterUpdateToOneWithWhereWithoutTransactionInput, CostCenterUpdateWithoutTransactionInput>, CostCenterUncheckedUpdateWithoutTransactionInput>
  }

  export type CurrencyUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CurrencyCreateWithoutTransactionsInput, CurrencyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutTransactionsInput
    upsert?: CurrencyUpsertWithoutTransactionsInput
    disconnect?: CurrencyWhereInput | boolean
    delete?: CurrencyWhereInput | boolean
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutTransactionsInput, CurrencyUpdateWithoutTransactionsInput>, CurrencyUncheckedUpdateWithoutTransactionsInput>
  }

  export type GodownUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<GodownCreateWithoutTransactionInput, GodownUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: GodownCreateOrConnectWithoutTransactionInput
    upsert?: GodownUpsertWithoutTransactionInput
    disconnect?: GodownWhereInput | boolean
    delete?: GodownWhereInput | boolean
    connect?: GodownWhereUniqueInput
    update?: XOR<XOR<GodownUpdateToOneWithWhereWithoutTransactionInput, GodownUpdateWithoutTransactionInput>, GodownUncheckedUpdateWithoutTransactionInput>
  }

  export type ItemUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ItemCreateWithoutTransactionsInput, ItemUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutTransactionsInput
    upsert?: ItemUpsertWithoutTransactionsInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutTransactionsInput, ItemUpdateWithoutTransactionsInput>, ItemUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionsMasterUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<TransactionsMasterCreateWithoutTransactionsInput, TransactionsMasterUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TransactionsMasterCreateOrConnectWithoutTransactionsInput
    upsert?: TransactionsMasterUpsertWithoutTransactionsInput
    connect?: TransactionsMasterWhereUniqueInput
    update?: XOR<XOR<TransactionsMasterUpdateToOneWithWhereWithoutTransactionsInput, TransactionsMasterUpdateWithoutTransactionsInput>, TransactionsMasterUncheckedUpdateWithoutTransactionsInput>
  }

  export type CompanyCreateNestedOneWithoutDeliveryTermsInput = {
    create?: XOR<CompanyCreateWithoutDeliveryTermsInput, CompanyUncheckedCreateWithoutDeliveryTermsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDeliveryTermsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutDeliveryTermsNestedInput = {
    create?: XOR<CompanyCreateWithoutDeliveryTermsInput, CompanyUncheckedCreateWithoutDeliveryTermsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDeliveryTermsInput
    upsert?: CompanyUpsertWithoutDeliveryTermsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDeliveryTermsInput, CompanyUpdateWithoutDeliveryTermsInput>, CompanyUncheckedUpdateWithoutDeliveryTermsInput>
  }

  export type CompanyCreateNestedOneWithoutCommissionTermsInput = {
    create?: XOR<CompanyCreateWithoutCommissionTermsInput, CompanyUncheckedCreateWithoutCommissionTermsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCommissionTermsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCommissionTermsNestedInput = {
    create?: XOR<CompanyCreateWithoutCommissionTermsInput, CompanyUncheckedCreateWithoutCommissionTermsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCommissionTermsInput
    upsert?: CompanyUpsertWithoutCommissionTermsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCommissionTermsInput, CompanyUpdateWithoutCommissionTermsInput>, CompanyUncheckedUpdateWithoutCommissionTermsInput>
  }

  export type ManagerCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ManagerCreateWithoutEmployeesInput, ManagerUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutEmployeesInput
    connect?: ManagerWhereUniqueInput
  }

  export type EmployerCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<EmployerCreateWithoutEmployeesInput, EmployerUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmployerCreateOrConnectWithoutEmployeesInput
    connect?: EmployerWhereUniqueInput
  }

  export type LeaveCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput> | DocumentCreateWithoutEmployeeInput[] | DocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmployeeInput | DocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEmployeesInput
    connect?: CompanyWhereUniqueInput
  }

  export type LeaveUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput> | DocumentCreateWithoutEmployeeInput[] | DocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmployeeInput | DocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableEnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status | null
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type NullableEnumPayTypeFieldUpdateOperationsInput = {
    set?: $Enums.PayType | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumPayFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.PayFrequency | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ManagerUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<ManagerCreateWithoutEmployeesInput, ManagerUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutEmployeesInput
    upsert?: ManagerUpsertWithoutEmployeesInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutEmployeesInput, ManagerUpdateWithoutEmployeesInput>, ManagerUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployerUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<EmployerCreateWithoutEmployeesInput, EmployerUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmployerCreateOrConnectWithoutEmployeesInput
    upsert?: EmployerUpsertWithoutEmployeesInput
    connect?: EmployerWhereUniqueInput
    update?: XOR<XOR<EmployerUpdateToOneWithWhereWithoutEmployeesInput, EmployerUpdateWithoutEmployeesInput>, EmployerUncheckedUpdateWithoutEmployeesInput>
  }

  export type LeaveUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput> | DocumentCreateWithoutEmployeeInput[] | DocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmployeeInput | DocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutEmployeeInput | DocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutEmployeeInput | DocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutEmployeeInput | DocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEmployeesInput
    upsert?: CompanyUpsertWithoutEmployeesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutEmployeesInput, CompanyUpdateWithoutEmployeesInput>, CompanyUncheckedUpdateWithoutEmployeesInput>
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput> | DocumentCreateWithoutEmployeeInput[] | DocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmployeeInput | DocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutEmployeeInput | DocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutEmployeeInput | DocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutEmployeeInput | DocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutLeavesInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    upsert?: EmployeeUpsertWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeavesInput, EmployeeUpdateWithoutLeavesInput>, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    upsert?: EmployeeUpsertWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDocumentsInput, EmployeeUpdateWithoutDocumentsInput>, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmployeeCreateNestedManyWithoutManagerInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutManagerNestedInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutManagerInput | EmployeeUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutManagerInput | EmployeeUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutManagerInput | EmployeeUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutManagerInput | EmployeeUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutManagerInput | EmployeeUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutManagerInput | EmployeeUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutEmployerInput = {
    create?: XOR<EmployeeCreateWithoutEmployerInput, EmployeeUncheckedCreateWithoutEmployerInput> | EmployeeCreateWithoutEmployerInput[] | EmployeeUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployerInput | EmployeeCreateOrConnectWithoutEmployerInput[]
    createMany?: EmployeeCreateManyEmployerInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutEmployerInput = {
    create?: XOR<EmployeeCreateWithoutEmployerInput, EmployeeUncheckedCreateWithoutEmployerInput> | EmployeeCreateWithoutEmployerInput[] | EmployeeUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployerInput | EmployeeCreateOrConnectWithoutEmployerInput[]
    createMany?: EmployeeCreateManyEmployerInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutEmployerNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployerInput, EmployeeUncheckedCreateWithoutEmployerInput> | EmployeeCreateWithoutEmployerInput[] | EmployeeUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployerInput | EmployeeCreateOrConnectWithoutEmployerInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutEmployerInput | EmployeeUpsertWithWhereUniqueWithoutEmployerInput[]
    createMany?: EmployeeCreateManyEmployerInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutEmployerInput | EmployeeUpdateWithWhereUniqueWithoutEmployerInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutEmployerInput | EmployeeUpdateManyWithWhereWithoutEmployerInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutEmployerNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployerInput, EmployeeUncheckedCreateWithoutEmployerInput> | EmployeeCreateWithoutEmployerInput[] | EmployeeUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployerInput | EmployeeCreateOrConnectWithoutEmployerInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutEmployerInput | EmployeeUpsertWithWhereUniqueWithoutEmployerInput[]
    createMany?: EmployeeCreateManyEmployerInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutEmployerInput | EmployeeUpdateWithWhereUniqueWithoutEmployerInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutEmployerInput | EmployeeUpdateManyWithWhereWithoutEmployerInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableFilter<$PrismaModel> | $Enums.Status | null
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumPayTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PayType | EnumPayTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PayType[] | ListEnumPayTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PayType[] | ListEnumPayTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPayTypeNullableFilter<$PrismaModel> | $Enums.PayType | null
  }

  export type NestedEnumPayFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PayFrequency | EnumPayFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.PayFrequency[] | ListEnumPayFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PayFrequency[] | ListEnumPayFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPayFrequencyNullableFilter<$PrismaModel> | $Enums.PayFrequency | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumPayTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayType | EnumPayTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PayType[] | ListEnumPayTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PayType[] | ListEnumPayTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPayTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PayType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPayTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPayTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPayFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayFrequency | EnumPayFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.PayFrequency[] | ListEnumPayFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PayFrequency[] | ListEnumPayFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPayFrequencyNullableWithAggregatesFilter<$PrismaModel> | $Enums.PayFrequency | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPayFrequencyNullableFilter<$PrismaModel>
    _max?: NestedEnumPayFrequencyNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BSCDCreateWithoutMainBscdInput = {
    bscd: string
    bscdDetail: string
    macnoItems?: MACNOCreateNestedManyWithoutBscdRefInput
  }

  export type BSCDUncheckedCreateWithoutMainBscdInput = {
    bscd: string
    bscdDetail: string
    macnoItems?: MACNOUncheckedCreateNestedManyWithoutBscdRefInput
  }

  export type BSCDCreateOrConnectWithoutMainBscdInput = {
    where: BSCDWhereUniqueInput
    create: XOR<BSCDCreateWithoutMainBscdInput, BSCDUncheckedCreateWithoutMainBscdInput>
  }

  export type BSCDCreateManyMainBscdInputEnvelope = {
    data: BSCDCreateManyMainBscdInput | BSCDCreateManyMainBscdInput[]
    skipDuplicates?: boolean
  }

  export type BSCDUpsertWithWhereUniqueWithoutMainBscdInput = {
    where: BSCDWhereUniqueInput
    update: XOR<BSCDUpdateWithoutMainBscdInput, BSCDUncheckedUpdateWithoutMainBscdInput>
    create: XOR<BSCDCreateWithoutMainBscdInput, BSCDUncheckedCreateWithoutMainBscdInput>
  }

  export type BSCDUpdateWithWhereUniqueWithoutMainBscdInput = {
    where: BSCDWhereUniqueInput
    data: XOR<BSCDUpdateWithoutMainBscdInput, BSCDUncheckedUpdateWithoutMainBscdInput>
  }

  export type BSCDUpdateManyWithWhereWithoutMainBscdInput = {
    where: BSCDScalarWhereInput
    data: XOR<BSCDUpdateManyMutationInput, BSCDUncheckedUpdateManyWithoutMainBscdInput>
  }

  export type BSCDScalarWhereInput = {
    AND?: BSCDScalarWhereInput | BSCDScalarWhereInput[]
    OR?: BSCDScalarWhereInput[]
    NOT?: BSCDScalarWhereInput | BSCDScalarWhereInput[]
    bscd?: StringFilter<"BSCD"> | string
    mbscd?: StringFilter<"BSCD"> | string
    bscdDetail?: StringFilter<"BSCD"> | string
  }

  export type MBSCDCreateWithoutBscdItemsInput = {
    bscd: string
    bscdDetail: string
  }

  export type MBSCDUncheckedCreateWithoutBscdItemsInput = {
    bscd: string
    bscdDetail: string
  }

  export type MBSCDCreateOrConnectWithoutBscdItemsInput = {
    where: MBSCDWhereUniqueInput
    create: XOR<MBSCDCreateWithoutBscdItemsInput, MBSCDUncheckedCreateWithoutBscdItemsInput>
  }

  export type MACNOCreateWithoutBscdRefInput = {
    macno: string
    macname: string
    accounts?: ACNOCreateNestedManyWithoutMainAccountInput
  }

  export type MACNOUncheckedCreateWithoutBscdRefInput = {
    macno: string
    macname: string
    accounts?: ACNOUncheckedCreateNestedManyWithoutMainAccountInput
  }

  export type MACNOCreateOrConnectWithoutBscdRefInput = {
    where: MACNOWhereUniqueInput
    create: XOR<MACNOCreateWithoutBscdRefInput, MACNOUncheckedCreateWithoutBscdRefInput>
  }

  export type MACNOCreateManyBscdRefInputEnvelope = {
    data: MACNOCreateManyBscdRefInput | MACNOCreateManyBscdRefInput[]
    skipDuplicates?: boolean
  }

  export type MBSCDUpsertWithoutBscdItemsInput = {
    update: XOR<MBSCDUpdateWithoutBscdItemsInput, MBSCDUncheckedUpdateWithoutBscdItemsInput>
    create: XOR<MBSCDCreateWithoutBscdItemsInput, MBSCDUncheckedCreateWithoutBscdItemsInput>
    where?: MBSCDWhereInput
  }

  export type MBSCDUpdateToOneWithWhereWithoutBscdItemsInput = {
    where?: MBSCDWhereInput
    data: XOR<MBSCDUpdateWithoutBscdItemsInput, MBSCDUncheckedUpdateWithoutBscdItemsInput>
  }

  export type MBSCDUpdateWithoutBscdItemsInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
  }

  export type MBSCDUncheckedUpdateWithoutBscdItemsInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
  }

  export type MACNOUpsertWithWhereUniqueWithoutBscdRefInput = {
    where: MACNOWhereUniqueInput
    update: XOR<MACNOUpdateWithoutBscdRefInput, MACNOUncheckedUpdateWithoutBscdRefInput>
    create: XOR<MACNOCreateWithoutBscdRefInput, MACNOUncheckedCreateWithoutBscdRefInput>
  }

  export type MACNOUpdateWithWhereUniqueWithoutBscdRefInput = {
    where: MACNOWhereUniqueInput
    data: XOR<MACNOUpdateWithoutBscdRefInput, MACNOUncheckedUpdateWithoutBscdRefInput>
  }

  export type MACNOUpdateManyWithWhereWithoutBscdRefInput = {
    where: MACNOScalarWhereInput
    data: XOR<MACNOUpdateManyMutationInput, MACNOUncheckedUpdateManyWithoutBscdRefInput>
  }

  export type MACNOScalarWhereInput = {
    AND?: MACNOScalarWhereInput | MACNOScalarWhereInput[]
    OR?: MACNOScalarWhereInput[]
    NOT?: MACNOScalarWhereInput | MACNOScalarWhereInput[]
    macno?: StringFilter<"MACNO"> | string
    bscd?: StringFilter<"MACNO"> | string
    macname?: StringFilter<"MACNO"> | string
  }

  export type BSCDCreateWithoutMacnoItemsInput = {
    bscd: string
    bscdDetail: string
    mainBscd: MBSCDCreateNestedOneWithoutBscdItemsInput
  }

  export type BSCDUncheckedCreateWithoutMacnoItemsInput = {
    bscd: string
    mbscd: string
    bscdDetail: string
  }

  export type BSCDCreateOrConnectWithoutMacnoItemsInput = {
    where: BSCDWhereUniqueInput
    create: XOR<BSCDCreateWithoutMacnoItemsInput, BSCDUncheckedCreateWithoutMacnoItemsInput>
  }

  export type ACNOCreateWithoutMainAccountInput = {
    acno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
    transactionsMaster?: TransactionsMasterCreateNestedManyWithoutAcnoInput
    transactions?: TransactionsCreateNestedManyWithoutAcnoDetailsInput
  }

  export type ACNOUncheckedCreateWithoutMainAccountInput = {
    acno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
    transactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutAcnoInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAcnoDetailsInput
  }

  export type ACNOCreateOrConnectWithoutMainAccountInput = {
    where: ACNOWhereUniqueInput
    create: XOR<ACNOCreateWithoutMainAccountInput, ACNOUncheckedCreateWithoutMainAccountInput>
  }

  export type ACNOCreateManyMainAccountInputEnvelope = {
    data: ACNOCreateManyMainAccountInput | ACNOCreateManyMainAccountInput[]
    skipDuplicates?: boolean
  }

  export type BSCDUpsertWithoutMacnoItemsInput = {
    update: XOR<BSCDUpdateWithoutMacnoItemsInput, BSCDUncheckedUpdateWithoutMacnoItemsInput>
    create: XOR<BSCDCreateWithoutMacnoItemsInput, BSCDUncheckedCreateWithoutMacnoItemsInput>
    where?: BSCDWhereInput
  }

  export type BSCDUpdateToOneWithWhereWithoutMacnoItemsInput = {
    where?: BSCDWhereInput
    data: XOR<BSCDUpdateWithoutMacnoItemsInput, BSCDUncheckedUpdateWithoutMacnoItemsInput>
  }

  export type BSCDUpdateWithoutMacnoItemsInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
    mainBscd?: MBSCDUpdateOneRequiredWithoutBscdItemsNestedInput
  }

  export type BSCDUncheckedUpdateWithoutMacnoItemsInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    mbscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
  }

  export type ACNOUpsertWithWhereUniqueWithoutMainAccountInput = {
    where: ACNOWhereUniqueInput
    update: XOR<ACNOUpdateWithoutMainAccountInput, ACNOUncheckedUpdateWithoutMainAccountInput>
    create: XOR<ACNOCreateWithoutMainAccountInput, ACNOUncheckedCreateWithoutMainAccountInput>
  }

  export type ACNOUpdateWithWhereUniqueWithoutMainAccountInput = {
    where: ACNOWhereUniqueInput
    data: XOR<ACNOUpdateWithoutMainAccountInput, ACNOUncheckedUpdateWithoutMainAccountInput>
  }

  export type ACNOUpdateManyWithWhereWithoutMainAccountInput = {
    where: ACNOScalarWhereInput
    data: XOR<ACNOUpdateManyMutationInput, ACNOUncheckedUpdateManyWithoutMainAccountInput>
  }

  export type ACNOScalarWhereInput = {
    AND?: ACNOScalarWhereInput | ACNOScalarWhereInput[]
    OR?: ACNOScalarWhereInput[]
    NOT?: ACNOScalarWhereInput | ACNOScalarWhereInput[]
    acno?: StringFilter<"ACNO"> | string
    macno?: StringFilter<"ACNO"> | string
    acname?: StringFilter<"ACNO"> | string
    bankAccountNo?: StringNullableFilter<"ACNO"> | string | null
    address?: StringNullableFilter<"ACNO"> | string | null
    city?: StringNullableFilter<"ACNO"> | string | null
    phoneFax?: StringNullableFilter<"ACNO"> | string | null
    email?: StringNullableFilter<"ACNO"> | string | null
    website?: StringNullableFilter<"ACNO"> | string | null
    crDays?: IntNullableFilter<"ACNO"> | number | null
    stRate?: DecimalNullableFilter<"ACNO"> | Decimal | DecimalJsLike | number | string | null
    area?: StringNullableFilter<"ACNO"> | string | null
    category?: StringNullableFilter<"ACNO"> | string | null
    subCategory?: StringNullableFilter<"ACNO"> | string | null
    country?: StringNullableFilter<"ACNO"> | string | null
    customerBank?: StringNullableFilter<"ACNO"> | string | null
    customerBankAddr?: StringNullableFilter<"ACNO"> | string | null
    stRegNo?: StringNullableFilter<"ACNO"> | string | null
    ntnNo?: StringNullableFilter<"ACNO"> | string | null
    contactPerson?: StringNullableFilter<"ACNO"> | string | null
    crLimit?: IntNullableFilter<"ACNO"> | number | null
    salesArea?: StringNullableFilter<"ACNO"> | string | null
  }

  export type TransactionsMasterCreateWithoutAcnoInput = {
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    invoice_no?: string | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    user?: UsersCreateNestedOneWithoutTransactionsMasterInput
    company?: CompanyCreateNestedOneWithoutTransactionsMasterInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionsMasterInput
    transactions?: TransactionsCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterUncheckedCreateWithoutAcnoInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    transactions?: TransactionsUncheckedCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterCreateOrConnectWithoutAcnoInput = {
    where: TransactionsMasterWhereUniqueInput
    create: XOR<TransactionsMasterCreateWithoutAcnoInput, TransactionsMasterUncheckedCreateWithoutAcnoInput>
  }

  export type TransactionsMasterCreateManyAcnoInputEnvelope = {
    data: TransactionsMasterCreateManyAcnoInput | TransactionsMasterCreateManyAcnoInput[]
    skipDuplicates?: boolean
  }

  export type TransactionsCreateWithoutAcnoDetailsInput = {
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
    costCenter?: CostCenterCreateNestedOneWithoutTransactionInput
    currencyDetails?: CurrencyCreateNestedOneWithoutTransactionsInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionInput
    itemDetails?: ItemCreateNestedOneWithoutTransactionsInput
    transactionsMaster: TransactionsMasterCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutAcnoDetailsInput = {
    id?: number
    tran_id: number
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsCreateOrConnectWithoutAcnoDetailsInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutAcnoDetailsInput, TransactionsUncheckedCreateWithoutAcnoDetailsInput>
  }

  export type TransactionsCreateManyAcnoDetailsInputEnvelope = {
    data: TransactionsCreateManyAcnoDetailsInput | TransactionsCreateManyAcnoDetailsInput[]
    skipDuplicates?: boolean
  }

  export type MACNOCreateWithoutAccountsInput = {
    macno: string
    macname: string
    bscdRef: BSCDCreateNestedOneWithoutMacnoItemsInput
  }

  export type MACNOUncheckedCreateWithoutAccountsInput = {
    macno: string
    bscd: string
    macname: string
  }

  export type MACNOCreateOrConnectWithoutAccountsInput = {
    where: MACNOWhereUniqueInput
    create: XOR<MACNOCreateWithoutAccountsInput, MACNOUncheckedCreateWithoutAccountsInput>
  }

  export type TransactionsMasterUpsertWithWhereUniqueWithoutAcnoInput = {
    where: TransactionsMasterWhereUniqueInput
    update: XOR<TransactionsMasterUpdateWithoutAcnoInput, TransactionsMasterUncheckedUpdateWithoutAcnoInput>
    create: XOR<TransactionsMasterCreateWithoutAcnoInput, TransactionsMasterUncheckedCreateWithoutAcnoInput>
  }

  export type TransactionsMasterUpdateWithWhereUniqueWithoutAcnoInput = {
    where: TransactionsMasterWhereUniqueInput
    data: XOR<TransactionsMasterUpdateWithoutAcnoInput, TransactionsMasterUncheckedUpdateWithoutAcnoInput>
  }

  export type TransactionsMasterUpdateManyWithWhereWithoutAcnoInput = {
    where: TransactionsMasterScalarWhereInput
    data: XOR<TransactionsMasterUpdateManyMutationInput, TransactionsMasterUncheckedUpdateManyWithoutAcnoInput>
  }

  export type TransactionsMasterScalarWhereInput = {
    AND?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
    OR?: TransactionsMasterScalarWhereInput[]
    NOT?: TransactionsMasterScalarWhereInput | TransactionsMasterScalarWhereInput[]
    tran_id?: IntFilter<"TransactionsMaster"> | number
    company_id?: IntNullableFilter<"TransactionsMaster"> | number | null
    dateD?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    time?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    tran_code?: IntNullableFilter<"TransactionsMaster"> | number | null
    vr_no?: IntNullableFilter<"TransactionsMaster"> | number | null
    pycd?: StringNullableFilter<"TransactionsMaster"> | string | null
    check_no?: StringNullableFilter<"TransactionsMaster"> | string | null
    check_date?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
    rmk?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk1?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk2?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk3?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk4?: StringNullableFilter<"TransactionsMaster"> | string | null
    rmk5?: StringNullableFilter<"TransactionsMaster"> | string | null
    userId?: StringNullableFilter<"TransactionsMaster"> | string | null
    invoice_no?: StringNullableFilter<"TransactionsMaster"> | string | null
    godown?: IntNullableFilter<"TransactionsMaster"> | number | null
    wc_order_id?: IntNullableFilter<"TransactionsMaster"> | number | null
    sync_status?: StringNullableFilter<"TransactionsMaster"> | string | null
    last_sync?: DateTimeNullableFilter<"TransactionsMaster"> | Date | string | null
  }

  export type TransactionsUpsertWithWhereUniqueWithoutAcnoDetailsInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutAcnoDetailsInput, TransactionsUncheckedUpdateWithoutAcnoDetailsInput>
    create: XOR<TransactionsCreateWithoutAcnoDetailsInput, TransactionsUncheckedCreateWithoutAcnoDetailsInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutAcnoDetailsInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutAcnoDetailsInput, TransactionsUncheckedUpdateWithoutAcnoDetailsInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutAcnoDetailsInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutAcnoDetailsInput>
  }

  export type TransactionsScalarWhereInput = {
    AND?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    OR?: TransactionsScalarWhereInput[]
    NOT?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    id?: IntFilter<"Transactions"> | number
    tran_id?: IntFilter<"Transactions"> | number
    acno?: StringNullableFilter<"Transactions"> | string | null
    itcd?: IntNullableFilter<"Transactions"> | number | null
    ccno?: IntNullableFilter<"Transactions"> | number | null
    narration1?: StringNullableFilter<"Transactions"> | string | null
    narration2?: StringNullableFilter<"Transactions"> | string | null
    narration3?: StringNullableFilter<"Transactions"> | string | null
    narration4?: StringNullableFilter<"Transactions"> | string | null
    narration5?: StringNullableFilter<"Transactions"> | string | null
    chno?: StringNullableFilter<"Transactions"> | string | null
    check_date?: DateTimeNullableFilter<"Transactions"> | Date | string | null
    party_name?: StringNullableFilter<"Transactions"> | string | null
    damt?: FloatNullableFilter<"Transactions"> | number | null
    camt?: FloatNullableFilter<"Transactions"> | number | null
    qty?: FloatNullableFilter<"Transactions"> | number | null
    rate?: FloatNullableFilter<"Transactions"> | number | null
    wht_rate?: FloatNullableFilter<"Transactions"> | number | null
    st_rate?: FloatNullableFilter<"Transactions"> | number | null
    godown?: IntNullableFilter<"Transactions"> | number | null
    invoice_no?: StringNullableFilter<"Transactions"> | string | null
    sub_tran_id?: IntNullableFilter<"Transactions"> | number | null
    currency?: IntNullableFilter<"Transactions"> | number | null
    gross_amount?: FloatNullableFilter<"Transactions"> | number | null
    fc_amount?: FloatNullableFilter<"Transactions"> | number | null
    no_of_pack?: FloatNullableFilter<"Transactions"> | number | null
    qty_per_pack?: FloatNullableFilter<"Transactions"> | number | null
    st_amount?: FloatNullableFilter<"Transactions"> | number | null
    additional_tax?: FloatNullableFilter<"Transactions"> | number | null
  }

  export type MACNOUpsertWithoutAccountsInput = {
    update: XOR<MACNOUpdateWithoutAccountsInput, MACNOUncheckedUpdateWithoutAccountsInput>
    create: XOR<MACNOCreateWithoutAccountsInput, MACNOUncheckedCreateWithoutAccountsInput>
    where?: MACNOWhereInput
  }

  export type MACNOUpdateToOneWithWhereWithoutAccountsInput = {
    where?: MACNOWhereInput
    data: XOR<MACNOUpdateWithoutAccountsInput, MACNOUncheckedUpdateWithoutAccountsInput>
  }

  export type MACNOUpdateWithoutAccountsInput = {
    macno?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
    bscdRef?: BSCDUpdateOneRequiredWithoutMacnoItemsNestedInput
  }

  export type MACNOUncheckedUpdateWithoutAccountsInput = {
    macno?: StringFieldUpdateOperationsInput | string
    bscd?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
  }

  export type CostCenterCreateWithoutCompanyInput = {
    ccname?: string | null
    Transaction?: TransactionsCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterUncheckedCreateWithoutCompanyInput = {
    ccno?: number
    ccname?: string | null
    Transaction?: TransactionsUncheckedCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterCreateOrConnectWithoutCompanyInput = {
    where: CostCenterWhereUniqueInput
    create: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput>
  }

  export type CostCenterCreateManyCompanyInputEnvelope = {
    data: CostCenterCreateManyCompanyInput | CostCenterCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutCompanyInput = {
    dept_name?: string | null
  }

  export type DepartmentUncheckedCreateWithoutCompanyInput = {
    id?: number
    dept_name?: string | null
  }

  export type DepartmentCreateOrConnectWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput>
  }

  export type DepartmentCreateManyCompanyInputEnvelope = {
    data: DepartmentCreateManyCompanyInput | DepartmentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DesignationCreateWithoutCompanyInput = {
    desg_name?: string | null
  }

  export type DesignationUncheckedCreateWithoutCompanyInput = {
    id?: number
    desg_name?: string | null
  }

  export type DesignationCreateOrConnectWithoutCompanyInput = {
    where: DesignationWhereUniqueInput
    create: XOR<DesignationCreateWithoutCompanyInput, DesignationUncheckedCreateWithoutCompanyInput>
  }

  export type DesignationCreateManyCompanyInputEnvelope = {
    data: DesignationCreateManyCompanyInput | DesignationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type GodownCreateWithoutCompanyInput = {
    godown: string
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutGodownDetailsInput
    Transaction?: TransactionsCreateNestedManyWithoutGodownDetailsInput
  }

  export type GodownUncheckedCreateWithoutCompanyInput = {
    id?: number
    godown: string
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutGodownDetailsInput
    Transaction?: TransactionsUncheckedCreateNestedManyWithoutGodownDetailsInput
  }

  export type GodownCreateOrConnectWithoutCompanyInput = {
    where: GodownWhereUniqueInput
    create: XOR<GodownCreateWithoutCompanyInput, GodownUncheckedCreateWithoutCompanyInput>
  }

  export type GodownCreateManyCompanyInputEnvelope = {
    data: GodownCreateManyCompanyInput | GodownCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TransactionsMasterCreateWithoutCompanyInput = {
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    invoice_no?: string | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    user?: UsersCreateNestedOneWithoutTransactionsMasterInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionsMasterInput
    acno?: ACNOCreateNestedOneWithoutTransactionsMasterInput
    transactions?: TransactionsCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterUncheckedCreateWithoutCompanyInput = {
    tran_id?: number
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    transactions?: TransactionsUncheckedCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterCreateOrConnectWithoutCompanyInput = {
    where: TransactionsMasterWhereUniqueInput
    create: XOR<TransactionsMasterCreateWithoutCompanyInput, TransactionsMasterUncheckedCreateWithoutCompanyInput>
  }

  export type TransactionsMasterCreateManyCompanyInputEnvelope = {
    data: TransactionsMasterCreateManyCompanyInput | TransactionsMasterCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutCompanyInput = {
    user_id: string
    user_name?: string | null
    transactionsMaster?: TransactionsMasterCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutCompanyInput = {
    user_id: string
    user_name?: string | null
    transactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutCompanyInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCompanyInput, UsersUncheckedCreateWithoutCompanyInput>
  }

  export type UsersCreateManyCompanyInputEnvelope = {
    data: UsersCreateManyCompanyInput | UsersCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type FinancialYearCreateWithoutCompanyInput = {
    date_from: Date | string
    date_to: Date | string
    status: string
  }

  export type FinancialYearUncheckedCreateWithoutCompanyInput = {
    id?: number
    date_from: Date | string
    date_to: Date | string
    status: string
  }

  export type FinancialYearCreateOrConnectWithoutCompanyInput = {
    where: FinancialYearWhereUniqueInput
    create: XOR<FinancialYearCreateWithoutCompanyInput, FinancialYearUncheckedCreateWithoutCompanyInput>
  }

  export type FinancialYearCreateManyCompanyInputEnvelope = {
    data: FinancialYearCreateManyCompanyInput | FinancialYearCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SeasonCreateWithoutCompanyInput = {
    date_from: Date | string
    date_to: Date | string
    status: string
  }

  export type SeasonUncheckedCreateWithoutCompanyInput = {
    id?: number
    date_from: Date | string
    date_to: Date | string
    status: string
  }

  export type SeasonCreateOrConnectWithoutCompanyInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutCompanyInput, SeasonUncheckedCreateWithoutCompanyInput>
  }

  export type SeasonCreateManyCompanyInputEnvelope = {
    data: SeasonCreateManyCompanyInput | SeasonCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PoPrdCatCreateWithoutCompanyInput = {
    category_name: string
  }

  export type PoPrdCatUncheckedCreateWithoutCompanyInput = {
    id?: number
    category_name: string
  }

  export type PoPrdCatCreateOrConnectWithoutCompanyInput = {
    where: PoPrdCatWhereUniqueInput
    create: XOR<PoPrdCatCreateWithoutCompanyInput, PoPrdCatUncheckedCreateWithoutCompanyInput>
  }

  export type PoPrdCatCreateManyCompanyInputEnvelope = {
    data: PoPrdCatCreateManyCompanyInput | PoPrdCatCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryModeCreateWithoutCompanyInput = {
    delivery_mode: string
    rate_kg: number
  }

  export type DeliveryModeUncheckedCreateWithoutCompanyInput = {
    id?: number
    delivery_mode: string
    rate_kg: number
  }

  export type DeliveryModeCreateOrConnectWithoutCompanyInput = {
    where: DeliveryModeWhereUniqueInput
    create: XOR<DeliveryModeCreateWithoutCompanyInput, DeliveryModeUncheckedCreateWithoutCompanyInput>
  }

  export type DeliveryModeCreateManyCompanyInputEnvelope = {
    data: DeliveryModeCreateManyCompanyInput | DeliveryModeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryTermCreateWithoutCompanyInput = {
    delivery_term: string
  }

  export type DeliveryTermUncheckedCreateWithoutCompanyInput = {
    id?: number
    delivery_term: string
  }

  export type DeliveryTermCreateOrConnectWithoutCompanyInput = {
    where: DeliveryTermWhereUniqueInput
    create: XOR<DeliveryTermCreateWithoutCompanyInput, DeliveryTermUncheckedCreateWithoutCompanyInput>
  }

  export type DeliveryTermCreateManyCompanyInputEnvelope = {
    data: DeliveryTermCreateManyCompanyInput | DeliveryTermCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CommissionTermCreateWithoutCompanyInput = {
    commission_term: string
  }

  export type CommissionTermUncheckedCreateWithoutCompanyInput = {
    id?: number
    commission_term: string
  }

  export type CommissionTermCreateOrConnectWithoutCompanyInput = {
    where: CommissionTermWhereUniqueInput
    create: XOR<CommissionTermCreateWithoutCompanyInput, CommissionTermUncheckedCreateWithoutCompanyInput>
  }

  export type CommissionTermCreateManyCompanyInputEnvelope = {
    data: CommissionTermCreateManyCompanyInput | CommissionTermCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutCompanyInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    manager?: ManagerCreateNestedOneWithoutEmployeesInput
    employer: EmployerCreateNestedOneWithoutEmployeesInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutCompanyInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    manager_id?: string | null
    client_id: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutCompanyInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput>
  }

  export type EmployeeCreateManyCompanyInputEnvelope = {
    data: EmployeeCreateManyCompanyInput | EmployeeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CostCenterUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CostCenterWhereUniqueInput
    update: XOR<CostCenterUpdateWithoutCompanyInput, CostCenterUncheckedUpdateWithoutCompanyInput>
    create: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput>
  }

  export type CostCenterUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CostCenterWhereUniqueInput
    data: XOR<CostCenterUpdateWithoutCompanyInput, CostCenterUncheckedUpdateWithoutCompanyInput>
  }

  export type CostCenterUpdateManyWithWhereWithoutCompanyInput = {
    where: CostCenterScalarWhereInput
    data: XOR<CostCenterUpdateManyMutationInput, CostCenterUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CostCenterScalarWhereInput = {
    AND?: CostCenterScalarWhereInput | CostCenterScalarWhereInput[]
    OR?: CostCenterScalarWhereInput[]
    NOT?: CostCenterScalarWhereInput | CostCenterScalarWhereInput[]
    ccno?: IntFilter<"CostCenter"> | number
    company_id?: IntFilter<"CostCenter"> | number
    ccname?: StringNullableFilter<"CostCenter"> | string | null
  }

  export type DepartmentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutCompanyInput, DepartmentUncheckedUpdateWithoutCompanyInput>
    create: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutCompanyInput, DepartmentUncheckedUpdateWithoutCompanyInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutCompanyInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: IntFilter<"Department"> | number
    dept_name?: StringNullableFilter<"Department"> | string | null
    company_id?: IntFilter<"Department"> | number
  }

  export type DesignationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DesignationWhereUniqueInput
    update: XOR<DesignationUpdateWithoutCompanyInput, DesignationUncheckedUpdateWithoutCompanyInput>
    create: XOR<DesignationCreateWithoutCompanyInput, DesignationUncheckedCreateWithoutCompanyInput>
  }

  export type DesignationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DesignationWhereUniqueInput
    data: XOR<DesignationUpdateWithoutCompanyInput, DesignationUncheckedUpdateWithoutCompanyInput>
  }

  export type DesignationUpdateManyWithWhereWithoutCompanyInput = {
    where: DesignationScalarWhereInput
    data: XOR<DesignationUpdateManyMutationInput, DesignationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DesignationScalarWhereInput = {
    AND?: DesignationScalarWhereInput | DesignationScalarWhereInput[]
    OR?: DesignationScalarWhereInput[]
    NOT?: DesignationScalarWhereInput | DesignationScalarWhereInput[]
    id?: IntFilter<"Designation"> | number
    desg_name?: StringNullableFilter<"Designation"> | string | null
    company_id?: IntFilter<"Designation"> | number
  }

  export type GodownUpsertWithWhereUniqueWithoutCompanyInput = {
    where: GodownWhereUniqueInput
    update: XOR<GodownUpdateWithoutCompanyInput, GodownUncheckedUpdateWithoutCompanyInput>
    create: XOR<GodownCreateWithoutCompanyInput, GodownUncheckedCreateWithoutCompanyInput>
  }

  export type GodownUpdateWithWhereUniqueWithoutCompanyInput = {
    where: GodownWhereUniqueInput
    data: XOR<GodownUpdateWithoutCompanyInput, GodownUncheckedUpdateWithoutCompanyInput>
  }

  export type GodownUpdateManyWithWhereWithoutCompanyInput = {
    where: GodownScalarWhereInput
    data: XOR<GodownUpdateManyMutationInput, GodownUncheckedUpdateManyWithoutCompanyInput>
  }

  export type GodownScalarWhereInput = {
    AND?: GodownScalarWhereInput | GodownScalarWhereInput[]
    OR?: GodownScalarWhereInput[]
    NOT?: GodownScalarWhereInput | GodownScalarWhereInput[]
    id?: IntFilter<"Godown"> | number
    godown?: StringFilter<"Godown"> | string
    company_id?: IntFilter<"Godown"> | number
  }

  export type TransactionsMasterUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TransactionsMasterWhereUniqueInput
    update: XOR<TransactionsMasterUpdateWithoutCompanyInput, TransactionsMasterUncheckedUpdateWithoutCompanyInput>
    create: XOR<TransactionsMasterCreateWithoutCompanyInput, TransactionsMasterUncheckedCreateWithoutCompanyInput>
  }

  export type TransactionsMasterUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TransactionsMasterWhereUniqueInput
    data: XOR<TransactionsMasterUpdateWithoutCompanyInput, TransactionsMasterUncheckedUpdateWithoutCompanyInput>
  }

  export type TransactionsMasterUpdateManyWithWhereWithoutCompanyInput = {
    where: TransactionsMasterScalarWhereInput
    data: XOR<TransactionsMasterUpdateManyMutationInput, TransactionsMasterUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UsersUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutCompanyInput, UsersUncheckedUpdateWithoutCompanyInput>
    create: XOR<UsersCreateWithoutCompanyInput, UsersUncheckedCreateWithoutCompanyInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutCompanyInput, UsersUncheckedUpdateWithoutCompanyInput>
  }

  export type UsersUpdateManyWithWhereWithoutCompanyInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    user_id?: StringFilter<"Users"> | string
    user_name?: StringNullableFilter<"Users"> | string | null
    company_id?: IntFilter<"Users"> | number
  }

  export type FinancialYearUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FinancialYearWhereUniqueInput
    update: XOR<FinancialYearUpdateWithoutCompanyInput, FinancialYearUncheckedUpdateWithoutCompanyInput>
    create: XOR<FinancialYearCreateWithoutCompanyInput, FinancialYearUncheckedCreateWithoutCompanyInput>
  }

  export type FinancialYearUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FinancialYearWhereUniqueInput
    data: XOR<FinancialYearUpdateWithoutCompanyInput, FinancialYearUncheckedUpdateWithoutCompanyInput>
  }

  export type FinancialYearUpdateManyWithWhereWithoutCompanyInput = {
    where: FinancialYearScalarWhereInput
    data: XOR<FinancialYearUpdateManyMutationInput, FinancialYearUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FinancialYearScalarWhereInput = {
    AND?: FinancialYearScalarWhereInput | FinancialYearScalarWhereInput[]
    OR?: FinancialYearScalarWhereInput[]
    NOT?: FinancialYearScalarWhereInput | FinancialYearScalarWhereInput[]
    id?: IntFilter<"FinancialYear"> | number
    date_from?: DateTimeFilter<"FinancialYear"> | Date | string
    date_to?: DateTimeFilter<"FinancialYear"> | Date | string
    status?: StringFilter<"FinancialYear"> | string
    company_id?: IntFilter<"FinancialYear"> | number
  }

  export type SeasonUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SeasonWhereUniqueInput
    update: XOR<SeasonUpdateWithoutCompanyInput, SeasonUncheckedUpdateWithoutCompanyInput>
    create: XOR<SeasonCreateWithoutCompanyInput, SeasonUncheckedCreateWithoutCompanyInput>
  }

  export type SeasonUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SeasonWhereUniqueInput
    data: XOR<SeasonUpdateWithoutCompanyInput, SeasonUncheckedUpdateWithoutCompanyInput>
  }

  export type SeasonUpdateManyWithWhereWithoutCompanyInput = {
    where: SeasonScalarWhereInput
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SeasonScalarWhereInput = {
    AND?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    OR?: SeasonScalarWhereInput[]
    NOT?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    id?: IntFilter<"Season"> | number
    date_from?: DateTimeFilter<"Season"> | Date | string
    date_to?: DateTimeFilter<"Season"> | Date | string
    status?: StringFilter<"Season"> | string
    company_id?: IntFilter<"Season"> | number
  }

  export type PoPrdCatUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PoPrdCatWhereUniqueInput
    update: XOR<PoPrdCatUpdateWithoutCompanyInput, PoPrdCatUncheckedUpdateWithoutCompanyInput>
    create: XOR<PoPrdCatCreateWithoutCompanyInput, PoPrdCatUncheckedCreateWithoutCompanyInput>
  }

  export type PoPrdCatUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PoPrdCatWhereUniqueInput
    data: XOR<PoPrdCatUpdateWithoutCompanyInput, PoPrdCatUncheckedUpdateWithoutCompanyInput>
  }

  export type PoPrdCatUpdateManyWithWhereWithoutCompanyInput = {
    where: PoPrdCatScalarWhereInput
    data: XOR<PoPrdCatUpdateManyMutationInput, PoPrdCatUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PoPrdCatScalarWhereInput = {
    AND?: PoPrdCatScalarWhereInput | PoPrdCatScalarWhereInput[]
    OR?: PoPrdCatScalarWhereInput[]
    NOT?: PoPrdCatScalarWhereInput | PoPrdCatScalarWhereInput[]
    id?: IntFilter<"PoPrdCat"> | number
    category_name?: StringFilter<"PoPrdCat"> | string
    company_id?: IntFilter<"PoPrdCat"> | number
  }

  export type DeliveryModeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DeliveryModeWhereUniqueInput
    update: XOR<DeliveryModeUpdateWithoutCompanyInput, DeliveryModeUncheckedUpdateWithoutCompanyInput>
    create: XOR<DeliveryModeCreateWithoutCompanyInput, DeliveryModeUncheckedCreateWithoutCompanyInput>
  }

  export type DeliveryModeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DeliveryModeWhereUniqueInput
    data: XOR<DeliveryModeUpdateWithoutCompanyInput, DeliveryModeUncheckedUpdateWithoutCompanyInput>
  }

  export type DeliveryModeUpdateManyWithWhereWithoutCompanyInput = {
    where: DeliveryModeScalarWhereInput
    data: XOR<DeliveryModeUpdateManyMutationInput, DeliveryModeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DeliveryModeScalarWhereInput = {
    AND?: DeliveryModeScalarWhereInput | DeliveryModeScalarWhereInput[]
    OR?: DeliveryModeScalarWhereInput[]
    NOT?: DeliveryModeScalarWhereInput | DeliveryModeScalarWhereInput[]
    id?: IntFilter<"DeliveryMode"> | number
    delivery_mode?: StringFilter<"DeliveryMode"> | string
    rate_kg?: IntFilter<"DeliveryMode"> | number
    company_id?: IntFilter<"DeliveryMode"> | number
  }

  export type DeliveryTermUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DeliveryTermWhereUniqueInput
    update: XOR<DeliveryTermUpdateWithoutCompanyInput, DeliveryTermUncheckedUpdateWithoutCompanyInput>
    create: XOR<DeliveryTermCreateWithoutCompanyInput, DeliveryTermUncheckedCreateWithoutCompanyInput>
  }

  export type DeliveryTermUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DeliveryTermWhereUniqueInput
    data: XOR<DeliveryTermUpdateWithoutCompanyInput, DeliveryTermUncheckedUpdateWithoutCompanyInput>
  }

  export type DeliveryTermUpdateManyWithWhereWithoutCompanyInput = {
    where: DeliveryTermScalarWhereInput
    data: XOR<DeliveryTermUpdateManyMutationInput, DeliveryTermUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DeliveryTermScalarWhereInput = {
    AND?: DeliveryTermScalarWhereInput | DeliveryTermScalarWhereInput[]
    OR?: DeliveryTermScalarWhereInput[]
    NOT?: DeliveryTermScalarWhereInput | DeliveryTermScalarWhereInput[]
    id?: IntFilter<"DeliveryTerm"> | number
    delivery_term?: StringFilter<"DeliveryTerm"> | string
    company_id?: IntFilter<"DeliveryTerm"> | number
  }

  export type CommissionTermUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CommissionTermWhereUniqueInput
    update: XOR<CommissionTermUpdateWithoutCompanyInput, CommissionTermUncheckedUpdateWithoutCompanyInput>
    create: XOR<CommissionTermCreateWithoutCompanyInput, CommissionTermUncheckedCreateWithoutCompanyInput>
  }

  export type CommissionTermUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CommissionTermWhereUniqueInput
    data: XOR<CommissionTermUpdateWithoutCompanyInput, CommissionTermUncheckedUpdateWithoutCompanyInput>
  }

  export type CommissionTermUpdateManyWithWhereWithoutCompanyInput = {
    where: CommissionTermScalarWhereInput
    data: XOR<CommissionTermUpdateManyMutationInput, CommissionTermUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CommissionTermScalarWhereInput = {
    AND?: CommissionTermScalarWhereInput | CommissionTermScalarWhereInput[]
    OR?: CommissionTermScalarWhereInput[]
    NOT?: CommissionTermScalarWhereInput | CommissionTermScalarWhereInput[]
    id?: IntFilter<"CommissionTerm"> | number
    commission_term?: StringFilter<"CommissionTerm"> | string
    company_id?: IntFilter<"CommissionTerm"> | number
  }

  export type EmployeeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutCompanyInput, EmployeeUncheckedUpdateWithoutCompanyInput>
    create: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutCompanyInput, EmployeeUncheckedUpdateWithoutCompanyInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutCompanyInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    first_name?: StringFilter<"Employee"> | string
    middle_name?: StringNullableFilter<"Employee"> | string | null
    surname?: StringFilter<"Employee"> | string
    dob?: DateTimeFilter<"Employee"> | Date | string
    gender?: EnumGenderNullableFilter<"Employee"> | $Enums.Gender | null
    phone_number?: StringFilter<"Employee"> | string
    npf_number?: StringFilter<"Employee"> | string
    email_address?: StringFilter<"Employee"> | string
    village?: StringFilter<"Employee"> | string
    status?: EnumStatusNullableFilter<"Employee"> | $Enums.Status | null
    hire_date?: DateTimeFilter<"Employee"> | Date | string
    job_title?: StringFilter<"Employee"> | string
    department?: StringFilter<"Employee"> | string
    work_location?: StringFilter<"Employee"> | string
    manager_id?: StringNullableFilter<"Employee"> | string | null
    client_id?: StringFilter<"Employee"> | string
    employee_id?: StringFilter<"Employee"> | string
    payment_method?: EnumPaymentMethodNullableFilter<"Employee"> | $Enums.PaymentMethod | null
    bank_name?: StringNullableFilter<"Employee"> | string | null
    account_name?: StringNullableFilter<"Employee"> | string | null
    account_number?: StringNullableFilter<"Employee"> | string | null
    pay_type?: EnumPayTypeNullableFilter<"Employee"> | $Enums.PayType | null
    rate_per_hour?: FloatFilter<"Employee"> | number
    pay_frequency?: EnumPayFrequencyNullableFilter<"Employee"> | $Enums.PayFrequency | null
    employee_type?: StringFilter<"Employee"> | string
    cost_center?: StringFilter<"Employee"> | string
    allownces?: JsonFilter<"Employee">
    allownce_eligible?: BoolFilter<"Employee"> | boolean
    deductions?: JsonFilter<"Employee">
    profile_image?: StringNullableFilter<"Employee"> | string | null
    created_on?: DateTimeFilter<"Employee"> | Date | string
    updated_on?: DateTimeFilter<"Employee"> | Date | string
    company_id?: IntFilter<"Employee"> | number
  }

  export type CompanyCreateWithoutCostCentersInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCostCentersInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCostCentersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCostCentersInput, CompanyUncheckedCreateWithoutCostCentersInput>
  }

  export type TransactionsCreateWithoutCostCenterInput = {
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
    acnoDetails?: ACNOCreateNestedOneWithoutTransactionsInput
    currencyDetails?: CurrencyCreateNestedOneWithoutTransactionsInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionInput
    itemDetails?: ItemCreateNestedOneWithoutTransactionsInput
    transactionsMaster: TransactionsMasterCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutCostCenterInput = {
    id?: number
    tran_id: number
    acno?: string | null
    itcd?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsCreateOrConnectWithoutCostCenterInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutCostCenterInput, TransactionsUncheckedCreateWithoutCostCenterInput>
  }

  export type TransactionsCreateManyCostCenterInputEnvelope = {
    data: TransactionsCreateManyCostCenterInput | TransactionsCreateManyCostCenterInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutCostCentersInput = {
    update: XOR<CompanyUpdateWithoutCostCentersInput, CompanyUncheckedUpdateWithoutCostCentersInput>
    create: XOR<CompanyCreateWithoutCostCentersInput, CompanyUncheckedCreateWithoutCostCentersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCostCentersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCostCentersInput, CompanyUncheckedUpdateWithoutCostCentersInput>
  }

  export type CompanyUpdateWithoutCostCentersInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCostCentersInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TransactionsUpsertWithWhereUniqueWithoutCostCenterInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutCostCenterInput, TransactionsUncheckedUpdateWithoutCostCenterInput>
    create: XOR<TransactionsCreateWithoutCostCenterInput, TransactionsUncheckedCreateWithoutCostCenterInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutCostCenterInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutCostCenterInput, TransactionsUncheckedUpdateWithoutCostCenterInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutCostCenterInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutCostCenterInput>
  }

  export type CompanyCreateWithoutDepartmentsInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDepartmentsInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDepartmentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
  }

  export type CompanyUpsertWithoutDepartmentsInput = {
    update: XOR<CompanyUpdateWithoutDepartmentsInput, CompanyUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDepartmentsInput, CompanyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CompanyUpdateWithoutDepartmentsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDepartmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProductGroupCreateWithoutProductMasterCategoriesInput = {
    pg_name?: string | null
    productCategories?: ProductCategoryCreateNestedManyWithoutProductGroupsInput
  }

  export type ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput = {
    id?: number
    pg_name?: string | null
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutProductGroupsInput
  }

  export type ProductGroupCreateOrConnectWithoutProductMasterCategoriesInput = {
    where: ProductGroupWhereUniqueInput
    create: XOR<ProductGroupCreateWithoutProductMasterCategoriesInput, ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput>
  }

  export type ProductGroupCreateManyProductMasterCategoriesInputEnvelope = {
    data: ProductGroupCreateManyProductMasterCategoriesInput | ProductGroupCreateManyProductMasterCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type ProductGroupUpsertWithWhereUniqueWithoutProductMasterCategoriesInput = {
    where: ProductGroupWhereUniqueInput
    update: XOR<ProductGroupUpdateWithoutProductMasterCategoriesInput, ProductGroupUncheckedUpdateWithoutProductMasterCategoriesInput>
    create: XOR<ProductGroupCreateWithoutProductMasterCategoriesInput, ProductGroupUncheckedCreateWithoutProductMasterCategoriesInput>
  }

  export type ProductGroupUpdateWithWhereUniqueWithoutProductMasterCategoriesInput = {
    where: ProductGroupWhereUniqueInput
    data: XOR<ProductGroupUpdateWithoutProductMasterCategoriesInput, ProductGroupUncheckedUpdateWithoutProductMasterCategoriesInput>
  }

  export type ProductGroupUpdateManyWithWhereWithoutProductMasterCategoriesInput = {
    where: ProductGroupScalarWhereInput
    data: XOR<ProductGroupUpdateManyMutationInput, ProductGroupUncheckedUpdateManyWithoutProductMasterCategoriesInput>
  }

  export type ProductGroupScalarWhereInput = {
    AND?: ProductGroupScalarWhereInput | ProductGroupScalarWhereInput[]
    OR?: ProductGroupScalarWhereInput[]
    NOT?: ProductGroupScalarWhereInput | ProductGroupScalarWhereInput[]
    id?: IntFilter<"ProductGroup"> | number
    pg_name?: StringNullableFilter<"ProductGroup"> | string | null
    pmc_id?: IntFilter<"ProductGroup"> | number
  }

  export type ProductCategoryCreateWithoutProductGroupsInput = {
    pc_name?: string | null
    mainCategories?: MainCategoryCreateNestedManyWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductGroupsInput = {
    id?: number
    pc_name?: string | null
    mainCategories?: MainCategoryUncheckedCreateNestedManyWithoutProductCategoriesInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductGroupsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductGroupsInput, ProductCategoryUncheckedCreateWithoutProductGroupsInput>
  }

  export type ProductCategoryCreateManyProductGroupsInputEnvelope = {
    data: ProductCategoryCreateManyProductGroupsInput | ProductCategoryCreateManyProductGroupsInput[]
    skipDuplicates?: boolean
  }

  export type ProductMasterCategoryCreateWithoutProductGroupsInput = {
    pmc_name?: string | null
  }

  export type ProductMasterCategoryUncheckedCreateWithoutProductGroupsInput = {
    id?: number
    pmc_name?: string | null
  }

  export type ProductMasterCategoryCreateOrConnectWithoutProductGroupsInput = {
    where: ProductMasterCategoryWhereUniqueInput
    create: XOR<ProductMasterCategoryCreateWithoutProductGroupsInput, ProductMasterCategoryUncheckedCreateWithoutProductGroupsInput>
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutProductGroupsInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutProductGroupsInput, ProductCategoryUncheckedUpdateWithoutProductGroupsInput>
    create: XOR<ProductCategoryCreateWithoutProductGroupsInput, ProductCategoryUncheckedCreateWithoutProductGroupsInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutProductGroupsInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutProductGroupsInput, ProductCategoryUncheckedUpdateWithoutProductGroupsInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutProductGroupsInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutProductGroupsInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    pc_name?: StringNullableFilter<"ProductCategory"> | string | null
    pg_id?: IntFilter<"ProductCategory"> | number
  }

  export type ProductMasterCategoryUpsertWithoutProductGroupsInput = {
    update: XOR<ProductMasterCategoryUpdateWithoutProductGroupsInput, ProductMasterCategoryUncheckedUpdateWithoutProductGroupsInput>
    create: XOR<ProductMasterCategoryCreateWithoutProductGroupsInput, ProductMasterCategoryUncheckedCreateWithoutProductGroupsInput>
    where?: ProductMasterCategoryWhereInput
  }

  export type ProductMasterCategoryUpdateToOneWithWhereWithoutProductGroupsInput = {
    where?: ProductMasterCategoryWhereInput
    data: XOR<ProductMasterCategoryUpdateWithoutProductGroupsInput, ProductMasterCategoryUncheckedUpdateWithoutProductGroupsInput>
  }

  export type ProductMasterCategoryUpdateWithoutProductGroupsInput = {
    pmc_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductMasterCategoryUncheckedUpdateWithoutProductGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    pmc_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MainCategoryCreateWithoutProductCategoriesInput = {
    mc_name?: string | null
    itemCategories?: ItemCategoryCreateNestedManyWithoutMainCategoryInput
  }

  export type MainCategoryUncheckedCreateWithoutProductCategoriesInput = {
    id?: number
    mc_name?: string | null
    itemCategories?: ItemCategoryUncheckedCreateNestedManyWithoutMainCategoryInput
  }

  export type MainCategoryCreateOrConnectWithoutProductCategoriesInput = {
    where: MainCategoryWhereUniqueInput
    create: XOR<MainCategoryCreateWithoutProductCategoriesInput, MainCategoryUncheckedCreateWithoutProductCategoriesInput>
  }

  export type MainCategoryCreateManyProductCategoriesInputEnvelope = {
    data: MainCategoryCreateManyProductCategoriesInput | MainCategoryCreateManyProductCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type ProductGroupCreateWithoutProductCategoriesInput = {
    pg_name?: string | null
    ProductMasterCategories: ProductMasterCategoryCreateNestedOneWithoutProductGroupsInput
  }

  export type ProductGroupUncheckedCreateWithoutProductCategoriesInput = {
    id?: number
    pg_name?: string | null
    pmc_id: number
  }

  export type ProductGroupCreateOrConnectWithoutProductCategoriesInput = {
    where: ProductGroupWhereUniqueInput
    create: XOR<ProductGroupCreateWithoutProductCategoriesInput, ProductGroupUncheckedCreateWithoutProductCategoriesInput>
  }

  export type MainCategoryUpsertWithWhereUniqueWithoutProductCategoriesInput = {
    where: MainCategoryWhereUniqueInput
    update: XOR<MainCategoryUpdateWithoutProductCategoriesInput, MainCategoryUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<MainCategoryCreateWithoutProductCategoriesInput, MainCategoryUncheckedCreateWithoutProductCategoriesInput>
  }

  export type MainCategoryUpdateWithWhereUniqueWithoutProductCategoriesInput = {
    where: MainCategoryWhereUniqueInput
    data: XOR<MainCategoryUpdateWithoutProductCategoriesInput, MainCategoryUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type MainCategoryUpdateManyWithWhereWithoutProductCategoriesInput = {
    where: MainCategoryScalarWhereInput
    data: XOR<MainCategoryUpdateManyMutationInput, MainCategoryUncheckedUpdateManyWithoutProductCategoriesInput>
  }

  export type MainCategoryScalarWhereInput = {
    AND?: MainCategoryScalarWhereInput | MainCategoryScalarWhereInput[]
    OR?: MainCategoryScalarWhereInput[]
    NOT?: MainCategoryScalarWhereInput | MainCategoryScalarWhereInput[]
    id?: IntFilter<"MainCategory"> | number
    mc_name?: StringNullableFilter<"MainCategory"> | string | null
    pc_id?: IntFilter<"MainCategory"> | number
  }

  export type ProductGroupUpsertWithoutProductCategoriesInput = {
    update: XOR<ProductGroupUpdateWithoutProductCategoriesInput, ProductGroupUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<ProductGroupCreateWithoutProductCategoriesInput, ProductGroupUncheckedCreateWithoutProductCategoriesInput>
    where?: ProductGroupWhereInput
  }

  export type ProductGroupUpdateToOneWithWhereWithoutProductCategoriesInput = {
    where?: ProductGroupWhereInput
    data: XOR<ProductGroupUpdateWithoutProductCategoriesInput, ProductGroupUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type ProductGroupUpdateWithoutProductCategoriesInput = {
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
    ProductMasterCategories?: ProductMasterCategoryUpdateOneRequiredWithoutProductGroupsNestedInput
  }

  export type ProductGroupUncheckedUpdateWithoutProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
    pmc_id?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCategoryCreateWithoutMainCategoryInput = {
    ic_name: string
    wc_category_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    items?: ItemCreateNestedManyWithoutItemCategoriesInput
  }

  export type ItemCategoryUncheckedCreateWithoutMainCategoryInput = {
    id?: number
    ic_name: string
    wc_category_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    items?: ItemUncheckedCreateNestedManyWithoutItemCategoriesInput
  }

  export type ItemCategoryCreateOrConnectWithoutMainCategoryInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutMainCategoryInput, ItemCategoryUncheckedCreateWithoutMainCategoryInput>
  }

  export type ItemCategoryCreateManyMainCategoryInputEnvelope = {
    data: ItemCategoryCreateManyMainCategoryInput | ItemCategoryCreateManyMainCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutMainCategoriesInput = {
    pc_name?: string | null
    ProductGroups: ProductGroupCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutMainCategoriesInput = {
    id?: number
    pc_name?: string | null
    pg_id: number
  }

  export type ProductCategoryCreateOrConnectWithoutMainCategoriesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutMainCategoriesInput, ProductCategoryUncheckedCreateWithoutMainCategoriesInput>
  }

  export type ItemCategoryUpsertWithWhereUniqueWithoutMainCategoryInput = {
    where: ItemCategoryWhereUniqueInput
    update: XOR<ItemCategoryUpdateWithoutMainCategoryInput, ItemCategoryUncheckedUpdateWithoutMainCategoryInput>
    create: XOR<ItemCategoryCreateWithoutMainCategoryInput, ItemCategoryUncheckedCreateWithoutMainCategoryInput>
  }

  export type ItemCategoryUpdateWithWhereUniqueWithoutMainCategoryInput = {
    where: ItemCategoryWhereUniqueInput
    data: XOR<ItemCategoryUpdateWithoutMainCategoryInput, ItemCategoryUncheckedUpdateWithoutMainCategoryInput>
  }

  export type ItemCategoryUpdateManyWithWhereWithoutMainCategoryInput = {
    where: ItemCategoryScalarWhereInput
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyWithoutMainCategoryInput>
  }

  export type ItemCategoryScalarWhereInput = {
    AND?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
    OR?: ItemCategoryScalarWhereInput[]
    NOT?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
    id?: IntFilter<"ItemCategory"> | number
    ic_name?: StringFilter<"ItemCategory"> | string
    mc_id?: IntFilter<"ItemCategory"> | number
    wc_category_id?: IntNullableFilter<"ItemCategory"> | number | null
    sync_status?: StringNullableFilter<"ItemCategory"> | string | null
    last_sync?: DateTimeNullableFilter<"ItemCategory"> | Date | string | null
  }

  export type ProductCategoryUpsertWithoutMainCategoriesInput = {
    update: XOR<ProductCategoryUpdateWithoutMainCategoriesInput, ProductCategoryUncheckedUpdateWithoutMainCategoriesInput>
    create: XOR<ProductCategoryCreateWithoutMainCategoriesInput, ProductCategoryUncheckedCreateWithoutMainCategoriesInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutMainCategoriesInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutMainCategoriesInput, ProductCategoryUncheckedUpdateWithoutMainCategoriesInput>
  }

  export type ProductCategoryUpdateWithoutMainCategoriesInput = {
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
    ProductGroups?: ProductGroupUpdateOneRequiredWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutMainCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pg_id?: IntFieldUpdateOperationsInput | number
  }

  export type MainCategoryCreateWithoutItemCategoriesInput = {
    mc_name?: string | null
    ProductCategories: ProductCategoryCreateNestedOneWithoutMainCategoriesInput
  }

  export type MainCategoryUncheckedCreateWithoutItemCategoriesInput = {
    id?: number
    mc_name?: string | null
    pc_id: number
  }

  export type MainCategoryCreateOrConnectWithoutItemCategoriesInput = {
    where: MainCategoryWhereUniqueInput
    create: XOR<MainCategoryCreateWithoutItemCategoriesInput, MainCategoryUncheckedCreateWithoutItemCategoriesInput>
  }

  export type ItemCreateWithoutItemCategoriesInput = {
    item?: string | null
    sku?: string | null
    price?: number | null
    stock?: number | null
    wc_product_id?: number | null
    wc_parent_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    Transactions?: TransactionsCreateNestedManyWithoutItemDetailsInput
  }

  export type ItemUncheckedCreateWithoutItemCategoriesInput = {
    itcd?: number
    item?: string | null
    sku?: string | null
    price?: number | null
    stock?: number | null
    wc_product_id?: number | null
    wc_parent_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    Transactions?: TransactionsUncheckedCreateNestedManyWithoutItemDetailsInput
  }

  export type ItemCreateOrConnectWithoutItemCategoriesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemCategoriesInput, ItemUncheckedCreateWithoutItemCategoriesInput>
  }

  export type ItemCreateManyItemCategoriesInputEnvelope = {
    data: ItemCreateManyItemCategoriesInput | ItemCreateManyItemCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type MainCategoryUpsertWithoutItemCategoriesInput = {
    update: XOR<MainCategoryUpdateWithoutItemCategoriesInput, MainCategoryUncheckedUpdateWithoutItemCategoriesInput>
    create: XOR<MainCategoryCreateWithoutItemCategoriesInput, MainCategoryUncheckedCreateWithoutItemCategoriesInput>
    where?: MainCategoryWhereInput
  }

  export type MainCategoryUpdateToOneWithWhereWithoutItemCategoriesInput = {
    where?: MainCategoryWhereInput
    data: XOR<MainCategoryUpdateWithoutItemCategoriesInput, MainCategoryUncheckedUpdateWithoutItemCategoriesInput>
  }

  export type MainCategoryUpdateWithoutItemCategoriesInput = {
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
    ProductCategories?: ProductCategoryUpdateOneRequiredWithoutMainCategoriesNestedInput
  }

  export type MainCategoryUncheckedUpdateWithoutItemCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pc_id?: IntFieldUpdateOperationsInput | number
  }

  export type ItemUpsertWithWhereUniqueWithoutItemCategoriesInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutItemCategoriesInput, ItemUncheckedUpdateWithoutItemCategoriesInput>
    create: XOR<ItemCreateWithoutItemCategoriesInput, ItemUncheckedCreateWithoutItemCategoriesInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutItemCategoriesInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutItemCategoriesInput, ItemUncheckedUpdateWithoutItemCategoriesInput>
  }

  export type ItemUpdateManyWithWhereWithoutItemCategoriesInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemCategoriesInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    itcd?: IntFilter<"Item"> | number
    item?: StringNullableFilter<"Item"> | string | null
    ic_id?: IntFilter<"Item"> | number
    sku?: StringNullableFilter<"Item"> | string | null
    price?: FloatNullableFilter<"Item"> | number | null
    stock?: IntNullableFilter<"Item"> | number | null
    wc_product_id?: IntNullableFilter<"Item"> | number | null
    wc_parent_id?: IntNullableFilter<"Item"> | number | null
    sync_status?: StringNullableFilter<"Item"> | string | null
    last_sync?: DateTimeNullableFilter<"Item"> | Date | string | null
  }

  export type ItemCategoryCreateWithoutItemsInput = {
    ic_name: string
    wc_category_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    mainCategory: MainCategoryCreateNestedOneWithoutItemCategoriesInput
  }

  export type ItemCategoryUncheckedCreateWithoutItemsInput = {
    id?: number
    ic_name: string
    mc_id: number
    wc_category_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type ItemCategoryCreateOrConnectWithoutItemsInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
  }

  export type TransactionsCreateWithoutItemDetailsInput = {
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
    acnoDetails?: ACNOCreateNestedOneWithoutTransactionsInput
    costCenter?: CostCenterCreateNestedOneWithoutTransactionInput
    currencyDetails?: CurrencyCreateNestedOneWithoutTransactionsInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionInput
    transactionsMaster: TransactionsMasterCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutItemDetailsInput = {
    id?: number
    tran_id: number
    acno?: string | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsCreateOrConnectWithoutItemDetailsInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutItemDetailsInput, TransactionsUncheckedCreateWithoutItemDetailsInput>
  }

  export type TransactionsCreateManyItemDetailsInputEnvelope = {
    data: TransactionsCreateManyItemDetailsInput | TransactionsCreateManyItemDetailsInput[]
    skipDuplicates?: boolean
  }

  export type ItemCategoryUpsertWithoutItemsInput = {
    update: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryUpdateWithoutItemsInput = {
    ic_name?: StringFieldUpdateOperationsInput | string
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mainCategory?: MainCategoryUpdateOneRequiredWithoutItemCategoriesNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ic_name?: StringFieldUpdateOperationsInput | string
    mc_id?: IntFieldUpdateOperationsInput | number
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsUpsertWithWhereUniqueWithoutItemDetailsInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutItemDetailsInput, TransactionsUncheckedUpdateWithoutItemDetailsInput>
    create: XOR<TransactionsCreateWithoutItemDetailsInput, TransactionsUncheckedCreateWithoutItemDetailsInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutItemDetailsInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutItemDetailsInput, TransactionsUncheckedUpdateWithoutItemDetailsInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutItemDetailsInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutItemDetailsInput>
  }

  export type CompanyCreateWithoutDesignationsInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDesignationsInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDesignationsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDesignationsInput, CompanyUncheckedCreateWithoutDesignationsInput>
  }

  export type CompanyUpsertWithoutDesignationsInput = {
    update: XOR<CompanyUpdateWithoutDesignationsInput, CompanyUncheckedUpdateWithoutDesignationsInput>
    create: XOR<CompanyCreateWithoutDesignationsInput, CompanyUncheckedCreateWithoutDesignationsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDesignationsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDesignationsInput, CompanyUncheckedUpdateWithoutDesignationsInput>
  }

  export type CompanyUpdateWithoutDesignationsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDesignationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutGodownsInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutGodownsInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutGodownsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutGodownsInput, CompanyUncheckedCreateWithoutGodownsInput>
  }

  export type TransactionsMasterCreateWithoutGodownDetailsInput = {
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    invoice_no?: string | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    user?: UsersCreateNestedOneWithoutTransactionsMasterInput
    company?: CompanyCreateNestedOneWithoutTransactionsMasterInput
    acno?: ACNOCreateNestedOneWithoutTransactionsMasterInput
    transactions?: TransactionsCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterUncheckedCreateWithoutGodownDetailsInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    transactions?: TransactionsUncheckedCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterCreateOrConnectWithoutGodownDetailsInput = {
    where: TransactionsMasterWhereUniqueInput
    create: XOR<TransactionsMasterCreateWithoutGodownDetailsInput, TransactionsMasterUncheckedCreateWithoutGodownDetailsInput>
  }

  export type TransactionsMasterCreateManyGodownDetailsInputEnvelope = {
    data: TransactionsMasterCreateManyGodownDetailsInput | TransactionsMasterCreateManyGodownDetailsInput[]
    skipDuplicates?: boolean
  }

  export type TransactionsCreateWithoutGodownDetailsInput = {
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
    acnoDetails?: ACNOCreateNestedOneWithoutTransactionsInput
    costCenter?: CostCenterCreateNestedOneWithoutTransactionInput
    currencyDetails?: CurrencyCreateNestedOneWithoutTransactionsInput
    itemDetails?: ItemCreateNestedOneWithoutTransactionsInput
    transactionsMaster: TransactionsMasterCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutGodownDetailsInput = {
    id?: number
    tran_id: number
    acno?: string | null
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsCreateOrConnectWithoutGodownDetailsInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutGodownDetailsInput, TransactionsUncheckedCreateWithoutGodownDetailsInput>
  }

  export type TransactionsCreateManyGodownDetailsInputEnvelope = {
    data: TransactionsCreateManyGodownDetailsInput | TransactionsCreateManyGodownDetailsInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutGodownsInput = {
    update: XOR<CompanyUpdateWithoutGodownsInput, CompanyUncheckedUpdateWithoutGodownsInput>
    create: XOR<CompanyCreateWithoutGodownsInput, CompanyUncheckedCreateWithoutGodownsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutGodownsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutGodownsInput, CompanyUncheckedUpdateWithoutGodownsInput>
  }

  export type CompanyUpdateWithoutGodownsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutGodownsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TransactionsMasterUpsertWithWhereUniqueWithoutGodownDetailsInput = {
    where: TransactionsMasterWhereUniqueInput
    update: XOR<TransactionsMasterUpdateWithoutGodownDetailsInput, TransactionsMasterUncheckedUpdateWithoutGodownDetailsInput>
    create: XOR<TransactionsMasterCreateWithoutGodownDetailsInput, TransactionsMasterUncheckedCreateWithoutGodownDetailsInput>
  }

  export type TransactionsMasterUpdateWithWhereUniqueWithoutGodownDetailsInput = {
    where: TransactionsMasterWhereUniqueInput
    data: XOR<TransactionsMasterUpdateWithoutGodownDetailsInput, TransactionsMasterUncheckedUpdateWithoutGodownDetailsInput>
  }

  export type TransactionsMasterUpdateManyWithWhereWithoutGodownDetailsInput = {
    where: TransactionsMasterScalarWhereInput
    data: XOR<TransactionsMasterUpdateManyMutationInput, TransactionsMasterUncheckedUpdateManyWithoutGodownDetailsInput>
  }

  export type TransactionsUpsertWithWhereUniqueWithoutGodownDetailsInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutGodownDetailsInput, TransactionsUncheckedUpdateWithoutGodownDetailsInput>
    create: XOR<TransactionsCreateWithoutGodownDetailsInput, TransactionsUncheckedCreateWithoutGodownDetailsInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutGodownDetailsInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutGodownDetailsInput, TransactionsUncheckedUpdateWithoutGodownDetailsInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutGodownDetailsInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutGodownDetailsInput>
  }

  export type CompanyCreateWithoutFinancialYearsInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFinancialYearsInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFinancialYearsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFinancialYearsInput, CompanyUncheckedCreateWithoutFinancialYearsInput>
  }

  export type CompanyUpsertWithoutFinancialYearsInput = {
    update: XOR<CompanyUpdateWithoutFinancialYearsInput, CompanyUncheckedUpdateWithoutFinancialYearsInput>
    create: XOR<CompanyCreateWithoutFinancialYearsInput, CompanyUncheckedCreateWithoutFinancialYearsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFinancialYearsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFinancialYearsInput, CompanyUncheckedUpdateWithoutFinancialYearsInput>
  }

  export type CompanyUpdateWithoutFinancialYearsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFinancialYearsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutSeasonsInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSeasonsInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSeasonsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSeasonsInput, CompanyUncheckedCreateWithoutSeasonsInput>
  }

  export type CompanyUpsertWithoutSeasonsInput = {
    update: XOR<CompanyUpdateWithoutSeasonsInput, CompanyUncheckedUpdateWithoutSeasonsInput>
    create: XOR<CompanyCreateWithoutSeasonsInput, CompanyUncheckedCreateWithoutSeasonsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSeasonsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSeasonsInput, CompanyUncheckedUpdateWithoutSeasonsInput>
  }

  export type CompanyUpdateWithoutSeasonsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSeasonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutPoPrdCatsInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPoPrdCatsInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPoPrdCatsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPoPrdCatsInput, CompanyUncheckedCreateWithoutPoPrdCatsInput>
  }

  export type CompanyUpsertWithoutPoPrdCatsInput = {
    update: XOR<CompanyUpdateWithoutPoPrdCatsInput, CompanyUncheckedUpdateWithoutPoPrdCatsInput>
    create: XOR<CompanyCreateWithoutPoPrdCatsInput, CompanyUncheckedCreateWithoutPoPrdCatsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPoPrdCatsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPoPrdCatsInput, CompanyUncheckedUpdateWithoutPoPrdCatsInput>
  }

  export type CompanyUpdateWithoutPoPrdCatsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPoPrdCatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutDeliveryModesInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDeliveryModesInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDeliveryModesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDeliveryModesInput, CompanyUncheckedCreateWithoutDeliveryModesInput>
  }

  export type CompanyUpsertWithoutDeliveryModesInput = {
    update: XOR<CompanyUpdateWithoutDeliveryModesInput, CompanyUncheckedUpdateWithoutDeliveryModesInput>
    create: XOR<CompanyCreateWithoutDeliveryModesInput, CompanyUncheckedCreateWithoutDeliveryModesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDeliveryModesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDeliveryModesInput, CompanyUncheckedUpdateWithoutDeliveryModesInput>
  }

  export type CompanyUpdateWithoutDeliveryModesInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDeliveryModesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TransactionsMasterCreateWithoutUserInput = {
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    invoice_no?: string | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    company?: CompanyCreateNestedOneWithoutTransactionsMasterInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionsMasterInput
    acno?: ACNOCreateNestedOneWithoutTransactionsMasterInput
    transactions?: TransactionsCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterUncheckedCreateWithoutUserInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    transactions?: TransactionsUncheckedCreateNestedManyWithoutTransactionsMasterInput
  }

  export type TransactionsMasterCreateOrConnectWithoutUserInput = {
    where: TransactionsMasterWhereUniqueInput
    create: XOR<TransactionsMasterCreateWithoutUserInput, TransactionsMasterUncheckedCreateWithoutUserInput>
  }

  export type TransactionsMasterCreateManyUserInputEnvelope = {
    data: TransactionsMasterCreateManyUserInput | TransactionsMasterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutUsersInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type TransactionsMasterUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionsMasterWhereUniqueInput
    update: XOR<TransactionsMasterUpdateWithoutUserInput, TransactionsMasterUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionsMasterCreateWithoutUserInput, TransactionsMasterUncheckedCreateWithoutUserInput>
  }

  export type TransactionsMasterUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionsMasterWhereUniqueInput
    data: XOR<TransactionsMasterUpdateWithoutUserInput, TransactionsMasterUncheckedUpdateWithoutUserInput>
  }

  export type TransactionsMasterUpdateManyWithWhereWithoutUserInput = {
    where: TransactionsMasterScalarWhereInput
    data: XOR<TransactionsMasterUpdateManyMutationInput, TransactionsMasterUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TransactionsCreateWithoutCurrencyDetailsInput = {
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
    acnoDetails?: ACNOCreateNestedOneWithoutTransactionsInput
    costCenter?: CostCenterCreateNestedOneWithoutTransactionInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionInput
    itemDetails?: ItemCreateNestedOneWithoutTransactionsInput
    transactionsMaster: TransactionsMasterCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutCurrencyDetailsInput = {
    id?: number
    tran_id: number
    acno?: string | null
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsCreateOrConnectWithoutCurrencyDetailsInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutCurrencyDetailsInput, TransactionsUncheckedCreateWithoutCurrencyDetailsInput>
  }

  export type TransactionsCreateManyCurrencyDetailsInputEnvelope = {
    data: TransactionsCreateManyCurrencyDetailsInput | TransactionsCreateManyCurrencyDetailsInput[]
    skipDuplicates?: boolean
  }

  export type TransactionsUpsertWithWhereUniqueWithoutCurrencyDetailsInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutCurrencyDetailsInput, TransactionsUncheckedUpdateWithoutCurrencyDetailsInput>
    create: XOR<TransactionsCreateWithoutCurrencyDetailsInput, TransactionsUncheckedCreateWithoutCurrencyDetailsInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutCurrencyDetailsInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutCurrencyDetailsInput, TransactionsUncheckedUpdateWithoutCurrencyDetailsInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutCurrencyDetailsInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutCurrencyDetailsInput>
  }

  export type UsersCreateWithoutTransactionsMasterInput = {
    user_id: string
    user_name?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutTransactionsMasterInput = {
    user_id: string
    user_name?: string | null
    company_id: number
  }

  export type UsersCreateOrConnectWithoutTransactionsMasterInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutTransactionsMasterInput, UsersUncheckedCreateWithoutTransactionsMasterInput>
  }

  export type CompanyCreateWithoutTransactionsMasterInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTransactionsMasterInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTransactionsMasterInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTransactionsMasterInput, CompanyUncheckedCreateWithoutTransactionsMasterInput>
  }

  export type GodownCreateWithoutTransactionsMasterInput = {
    godown: string
    company: CompanyCreateNestedOneWithoutGodownsInput
    Transaction?: TransactionsCreateNestedManyWithoutGodownDetailsInput
  }

  export type GodownUncheckedCreateWithoutTransactionsMasterInput = {
    id?: number
    godown: string
    company_id: number
    Transaction?: TransactionsUncheckedCreateNestedManyWithoutGodownDetailsInput
  }

  export type GodownCreateOrConnectWithoutTransactionsMasterInput = {
    where: GodownWhereUniqueInput
    create: XOR<GodownCreateWithoutTransactionsMasterInput, GodownUncheckedCreateWithoutTransactionsMasterInput>
  }

  export type ACNOCreateWithoutTransactionsMasterInput = {
    acno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
    transactions?: TransactionsCreateNestedManyWithoutAcnoDetailsInput
    mainAccount: MACNOCreateNestedOneWithoutAccountsInput
  }

  export type ACNOUncheckedCreateWithoutTransactionsMasterInput = {
    acno: string
    macno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAcnoDetailsInput
  }

  export type ACNOCreateOrConnectWithoutTransactionsMasterInput = {
    where: ACNOWhereUniqueInput
    create: XOR<ACNOCreateWithoutTransactionsMasterInput, ACNOUncheckedCreateWithoutTransactionsMasterInput>
  }

  export type TransactionsCreateWithoutTransactionsMasterInput = {
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
    acnoDetails?: ACNOCreateNestedOneWithoutTransactionsInput
    costCenter?: CostCenterCreateNestedOneWithoutTransactionInput
    currencyDetails?: CurrencyCreateNestedOneWithoutTransactionsInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionInput
    itemDetails?: ItemCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutTransactionsMasterInput = {
    id?: number
    acno?: string | null
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsCreateOrConnectWithoutTransactionsMasterInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutTransactionsMasterInput, TransactionsUncheckedCreateWithoutTransactionsMasterInput>
  }

  export type TransactionsCreateManyTransactionsMasterInputEnvelope = {
    data: TransactionsCreateManyTransactionsMasterInput | TransactionsCreateManyTransactionsMasterInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutTransactionsMasterInput = {
    update: XOR<UsersUpdateWithoutTransactionsMasterInput, UsersUncheckedUpdateWithoutTransactionsMasterInput>
    create: XOR<UsersCreateWithoutTransactionsMasterInput, UsersUncheckedCreateWithoutTransactionsMasterInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutTransactionsMasterInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutTransactionsMasterInput, UsersUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type UsersUpdateWithoutTransactionsMasterInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutTransactionsMasterInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyUpsertWithoutTransactionsMasterInput = {
    update: XOR<CompanyUpdateWithoutTransactionsMasterInput, CompanyUncheckedUpdateWithoutTransactionsMasterInput>
    create: XOR<CompanyCreateWithoutTransactionsMasterInput, CompanyUncheckedCreateWithoutTransactionsMasterInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTransactionsMasterInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTransactionsMasterInput, CompanyUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type CompanyUpdateWithoutTransactionsMasterInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTransactionsMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type GodownUpsertWithoutTransactionsMasterInput = {
    update: XOR<GodownUpdateWithoutTransactionsMasterInput, GodownUncheckedUpdateWithoutTransactionsMasterInput>
    create: XOR<GodownCreateWithoutTransactionsMasterInput, GodownUncheckedCreateWithoutTransactionsMasterInput>
    where?: GodownWhereInput
  }

  export type GodownUpdateToOneWithWhereWithoutTransactionsMasterInput = {
    where?: GodownWhereInput
    data: XOR<GodownUpdateWithoutTransactionsMasterInput, GodownUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type GodownUpdateWithoutTransactionsMasterInput = {
    godown?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutGodownsNestedInput
    Transaction?: TransactionsUpdateManyWithoutGodownDetailsNestedInput
  }

  export type GodownUncheckedUpdateWithoutTransactionsMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    godown?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    Transaction?: TransactionsUncheckedUpdateManyWithoutGodownDetailsNestedInput
  }

  export type ACNOUpsertWithoutTransactionsMasterInput = {
    update: XOR<ACNOUpdateWithoutTransactionsMasterInput, ACNOUncheckedUpdateWithoutTransactionsMasterInput>
    create: XOR<ACNOCreateWithoutTransactionsMasterInput, ACNOUncheckedCreateWithoutTransactionsMasterInput>
    where?: ACNOWhereInput
  }

  export type ACNOUpdateToOneWithWhereWithoutTransactionsMasterInput = {
    where?: ACNOWhereInput
    data: XOR<ACNOUpdateWithoutTransactionsMasterInput, ACNOUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type ACNOUpdateWithoutTransactionsMasterInput = {
    acno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionsUpdateManyWithoutAcnoDetailsNestedInput
    mainAccount?: MACNOUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type ACNOUncheckedUpdateWithoutTransactionsMasterInput = {
    acno?: StringFieldUpdateOperationsInput | string
    macno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionsUncheckedUpdateManyWithoutAcnoDetailsNestedInput
  }

  export type TransactionsUpsertWithWhereUniqueWithoutTransactionsMasterInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutTransactionsMasterInput, TransactionsUncheckedUpdateWithoutTransactionsMasterInput>
    create: XOR<TransactionsCreateWithoutTransactionsMasterInput, TransactionsUncheckedCreateWithoutTransactionsMasterInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutTransactionsMasterInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutTransactionsMasterInput, TransactionsUncheckedUpdateWithoutTransactionsMasterInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutTransactionsMasterInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutTransactionsMasterInput>
  }

  export type ACNOCreateWithoutTransactionsInput = {
    acno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
    transactionsMaster?: TransactionsMasterCreateNestedManyWithoutAcnoInput
    mainAccount: MACNOCreateNestedOneWithoutAccountsInput
  }

  export type ACNOUncheckedCreateWithoutTransactionsInput = {
    acno: string
    macno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
    transactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutAcnoInput
  }

  export type ACNOCreateOrConnectWithoutTransactionsInput = {
    where: ACNOWhereUniqueInput
    create: XOR<ACNOCreateWithoutTransactionsInput, ACNOUncheckedCreateWithoutTransactionsInput>
  }

  export type CostCenterCreateWithoutTransactionInput = {
    ccname?: string | null
    company: CompanyCreateNestedOneWithoutCostCentersInput
  }

  export type CostCenterUncheckedCreateWithoutTransactionInput = {
    ccno?: number
    company_id: number
    ccname?: string | null
  }

  export type CostCenterCreateOrConnectWithoutTransactionInput = {
    where: CostCenterWhereUniqueInput
    create: XOR<CostCenterCreateWithoutTransactionInput, CostCenterUncheckedCreateWithoutTransactionInput>
  }

  export type CurrencyCreateWithoutTransactionsInput = {
    currency: string
  }

  export type CurrencyUncheckedCreateWithoutTransactionsInput = {
    id?: number
    currency: string
  }

  export type CurrencyCreateOrConnectWithoutTransactionsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutTransactionsInput, CurrencyUncheckedCreateWithoutTransactionsInput>
  }

  export type GodownCreateWithoutTransactionInput = {
    godown: string
    company: CompanyCreateNestedOneWithoutGodownsInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutGodownDetailsInput
  }

  export type GodownUncheckedCreateWithoutTransactionInput = {
    id?: number
    godown: string
    company_id: number
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutGodownDetailsInput
  }

  export type GodownCreateOrConnectWithoutTransactionInput = {
    where: GodownWhereUniqueInput
    create: XOR<GodownCreateWithoutTransactionInput, GodownUncheckedCreateWithoutTransactionInput>
  }

  export type ItemCreateWithoutTransactionsInput = {
    item?: string | null
    sku?: string | null
    price?: number | null
    stock?: number | null
    wc_product_id?: number | null
    wc_parent_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    itemCategories: ItemCategoryCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutTransactionsInput = {
    itcd?: number
    item?: string | null
    ic_id: number
    sku?: string | null
    price?: number | null
    stock?: number | null
    wc_product_id?: number | null
    wc_parent_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type ItemCreateOrConnectWithoutTransactionsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTransactionsInput, ItemUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionsMasterCreateWithoutTransactionsInput = {
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    invoice_no?: string | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
    user?: UsersCreateNestedOneWithoutTransactionsMasterInput
    company?: CompanyCreateNestedOneWithoutTransactionsMasterInput
    godownDetails?: GodownCreateNestedOneWithoutTransactionsMasterInput
    acno?: ACNOCreateNestedOneWithoutTransactionsMasterInput
  }

  export type TransactionsMasterUncheckedCreateWithoutTransactionsInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type TransactionsMasterCreateOrConnectWithoutTransactionsInput = {
    where: TransactionsMasterWhereUniqueInput
    create: XOR<TransactionsMasterCreateWithoutTransactionsInput, TransactionsMasterUncheckedCreateWithoutTransactionsInput>
  }

  export type ACNOUpsertWithoutTransactionsInput = {
    update: XOR<ACNOUpdateWithoutTransactionsInput, ACNOUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ACNOCreateWithoutTransactionsInput, ACNOUncheckedCreateWithoutTransactionsInput>
    where?: ACNOWhereInput
  }

  export type ACNOUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ACNOWhereInput
    data: XOR<ACNOUpdateWithoutTransactionsInput, ACNOUncheckedUpdateWithoutTransactionsInput>
  }

  export type ACNOUpdateWithoutTransactionsInput = {
    acno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUpdateManyWithoutAcnoNestedInput
    mainAccount?: MACNOUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type ACNOUncheckedUpdateWithoutTransactionsInput = {
    acno?: StringFieldUpdateOperationsInput | string
    macno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutAcnoNestedInput
  }

  export type CostCenterUpsertWithoutTransactionInput = {
    update: XOR<CostCenterUpdateWithoutTransactionInput, CostCenterUncheckedUpdateWithoutTransactionInput>
    create: XOR<CostCenterCreateWithoutTransactionInput, CostCenterUncheckedCreateWithoutTransactionInput>
    where?: CostCenterWhereInput
  }

  export type CostCenterUpdateToOneWithWhereWithoutTransactionInput = {
    where?: CostCenterWhereInput
    data: XOR<CostCenterUpdateWithoutTransactionInput, CostCenterUncheckedUpdateWithoutTransactionInput>
  }

  export type CostCenterUpdateWithoutTransactionInput = {
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutCostCentersNestedInput
  }

  export type CostCenterUncheckedUpdateWithoutTransactionInput = {
    ccno?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CurrencyUpsertWithoutTransactionsInput = {
    update: XOR<CurrencyUpdateWithoutTransactionsInput, CurrencyUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CurrencyCreateWithoutTransactionsInput, CurrencyUncheckedCreateWithoutTransactionsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutTransactionsInput, CurrencyUncheckedUpdateWithoutTransactionsInput>
  }

  export type CurrencyUpdateWithoutTransactionsInput = {
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type GodownUpsertWithoutTransactionInput = {
    update: XOR<GodownUpdateWithoutTransactionInput, GodownUncheckedUpdateWithoutTransactionInput>
    create: XOR<GodownCreateWithoutTransactionInput, GodownUncheckedCreateWithoutTransactionInput>
    where?: GodownWhereInput
  }

  export type GodownUpdateToOneWithWhereWithoutTransactionInput = {
    where?: GodownWhereInput
    data: XOR<GodownUpdateWithoutTransactionInput, GodownUncheckedUpdateWithoutTransactionInput>
  }

  export type GodownUpdateWithoutTransactionInput = {
    godown?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutGodownsNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutGodownDetailsNestedInput
  }

  export type GodownUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    godown?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutGodownDetailsNestedInput
  }

  export type ItemUpsertWithoutTransactionsInput = {
    update: XOR<ItemUpdateWithoutTransactionsInput, ItemUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ItemCreateWithoutTransactionsInput, ItemUncheckedCreateWithoutTransactionsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutTransactionsInput, ItemUncheckedUpdateWithoutTransactionsInput>
  }

  export type ItemUpdateWithoutTransactionsInput = {
    item?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemCategories?: ItemCategoryUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutTransactionsInput = {
    itcd?: IntFieldUpdateOperationsInput | number
    item?: NullableStringFieldUpdateOperationsInput | string | null
    ic_id?: IntFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsMasterUpsertWithoutTransactionsInput = {
    update: XOR<TransactionsMasterUpdateWithoutTransactionsInput, TransactionsMasterUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TransactionsMasterCreateWithoutTransactionsInput, TransactionsMasterUncheckedCreateWithoutTransactionsInput>
    where?: TransactionsMasterWhereInput
  }

  export type TransactionsMasterUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TransactionsMasterWhereInput
    data: XOR<TransactionsMasterUpdateWithoutTransactionsInput, TransactionsMasterUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionsMasterUpdateWithoutTransactionsInput = {
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UsersUpdateOneWithoutTransactionsMasterNestedInput
    company?: CompanyUpdateOneWithoutTransactionsMasterNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionsMasterNestedInput
    acno?: ACNOUpdateOneWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateWithoutTransactionsInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyCreateWithoutDeliveryTermsInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDeliveryTermsInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDeliveryTermsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDeliveryTermsInput, CompanyUncheckedCreateWithoutDeliveryTermsInput>
  }

  export type CompanyUpsertWithoutDeliveryTermsInput = {
    update: XOR<CompanyUpdateWithoutDeliveryTermsInput, CompanyUncheckedUpdateWithoutDeliveryTermsInput>
    create: XOR<CompanyCreateWithoutDeliveryTermsInput, CompanyUncheckedCreateWithoutDeliveryTermsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDeliveryTermsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDeliveryTermsInput, CompanyUncheckedUpdateWithoutDeliveryTermsInput>
  }

  export type CompanyUpdateWithoutDeliveryTermsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDeliveryTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutCommissionTermsInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCommissionTermsInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCommissionTermsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCommissionTermsInput, CompanyUncheckedCreateWithoutCommissionTermsInput>
  }

  export type CompanyUpsertWithoutCommissionTermsInput = {
    update: XOR<CompanyUpdateWithoutCommissionTermsInput, CompanyUncheckedUpdateWithoutCommissionTermsInput>
    create: XOR<CompanyCreateWithoutCommissionTermsInput, CompanyUncheckedCreateWithoutCommissionTermsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCommissionTermsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCommissionTermsInput, CompanyUncheckedUpdateWithoutCommissionTermsInput>
  }

  export type CompanyUpdateWithoutCommissionTermsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCommissionTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ManagerCreateWithoutEmployeesInput = {
    id?: string
  }

  export type ManagerUncheckedCreateWithoutEmployeesInput = {
    id?: string
  }

  export type ManagerCreateOrConnectWithoutEmployeesInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutEmployeesInput, ManagerUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployerCreateWithoutEmployeesInput = {
    employer_id: string
  }

  export type EmployerUncheckedCreateWithoutEmployeesInput = {
    employer_id: string
  }

  export type EmployerCreateOrConnectWithoutEmployeesInput = {
    where: EmployerWhereUniqueInput
    create: XOR<EmployerCreateWithoutEmployeesInput, EmployerUncheckedCreateWithoutEmployeesInput>
  }

  export type LeaveCreateWithoutEmployeeInput = {
    id?: string
    leave_id: string
    available: number
  }

  export type LeaveUncheckedCreateWithoutEmployeeInput = {
    id?: string
    leave_id: string
    available: number
  }

  export type LeaveCreateOrConnectWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveCreateManyEmployeeInputEnvelope = {
    data: LeaveCreateManyEmployeeInput | LeaveCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutEmployeeInput = {
    id?: string
    url: string
    name: string
    description?: string | null
  }

  export type DocumentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    url: string
    name: string
    description?: string | null
  }

  export type DocumentCreateOrConnectWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type DocumentCreateManyEmployeeInputEnvelope = {
    data: DocumentCreateManyEmployeeInput | DocumentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutEmployeesInput = {
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    designations?: DesignationCreateNestedManyWithoutCompanyInput
    godowns?: GodownCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterCreateNestedManyWithoutCompanyInput
    users?: UsersCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearCreateNestedManyWithoutCompanyInput
    seasons?: SeasonCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEmployeesInput = {
    id?: number
    company?: string | null
    addr1?: string | null
    addr2?: string | null
    city?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    designations?: DesignationUncheckedCreateNestedManyWithoutCompanyInput
    godowns?: GodownUncheckedCreateNestedManyWithoutCompanyInput
    TransactionsMaster?: TransactionsMasterUncheckedCreateNestedManyWithoutCompanyInput
    users?: UsersUncheckedCreateNestedManyWithoutCompanyInput
    financialYears?: FinancialYearUncheckedCreateNestedManyWithoutCompanyInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCompanyInput
    poPrdCats?: PoPrdCatUncheckedCreateNestedManyWithoutCompanyInput
    deliveryModes?: DeliveryModeUncheckedCreateNestedManyWithoutCompanyInput
    deliveryTerms?: DeliveryTermUncheckedCreateNestedManyWithoutCompanyInput
    commissionTerms?: CommissionTermUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEmployeesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
  }

  export type ManagerUpsertWithoutEmployeesInput = {
    update: XOR<ManagerUpdateWithoutEmployeesInput, ManagerUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ManagerCreateWithoutEmployeesInput, ManagerUncheckedCreateWithoutEmployeesInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutEmployeesInput, ManagerUncheckedUpdateWithoutEmployeesInput>
  }

  export type ManagerUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployerUpsertWithoutEmployeesInput = {
    update: XOR<EmployerUpdateWithoutEmployeesInput, EmployerUncheckedUpdateWithoutEmployeesInput>
    create: XOR<EmployerCreateWithoutEmployeesInput, EmployerUncheckedCreateWithoutEmployeesInput>
    where?: EmployerWhereInput
  }

  export type EmployerUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: EmployerWhereInput
    data: XOR<EmployerUpdateWithoutEmployeesInput, EmployerUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployerUpdateWithoutEmployeesInput = {
    employer_id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployerUncheckedUpdateWithoutEmployeesInput = {
    employer_id?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: StringFilter<"Leave"> | string
    leave_id?: StringFilter<"Leave"> | string
    available?: FloatFilter<"Leave"> | number
    employee_id?: StringFilter<"Leave"> | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutEmployeeInput, DocumentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutEmployeeInput, DocumentUncheckedUpdateWithoutEmployeeInput>
  }

  export type DocumentUpdateManyWithWhereWithoutEmployeeInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    employee_id?: StringFilter<"Document"> | string
  }

  export type CompanyUpsertWithoutEmployeesInput = {
    update: XOR<CompanyUpdateWithoutEmployeesInput, CompanyUncheckedUpdateWithoutEmployeesInput>
    create: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutEmployeesInput, CompanyUncheckedUpdateWithoutEmployeesInput>
  }

  export type CompanyUpdateWithoutEmployeesInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutCompanyNestedInput
    users?: UsersUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    addr1?: NullableStringFieldUpdateOperationsInput | string | null
    addr2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    designations?: DesignationUncheckedUpdateManyWithoutCompanyNestedInput
    godowns?: GodownUncheckedUpdateManyWithoutCompanyNestedInput
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UsersUncheckedUpdateManyWithoutCompanyNestedInput
    financialYears?: FinancialYearUncheckedUpdateManyWithoutCompanyNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCompanyNestedInput
    poPrdCats?: PoPrdCatUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryModes?: DeliveryModeUncheckedUpdateManyWithoutCompanyNestedInput
    deliveryTerms?: DeliveryTermUncheckedUpdateManyWithoutCompanyNestedInput
    commissionTerms?: CommissionTermUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EmployeeCreateWithoutLeavesInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    manager?: ManagerCreateNestedOneWithoutEmployeesInput
    employer: EmployerCreateNestedOneWithoutEmployeesInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    company: CompanyCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutLeavesInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    manager_id?: string | null
    client_id: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    company_id: number
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
  }

  export type EmployeeUpsertWithoutLeavesInput = {
    update: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneWithoutEmployeesNestedInput
    employer?: EmployerUpdateOneRequiredWithoutEmployeesNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: IntFieldUpdateOperationsInput | number
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutDocumentsInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    manager?: ManagerCreateNestedOneWithoutEmployeesInput
    employer: EmployerCreateNestedOneWithoutEmployeesInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    company: CompanyCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutDocumentsInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    manager_id?: string | null
    client_id: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    company_id: number
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDocumentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
  }

  export type EmployeeUpsertWithoutDocumentsInput = {
    update: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmployeeUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneWithoutEmployeesNestedInput
    employer?: EmployerUpdateOneRequiredWithoutEmployeesNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: IntFieldUpdateOperationsInput | number
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutManagerInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    employer: EmployerCreateNestedOneWithoutEmployeesInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    company: CompanyCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutManagerInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    client_id: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    company_id: number
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput>
  }

  export type EmployeeCreateManyManagerInputEnvelope = {
    data: EmployeeCreateManyManagerInput | EmployeeCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutManagerInput, EmployeeUncheckedUpdateWithoutManagerInput>
    create: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutManagerInput, EmployeeUncheckedUpdateWithoutManagerInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutManagerInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutManagerInput>
  }

  export type EmployeeCreateWithoutEmployerInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    manager?: ManagerCreateNestedOneWithoutEmployeesInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    company: CompanyCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutEmployerInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    manager_id?: string | null
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    company_id: number
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployerInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployerInput, EmployeeUncheckedCreateWithoutEmployerInput>
  }

  export type EmployeeCreateManyEmployerInputEnvelope = {
    data: EmployeeCreateManyEmployerInput | EmployeeCreateManyEmployerInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutEmployerInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutEmployerInput, EmployeeUncheckedUpdateWithoutEmployerInput>
    create: XOR<EmployeeCreateWithoutEmployerInput, EmployeeUncheckedCreateWithoutEmployerInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutEmployerInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutEmployerInput, EmployeeUncheckedUpdateWithoutEmployerInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutEmployerInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmployerInput>
  }

  export type BSCDCreateManyMainBscdInput = {
    bscd: string
    bscdDetail: string
  }

  export type BSCDUpdateWithoutMainBscdInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
    macnoItems?: MACNOUpdateManyWithoutBscdRefNestedInput
  }

  export type BSCDUncheckedUpdateWithoutMainBscdInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
    macnoItems?: MACNOUncheckedUpdateManyWithoutBscdRefNestedInput
  }

  export type BSCDUncheckedUpdateManyWithoutMainBscdInput = {
    bscd?: StringFieldUpdateOperationsInput | string
    bscdDetail?: StringFieldUpdateOperationsInput | string
  }

  export type MACNOCreateManyBscdRefInput = {
    macno: string
    macname: string
  }

  export type MACNOUpdateWithoutBscdRefInput = {
    macno?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
    accounts?: ACNOUpdateManyWithoutMainAccountNestedInput
  }

  export type MACNOUncheckedUpdateWithoutBscdRefInput = {
    macno?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
    accounts?: ACNOUncheckedUpdateManyWithoutMainAccountNestedInput
  }

  export type MACNOUncheckedUpdateManyWithoutBscdRefInput = {
    macno?: StringFieldUpdateOperationsInput | string
    macname?: StringFieldUpdateOperationsInput | string
  }

  export type ACNOCreateManyMainAccountInput = {
    acno: string
    acname: string
    bankAccountNo?: string | null
    address?: string | null
    city?: string | null
    phoneFax?: string | null
    email?: string | null
    website?: string | null
    crDays?: number | null
    stRate?: Decimal | DecimalJsLike | number | string | null
    area?: string | null
    category?: string | null
    subCategory?: string | null
    country?: string | null
    customerBank?: string | null
    customerBankAddr?: string | null
    stRegNo?: string | null
    ntnNo?: string | null
    contactPerson?: string | null
    crLimit?: number | null
    salesArea?: string | null
  }

  export type ACNOUpdateWithoutMainAccountInput = {
    acno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUpdateManyWithoutAcnoNestedInput
    transactions?: TransactionsUpdateManyWithoutAcnoDetailsNestedInput
  }

  export type ACNOUncheckedUpdateWithoutMainAccountInput = {
    acno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutAcnoNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAcnoDetailsNestedInput
  }

  export type ACNOUncheckedUpdateManyWithoutMainAccountInput = {
    acno?: StringFieldUpdateOperationsInput | string
    acname?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phoneFax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    crDays?: NullableIntFieldUpdateOperationsInput | number | null
    stRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    customerBank?: NullableStringFieldUpdateOperationsInput | string | null
    customerBankAddr?: NullableStringFieldUpdateOperationsInput | string | null
    stRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    ntnNo?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    crLimit?: NullableIntFieldUpdateOperationsInput | number | null
    salesArea?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionsMasterCreateManyAcnoInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type TransactionsCreateManyAcnoDetailsInput = {
    id?: number
    tran_id: number
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsMasterUpdateWithoutAcnoInput = {
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UsersUpdateOneWithoutTransactionsMasterNestedInput
    company?: CompanyUpdateOneWithoutTransactionsMasterNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionsMasterNestedInput
    transactions?: TransactionsUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateWithoutAcnoInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionsUncheckedUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateManyWithoutAcnoInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsUpdateWithoutAcnoDetailsInput = {
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: CostCenterUpdateOneWithoutTransactionNestedInput
    currencyDetails?: CurrencyUpdateOneWithoutTransactionsNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionNestedInput
    itemDetails?: ItemUpdateOneWithoutTransactionsNestedInput
    transactionsMaster?: TransactionsMasterUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutAcnoDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsUncheckedUpdateManyWithoutAcnoDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CostCenterCreateManyCompanyInput = {
    ccno?: number
    ccname?: string | null
  }

  export type DepartmentCreateManyCompanyInput = {
    id?: number
    dept_name?: string | null
  }

  export type DesignationCreateManyCompanyInput = {
    id?: number
    desg_name?: string | null
  }

  export type GodownCreateManyCompanyInput = {
    id?: number
    godown: string
  }

  export type TransactionsMasterCreateManyCompanyInput = {
    tran_id?: number
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type UsersCreateManyCompanyInput = {
    user_id: string
    user_name?: string | null
  }

  export type FinancialYearCreateManyCompanyInput = {
    id?: number
    date_from: Date | string
    date_to: Date | string
    status: string
  }

  export type SeasonCreateManyCompanyInput = {
    id?: number
    date_from: Date | string
    date_to: Date | string
    status: string
  }

  export type PoPrdCatCreateManyCompanyInput = {
    id?: number
    category_name: string
  }

  export type DeliveryModeCreateManyCompanyInput = {
    id?: number
    delivery_mode: string
    rate_kg: number
  }

  export type DeliveryTermCreateManyCompanyInput = {
    id?: number
    delivery_term: string
  }

  export type CommissionTermCreateManyCompanyInput = {
    id?: number
    commission_term: string
  }

  export type EmployeeCreateManyCompanyInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    manager_id?: string | null
    client_id: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
  }

  export type CostCenterUpdateWithoutCompanyInput = {
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
    Transaction?: TransactionsUpdateManyWithoutCostCenterNestedInput
  }

  export type CostCenterUncheckedUpdateWithoutCompanyInput = {
    ccno?: IntFieldUpdateOperationsInput | number
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
    Transaction?: TransactionsUncheckedUpdateManyWithoutCostCenterNestedInput
  }

  export type CostCenterUncheckedUpdateManyWithoutCompanyInput = {
    ccno?: IntFieldUpdateOperationsInput | number
    ccname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUpdateWithoutCompanyInput = {
    dept_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dept_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dept_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DesignationUpdateWithoutCompanyInput = {
    desg_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DesignationUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    desg_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DesignationUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    desg_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GodownUpdateWithoutCompanyInput = {
    godown?: StringFieldUpdateOperationsInput | string
    TransactionsMaster?: TransactionsMasterUpdateManyWithoutGodownDetailsNestedInput
    Transaction?: TransactionsUpdateManyWithoutGodownDetailsNestedInput
  }

  export type GodownUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    godown?: StringFieldUpdateOperationsInput | string
    TransactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutGodownDetailsNestedInput
    Transaction?: TransactionsUncheckedUpdateManyWithoutGodownDetailsNestedInput
  }

  export type GodownUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    godown?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionsMasterUpdateWithoutCompanyInput = {
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UsersUpdateOneWithoutTransactionsMasterNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionsMasterNestedInput
    acno?: ACNOUpdateOneWithoutTransactionsMasterNestedInput
    transactions?: TransactionsUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateWithoutCompanyInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionsUncheckedUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateManyWithoutCompanyInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersUpdateWithoutCompanyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutCompanyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsMaster?: TransactionsMasterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutCompanyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialYearUpdateWithoutCompanyInput = {
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialYearUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialYearUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SeasonUpdateWithoutCompanyInput = {
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SeasonUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SeasonUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_from?: DateTimeFieldUpdateOperationsInput | Date | string
    date_to?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PoPrdCatUpdateWithoutCompanyInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type PoPrdCatUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type PoPrdCatUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryModeUpdateWithoutCompanyInput = {
    delivery_mode?: StringFieldUpdateOperationsInput | string
    rate_kg?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryModeUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_mode?: StringFieldUpdateOperationsInput | string
    rate_kg?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryModeUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_mode?: StringFieldUpdateOperationsInput | string
    rate_kg?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryTermUpdateWithoutCompanyInput = {
    delivery_term?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryTermUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_term?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryTermUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_term?: StringFieldUpdateOperationsInput | string
  }

  export type CommissionTermUpdateWithoutCompanyInput = {
    commission_term?: StringFieldUpdateOperationsInput | string
  }

  export type CommissionTermUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commission_term?: StringFieldUpdateOperationsInput | string
  }

  export type CommissionTermUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commission_term?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneWithoutEmployeesNestedInput
    employer?: EmployerUpdateOneRequiredWithoutEmployeesNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsCreateManyCostCenterInput = {
    id?: number
    tran_id: number
    acno?: string | null
    itcd?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsUpdateWithoutCostCenterInput = {
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    acnoDetails?: ACNOUpdateOneWithoutTransactionsNestedInput
    currencyDetails?: CurrencyUpdateOneWithoutTransactionsNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionNestedInput
    itemDetails?: ItemUpdateOneWithoutTransactionsNestedInput
    transactionsMaster?: TransactionsMasterUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutCostCenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsUncheckedUpdateManyWithoutCostCenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductGroupCreateManyProductMasterCategoriesInput = {
    id?: number
    pg_name?: string | null
  }

  export type ProductGroupUpdateWithoutProductMasterCategoriesInput = {
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
    productCategories?: ProductCategoryUpdateManyWithoutProductGroupsNestedInput
  }

  export type ProductGroupUncheckedUpdateWithoutProductMasterCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutProductGroupsNestedInput
  }

  export type ProductGroupUncheckedUpdateManyWithoutProductMasterCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    pg_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryCreateManyProductGroupsInput = {
    id?: number
    pc_name?: string | null
  }

  export type ProductCategoryUpdateWithoutProductGroupsInput = {
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
    mainCategories?: MainCategoryUpdateManyWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
    mainCategories?: MainCategoryUncheckedUpdateManyWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MainCategoryCreateManyProductCategoriesInput = {
    id?: number
    mc_name?: string | null
  }

  export type MainCategoryUpdateWithoutProductCategoriesInput = {
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategories?: ItemCategoryUpdateManyWithoutMainCategoryNestedInput
  }

  export type MainCategoryUncheckedUpdateWithoutProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategories?: ItemCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput
  }

  export type MainCategoryUncheckedUpdateManyWithoutProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mc_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCategoryCreateManyMainCategoryInput = {
    id?: number
    ic_name: string
    wc_category_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type ItemCategoryUpdateWithoutMainCategoryInput = {
    ic_name?: StringFieldUpdateOperationsInput | string
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUpdateManyWithoutItemCategoriesNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutMainCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    ic_name?: StringFieldUpdateOperationsInput | string
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUncheckedUpdateManyWithoutItemCategoriesNestedInput
  }

  export type ItemCategoryUncheckedUpdateManyWithoutMainCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    ic_name?: StringFieldUpdateOperationsInput | string
    wc_category_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCreateManyItemCategoriesInput = {
    itcd?: number
    item?: string | null
    sku?: string | null
    price?: number | null
    stock?: number | null
    wc_product_id?: number | null
    wc_parent_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type ItemUpdateWithoutItemCategoriesInput = {
    item?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Transactions?: TransactionsUpdateManyWithoutItemDetailsNestedInput
  }

  export type ItemUncheckedUpdateWithoutItemCategoriesInput = {
    itcd?: IntFieldUpdateOperationsInput | number
    item?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Transactions?: TransactionsUncheckedUpdateManyWithoutItemDetailsNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItemCategoriesInput = {
    itcd?: IntFieldUpdateOperationsInput | number
    item?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    wc_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    wc_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsCreateManyItemDetailsInput = {
    id?: number
    tran_id: number
    acno?: string | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsUpdateWithoutItemDetailsInput = {
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    acnoDetails?: ACNOUpdateOneWithoutTransactionsNestedInput
    costCenter?: CostCenterUpdateOneWithoutTransactionNestedInput
    currencyDetails?: CurrencyUpdateOneWithoutTransactionsNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionNestedInput
    transactionsMaster?: TransactionsMasterUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutItemDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsUncheckedUpdateManyWithoutItemDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsMasterCreateManyGodownDetailsInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    userId?: string | null
    invoice_no?: string | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type TransactionsCreateManyGodownDetailsInput = {
    id?: number
    tran_id: number
    acno?: string | null
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsMasterUpdateWithoutGodownDetailsInput = {
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UsersUpdateOneWithoutTransactionsMasterNestedInput
    company?: CompanyUpdateOneWithoutTransactionsMasterNestedInput
    acno?: ACNOUpdateOneWithoutTransactionsMasterNestedInput
    transactions?: TransactionsUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateWithoutGodownDetailsInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionsUncheckedUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateManyWithoutGodownDetailsInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsUpdateWithoutGodownDetailsInput = {
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    acnoDetails?: ACNOUpdateOneWithoutTransactionsNestedInput
    costCenter?: CostCenterUpdateOneWithoutTransactionNestedInput
    currencyDetails?: CurrencyUpdateOneWithoutTransactionsNestedInput
    itemDetails?: ItemUpdateOneWithoutTransactionsNestedInput
    transactionsMaster?: TransactionsMasterUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutGodownDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsUncheckedUpdateManyWithoutGodownDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsMasterCreateManyUserInput = {
    tran_id?: number
    company_id?: number | null
    dateD?: Date | string | null
    time?: Date | string | null
    tran_code?: number | null
    vr_no?: number | null
    pycd?: string | null
    check_no?: string | null
    check_date?: Date | string | null
    rmk?: string | null
    rmk1?: string | null
    rmk2?: string | null
    rmk3?: string | null
    rmk4?: string | null
    rmk5?: string | null
    invoice_no?: string | null
    godown?: number | null
    wc_order_id?: number | null
    sync_status?: string | null
    last_sync?: Date | string | null
  }

  export type TransactionsMasterUpdateWithoutUserInput = {
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutTransactionsMasterNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionsMasterNestedInput
    acno?: ACNOUpdateOneWithoutTransactionsMasterNestedInput
    transactions?: TransactionsUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateWithoutUserInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionsUncheckedUpdateManyWithoutTransactionsMasterNestedInput
  }

  export type TransactionsMasterUncheckedUpdateManyWithoutUserInput = {
    tran_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    dateD?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tran_code?: NullableIntFieldUpdateOperationsInput | number | null
    vr_no?: NullableIntFieldUpdateOperationsInput | number | null
    pycd?: NullableStringFieldUpdateOperationsInput | string | null
    check_no?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rmk?: NullableStringFieldUpdateOperationsInput | string | null
    rmk1?: NullableStringFieldUpdateOperationsInput | string | null
    rmk2?: NullableStringFieldUpdateOperationsInput | string | null
    rmk3?: NullableStringFieldUpdateOperationsInput | string | null
    rmk4?: NullableStringFieldUpdateOperationsInput | string | null
    rmk5?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    wc_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    sync_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsCreateManyCurrencyDetailsInput = {
    id?: number
    tran_id: number
    acno?: string | null
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsUpdateWithoutCurrencyDetailsInput = {
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    acnoDetails?: ACNOUpdateOneWithoutTransactionsNestedInput
    costCenter?: CostCenterUpdateOneWithoutTransactionNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionNestedInput
    itemDetails?: ItemUpdateOneWithoutTransactionsNestedInput
    transactionsMaster?: TransactionsMasterUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutCurrencyDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsUncheckedUpdateManyWithoutCurrencyDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tran_id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsCreateManyTransactionsMasterInput = {
    id?: number
    acno?: string | null
    itcd?: number | null
    ccno?: number | null
    narration1?: string | null
    narration2?: string | null
    narration3?: string | null
    narration4?: string | null
    narration5?: string | null
    chno?: string | null
    check_date?: Date | string | null
    party_name?: string | null
    damt?: number | null
    camt?: number | null
    qty?: number | null
    rate?: number | null
    wht_rate?: number | null
    st_rate?: number | null
    godown?: number | null
    invoice_no?: string | null
    sub_tran_id?: number | null
    currency?: number | null
    gross_amount?: number | null
    fc_amount?: number | null
    no_of_pack?: number | null
    qty_per_pack?: number | null
    st_amount?: number | null
    additional_tax?: number | null
  }

  export type TransactionsUpdateWithoutTransactionsMasterInput = {
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    acnoDetails?: ACNOUpdateOneWithoutTransactionsNestedInput
    costCenter?: CostCenterUpdateOneWithoutTransactionNestedInput
    currencyDetails?: CurrencyUpdateOneWithoutTransactionsNestedInput
    godownDetails?: GodownUpdateOneWithoutTransactionNestedInput
    itemDetails?: ItemUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutTransactionsMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionsUncheckedUpdateManyWithoutTransactionsMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    acno?: NullableStringFieldUpdateOperationsInput | string | null
    itcd?: NullableIntFieldUpdateOperationsInput | number | null
    ccno?: NullableIntFieldUpdateOperationsInput | number | null
    narration1?: NullableStringFieldUpdateOperationsInput | string | null
    narration2?: NullableStringFieldUpdateOperationsInput | string | null
    narration3?: NullableStringFieldUpdateOperationsInput | string | null
    narration4?: NullableStringFieldUpdateOperationsInput | string | null
    narration5?: NullableStringFieldUpdateOperationsInput | string | null
    chno?: NullableStringFieldUpdateOperationsInput | string | null
    check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    damt?: NullableFloatFieldUpdateOperationsInput | number | null
    camt?: NullableFloatFieldUpdateOperationsInput | number | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    wht_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    st_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    godown?: NullableIntFieldUpdateOperationsInput | number | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tran_id?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableIntFieldUpdateOperationsInput | number | null
    gross_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    fc_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    no_of_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    qty_per_pack?: NullableFloatFieldUpdateOperationsInput | number | null
    st_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_tax?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LeaveCreateManyEmployeeInput = {
    id?: string
    leave_id: string
    available: number
  }

  export type DocumentCreateManyEmployeeInput = {
    id?: string
    url: string
    name: string
    description?: string | null
  }

  export type LeaveUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leave_id?: StringFieldUpdateOperationsInput | string
    available?: FloatFieldUpdateOperationsInput | number
  }

  export type LeaveUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leave_id?: StringFieldUpdateOperationsInput | string
    available?: FloatFieldUpdateOperationsInput | number
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leave_id?: StringFieldUpdateOperationsInput | string
    available?: FloatFieldUpdateOperationsInput | number
  }

  export type DocumentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateManyManagerInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    client_id: string
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    company_id: number
  }

  export type EmployeeUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: EmployerUpdateOneRequiredWithoutEmployeesNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: IntFieldUpdateOperationsInput | number
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeCreateManyEmployerInput = {
    id?: string
    first_name: string
    middle_name?: string | null
    surname: string
    dob: Date | string
    gender?: $Enums.Gender | null
    phone_number: string
    npf_number: string
    email_address: string
    village: string
    status?: $Enums.Status | null
    hire_date: Date | string
    job_title: string
    department: string
    work_location: string
    manager_id?: string | null
    employee_id: string
    payment_method?: $Enums.PaymentMethod | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    pay_type?: $Enums.PayType | null
    rate_per_hour: number
    pay_frequency?: $Enums.PayFrequency | null
    employee_type: string
    cost_center: string
    allownces: JsonNullValueInput | InputJsonValue
    allownce_eligible?: boolean
    deductions: JsonNullValueInput | InputJsonValue
    profile_image?: string | null
    created_on?: Date | string
    updated_on?: Date | string
    company_id: number
  }

  export type EmployeeUpdateWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneWithoutEmployeesNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: IntFieldUpdateOperationsInput | number
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phone_number?: StringFieldUpdateOperationsInput | string
    npf_number?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    village?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    hire_date?: DateTimeFieldUpdateOperationsInput | Date | string
    job_title?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    work_location?: StringFieldUpdateOperationsInput | string
    manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    employee_id?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableEnumPayTypeFieldUpdateOperationsInput | $Enums.PayType | null
    rate_per_hour?: FloatFieldUpdateOperationsInput | number
    pay_frequency?: NullableEnumPayFrequencyFieldUpdateOperationsInput | $Enums.PayFrequency | null
    employee_type?: StringFieldUpdateOperationsInput | string
    cost_center?: StringFieldUpdateOperationsInput | string
    allownces?: JsonNullValueInput | InputJsonValue
    allownce_eligible?: BoolFieldUpdateOperationsInput | boolean
    deductions?: JsonNullValueInput | InputJsonValue
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_on?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}